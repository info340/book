[["index.html", "Client-Side Web Development About the Book", " Client-Side Web Development Joel Ross February 11, 2025 About the Book About the Book This book covers the the skills and techniques necessary for creating sophisticated and accessible interactive web applications. It focuses on the client-side languages, tools, and libraries that professionals use to build the web sites you use every day. It assumes a basic background in computer programming (e.g., introductory programming in Java or Python), and some concepts from the technical foundations of informatics). These materials were developed for the INFO 340: Client-Side Web Development course taught at the University of Washington Information School; however they have been structured to be an online resource for anyone who wishes to learn web programming. This book is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. This book is open source. Visit us on GitHub to contribute improvements. Acknowledgements Some chapters originally authored by and Mike Freeman. Some content was originally adapted from tutorials by David Stearns. Some structure and explanations inspired by Learning Web Design by Jennifer Robbins. "],["software-setup.html", "Chapter 1 Getting Setup 1.1 Web Browser 1.2 Code Editor 1.3 Bash (Command Line) 1.4 Node and npm 1.5 Git and GitHub Resources", " Chapter 1 Getting Setup This course will cover and use a wide variety of tools and techniques common to modern web development, including different software programs that are used to write, manage, and execute the code for your web application. This chapter explains how to install and use some of the software you will need to build these applications. Note that iSchool lab machines should have all appropriate software already installed and ready to use. In summary, you’ll need to install and set up the following software on your machine (more information below on each of these). Feel free to use alternative software, but these are the suggested programs for the course (i.e., the ones which we will provide support for): A modern web browser such as Google Chrome Visual Studio Code as a code editor for writing code Node.js, a JavaScript engine npm, a JavaScript package manager that comes with Node.js A Bash terminal (e.g., the Git Bash for Windows; Terminal is already installed on Macs). git as a version control system (for Windows users; already installed on Macs) 1.1 Web Browser The first thing you’ll need is a web browser for viewing the web pages you make! I recommend you install and use Chrome, which comes with an effective set of built-in developer tools that will be especially useful in this class. I recommend Chrome primarily for historical reasons (and because it is the browser used by the author—and I had to pick one!). You can access the Chrome Developer tools by selecting View &gt; Developer &gt; Developer Tools from Chrome’s main menu (cmd + option + i on a Mac, ctrl + shift + i on Windows). You will pretty much always want to have these tools open when doing web development, especially when including interactivity via JavaScript. Other modern browsers such as Firefox or Microsoft Edge will also function perfectly well in this course and include their own versions of the required development tools. Note that different browsers may and will render code in different ways, which will be discussed extensively throughout the course. I strongly suggest that you don’t use Safari, as it has a number of user interface and rendering issues that make it difficult to develop with for this course. 1.2 Code Editor In order to write web code, you need somewhere to write it. There are a variety of code editors and IDEs (Integrated Development Environments) that are specialized for web development, providing syntax highlighting, code completion, and other useful functionality. There are lots of different code editors out there, all of which have slightly different appearances and features; you only need to download and use one of the following programs. I strongly recommend Visual Studio Code as a default, but feel free to try out different ones to find something you like (and then evangelize about it to your friends!) Visual Studio Code Visual Studio Code (or VS Code; not to be confused with Visual Studio) is a free, open-source editor developed by Microsoft—yes, really. It focuses on web programming and JavaScript, though also supports many other languages and provides a number of community-built extensions for adding even more features. It is one of the most common editors for programming and web development in particular. VS Code is actually a stand-alone web application, so it’s written in the same HTML, CSS, and JavaScript you’ll learn in this course! To install VS Code, follow the above link and Click the “Download” button to download the installer (e.g, .dmg or .exe) file, then double-click on that to install the application. VS Code is highly customizable with very many features. For more information about using VS Code, see the documentation, which includes videos if you find them useful. The documentation for programming in HTML, CSS, and especially JavaScript also contain lots of tips and tricks. You can open a file in VS Code by using the File &gt; Open... command. Because web development often involves working with lots of different files at once, it’s often more effective to open an entire folder at once using File &gt; Open Folder.... This will list all of the files in that folder in a sidebar, and you can double-click on each file to open it up in its own tab. You can also manage files from the sidebar: moving them, making folders, or renaming them through the context (right-click) menu. Note that when VS code files are open in tabs, they will show an “x” on the right of the tab to close it. But if the file has been modified, that “x” will instead be a filled-in circle, indicating that there are unsaved changed to the file. Watch out for this: its a good way to catch if you forgot to save your work (and thats why your changes aren’t showing up!) One more trick to using VS Code effectively is to get comfortable with the Command Palette. If you hit cmd + shift + p, VS Code will open a small dialog where you can search for whatever you want the editor to do. For example, if you type in markdown you can get list of commands related to Markdown files (including the ability to open up a preview). The Format Code option is also particularly useful for fixing spacing issues in your code. While VS Code is relatively unobtrusive when compared to otehr IDEs, be very careful about using its auto-complete or AI-based features. Often the editor will try and help or “fix” your code by adding in wrong solutions, which then cause further unexpected problems later. Make sure that any code that is written into your files are lines that you understand and can debug! 1.2.1 Other Editors While we suggest using VSCode for this course, other editors are also acceptable and may be of interest to you. Note that these Sublime Text is an older but popular text editor with excellent defaults and a variety of available extensions (though you’ll need to manage and install extensions to achieve the functionality offered by other editors out of the box). While the software can be used for free, every 20 or so saves it will prompt you to purchase the full version. This is a great option to write a plain text file. WebStorm is a full-featured IDE from JetBrains (the makers of IntelliJ for Java). While it can offer some useful features, it is also likely to produce a lot of “cruft” or guide your coding in particular ways. I recommend you only use it after you have mastered the basics (such as by finishing this course!) so that you understand the choices it is making. Atom was a text editor built by the folks at GitHub, though it has since been retired. It was very similar to VS Code in terms of features, but has a somewhat different interface and community. It had a similar command-palette to VS Code. The document you are reading was authored in Atom, which is why it remains on this list. The Pulsar project is a fork of the Atom editor. 1.3 Bash (Command Line) Many of the software tools used in professional web development are used on the command line: a text-based interface for controlling your computer. While the command line is harder to learn and figure out, it is particularly effective for doing web development. Command line automation is powerful and efficient enough to handle the dozens of repeated tasks across hundreds of different source files (split across multiple computers) commonly found in web programming. You will need to be comfortable using the command line in order to utilize the software for this course. While there are multiple different command shells (command line interfaces), this course uses the Bash shell, which provides a particular common set of commands common to Mac and Linux machines. What you install depends on your operating system: On a Mac you’ll want to use the built-in app called Terminal. You can open it by searching via Spotlight (hit Cmd (⌘) and Spacebar together, type in “terminal”, then select the app to open it), or by finding it in the Applications/Utilities folder. As of macOS Catalina, Macs use zsh as the default command shell with Terminal. This works mostly the same as Bash (supporting generally the same command). It is also possible to switch between the two shells if needed. On Windows, you can use the Git Bash shell, which you should install along with git (see below). Open this program to open the command shell. Note that Windows does come with its own command shell, called the Command Prompt (previously the DOS Prompt), but it has a different set of commands and features. Powershell is a more powerful version of the Command Prompt if you really want to get into the Windows Management Framework. But Bash is more common in open-source programming like we’ll be doing, and so we will be focusing on that set of commands. Some software used in this course will not work with the Command Prompt or Powershell; you will need to have and use a Bash-type shell installed. This course expects you to already be familiar with basic command line usage. For review, see e.g., The Command Line in the INFO 201 course reader. 1.4 Node and npm Node.js (commonly just “Node”) is a a command line runtime environment for the JavaScript programming language—that is, a program that is used to interpret and execute programming instructions written in JavaScript. Although client-side development usually involves running JavaScript in the browser (see Chapter: JavaScript), Node provides a platform for installing and running a wide variety of “helper” programs that are frequently used in web development. The easiest way to install Node is to use the installer from Nodejs.org. I recommend getting the latest version for this course. Download the installer and execute it to set up Node on your machine. If you want more control over your machine and Node versions, you can alternatively install Node using nvm, the Node Version Manager. This is a command line program that manages installing the Node command line program, but also makes it easy to update or adjust your Node installation. See the installation instructions for details. You can test that Node is installed and working by opening your command shell and running node --version Be sure and check that you have a recent enough version! At time of this writing, you should have Node v18 or later. Installing Node also installs an additional command line program called npm. npm is a package manager, or a program used to “manage” other programs—think of it as a command line “app store” for developer tools and libraries. npm is the most common way of installing and running a large number of tools used in professional web development. As of September 2022, the npm “registry” included more than 2.1 million different packages. You will need to have at least v5.6 of npm installed. Installing the latest Node should give you the latest npm as well, but you can also upgrade npm using the command npm install npm@latest -g. See below for an explanation of this command. Installing software with npm You can use the npm program to download and install command line programs by name: # syntax to globally install package with npm npm install -g PACKAGE-NAME For example, you could install the Jest testing application (a program for running automated tests) used in this course using: # globally install the Jest package npm install -g jest Importantly, note the included -g option. This tells npm that the package should be installed globally, making it available across the entire computer, rather than just from a particular folder. Because you want to be able to use a command line program like Jest from any folder (e.g., for any project), command line utilities are always installed globally with the -g option. Installing an application globally often requires administrator permissions. If you try to install something without admin permission, you’ll get an error saying permission denied: In order to install programs globally, you will need to use the sudo (superuser do) command to run the install as an administrator. You do this by putting sudo in front of the command you want to run, for example: # as an administrator, globally install the Jest package sudo npm install -g jest You will be prompted for your computer’s password, make sure to fill that in (even though you won’t see any typing occur). Note that you should only use sudo when absolutely necessary (e.g., when you hit this error); don’t run every command as an administrator! After an application is installed through npm, you can run that program from the command line by typing its name followed by any arguments. For example, you can have the Jest program print its version: # get the version of the installed Jest application jest --version The latest version of npm also comes with an additional program called npx. This application lets you “download and run” an application without installing it separately. For example, you could download and run Jest to see it’s version; note that you don’t ever need to call npm install for jest when using npx: # download and run the Jest application without installing it separately npx jest --version Managing local packages It is also possible to install packages locally by omitting the -g argument. For example: npm install lodash This command will download the lodash code library (a set of useful JavaScript functions). This package will be placed into a new folder in the current project directory called node_modules/, and can be imported and used in the current directory’s code. (It’s called a local install because the package is only available to the “local” project). You will need to install local packages once per project. Because node packages can be very large, and projects can have lots of them, you want to be sure to not commit the node_modules/ folder to version control. Make sure that the folder is listed in your .gitignore file! As projects become large, it is common for them to build up many dependencies: packages that must be installed in order for the program to work. In other words, there needs to be a certain set of packages in the project’s node_modules/ folder. npm is able to keep track of these dependencies by recording them in a specialized file called package.json that can be placed inside the project directory. A package.json file is a text file containing a JSON list of information about your project. For example: { \"name\": \"example\", \"version\": \"1.0.0\", \"private\": true, \"description\": \"A project with an example package.json\", \"main\": \"index.js\", \"scripts\": { \"test\": \"jest\" }, \"author\": \"Joel Ross\", \"license\": \"ISC\", \"dependencies\": { \"lodash\": \"^4.17.4\", \"moment\": \"^2.18.1\" }, \"devDependencies\": { \"html-validator\": \"^2.2.2\" } } (You can create one of these files by using the command npm init in the current project directory, and then following the instructions to fill in the fields). Notice that there are two packages listed under \"dependencies\": lodash and moment (the ^4.17.4 indicates which version of lodash—one that is at least 4.17.4). You can use npm to automatically install all of the packages listed under \"dependencies\" (as well as under \"devDependencies\") in the package.json file using the command: npm install Using npm install without any arguments means “install all of the requirements that have been recorded for this project”. This is a good first step any time you download a project or checkout a repository from GitHub! You can run the npm install command as many times as you wish: if the package has already been installed (into the node_modules/ folder), it won’t be downloaded again. Only “missing” packages—such as those recently added to the package.json file—will be installed. Because all local packages are saved in the node_modules/ folder, that folder is a common target when troubleshooting package installation issues. For example, if package does not seem to be importing correctly, a common step is to delete the node_modules folder and then try again! Note that while the package.json file lists the desired dependencies for a project, the package-lock.json file lists the specific versions of dependencies (and the dependencies of the dependencies!) that have actually been installed. This is to make sure that if a package received a minor update (e.g., from 4.17.18 to 4.17.19) that has a bug, you won’t accidentally install that version and break your project. The package-lock.json file is automatically generated every time you install or re-install a local package. Changes to this file are a good way to check if you’ve accidentally installed a different version of a dependency. When installing specific packages (e.g., with npm install package-name), npm automatically adds them to the dependencies list in the package.json. You can also make this recording explicit with the --save option: # explicitly save dependency in package.json npm install --save lodash This means that every time you want to “add” a packagae to your project, you just need to install it once and it will automatically be saved in the package.json file (so that it can be installed alongside the rest of the dependencies with npm install). Similarly, the --save-dev option will instead save the package in the \"devDependencies\" list, which are dependencies needed only for development (writing the program’s code) and not for execution (running the program). Whether you are in “development” or “production” mode depends on the configuration of your Node environment; by default everything is in development mode so there is no distinction between the two lists. You can uninstall packages using npm uninstall, or can remove packages from the dependencies lists simply by editing the package.json file (e.g., with VS Code). To sum up, you will use three commands with npm to install packages: npm install -g PACKAGE-NAME to globally install command line programs. npm install to locally install all of the dependencies for a project you check out. npm install PACKAGE-NAME to locally install a new code package and record it in the package.json file. While npm is the most popular package manager (and the one used in this course), there are others as well. For example, Yarn is a package manager created by Facebook that is compatible with npm and is quickly growing in popularity. Note that you will generally need to use one package manager or other; don’t try to mix them in a single project! 1.5 Git and GitHub Professional web development involves many different people working on many different files. git is a collaborative version control system that provides a set of commands that allow you to manage changes to written code, particularly when collaborating with other programmers. This course expects you to already be familiar with using Git and GitHub. For review, see Git and GitHub, Git Branches, and Git Collaboration in the INFO 201 course reader. Note that students in the INFO 340 course will use git and GitHub to turn in programming assignments. For this course, you will need to download and install the git software program in order to use it. If you are on a Mac, git should already be installed. If you are using a Windows machine, then installing git will also install the Git Bash command shell. Note that git is a command line application: you can test that it is installed by running the command: git --version Some coding editors such as VS Code have also integrated git commands and information, so that you can see e.g., what files have been modified since the last commit (new files are colored green in the file list sidebar; new files are colored yellow). Note however that this course focuses on the command line use of git in order to best understand what commands are being run to manage code versions. While git is the software used to manage versions of code, GitHub is a website that is used to store copies online copies of computer code that are being managed with git. In order to use GitHub, you’ll need to have a free GitHub account. You should register a username that is identifiable as you (e.g., based on your name or your UW NetID). This will make it easier for others to determine out who contributed what code, rather than needing to gudess who ‘LeetDesigner2099’ is. This can be the start of a professional account you may use for the rest of your career! In order to push and pull to GitHub from the command line, you’ll need to set up a Personal Access Token (PAT) for GitHub. This is like a specialized password whose access you can control, rather than using your “full account” password. If you don’t have a working token (or it’s been a long time since you used one), you’ll need to create it. To create the PAT, go to your account settings on GitHub, click on Developer Settings option, and then choose to modify Personal access tokens (you’ll end up at https://github.com/settings/apps). To make a new token\": Click the Generate new token button; choose Generate new token (classic). On the next page, give your token a name (e.g., “INFO 340 command line”, or just “command line access”). Specify any expiration date that is after the end of the course; I set it to expire a year from when I create it to make sure that I refresh it periodically. Under Select Scopes, make sure you click the checkbox next to repo in order to give the token access to repositories; you do not need to provide any additional access for this course. Then click the Generate Token button at the bottom. Your token will look like a random string of characters starting with ghp. This string is the “password” you can use when cloning or pushing from GitHub on the command line. Store it in a safe place (a password manager is good), though after you use it once git should cache it so you won’t need to remember it every time. In order to cache your token, clone a code repo (using git clone). When prompted, put in your GitHub user name, and when when prompted for a password, put in the token string! If you’ve used a token before, you may need to remove your old “saved” password from your computer and replace it with the new token—see these instructions for how to do that for your operating system (on a Mac in particular you may need to update your credentials in Keychain) Resources Links to the recommended software are collected here for easy access: Chrome Visual Studio Code Node.js (and npm) npm documentation git (and Git Bash) GitHub (sign up) "],["client-side-development.html", "Chapter 2 Client-Side Development 2.1 Clients and Servers 2.2 URLs and Web Files 2.3 Servers and Hosting 2.4 Web Standards 2.5 Web Accessibility", " Chapter 2 Client-Side Development This chapter provides an overview of the context for doing client-side web development: a brief introduction to how the internet works and where client-side programming fits in with that. It provides background that will be useful in learning specific web technologies. 2.1 Clients and Servers Web development is the process of implementing (programming) web sites and applications that users can access over the Internet. However, the Internet is a network involving many different computers all communicating with one another. These computers can be roughly divided into two different groups: servers store (“host”) content and provide (“serve”) it to other computers, while clients request that content from the servers and then present it to the human users. Generally, servers are the computers owned and managed by large organizations, while clients are individual devices (laptops, phones, etc) owned by individual users. How do clients and servers interact? Well consider the process of viewing a basic web page, such as the Wikipedia entry on Informatics. In order to visit this page, the user types the web address (https://en.wikipedia.org/wiki/Informatics) into the address bar, or clicks on a link to go to the page. In either case, the user’s computer is the client, and their browser takes that address or link and uses it to create an HTTP Request—a request for data sent following the HyperText Transfer Protocol. This request is like a letter asking for information, and is sent to a different computer: the web server that contains that information. A diagram of client/server communication. The web server will receive this request, and based on the request’s content (including the details of the web address) will decide what information to send as a response to the client. In general, this response will be made up of lots of different files: the text content of the web page, styling information (font, color) for how it should look, instructions for responding to user interaction (button clicks), images or other assets to show, and so forth. The client’s web browser will then take all of these different files in the response and use them to render (create/present) the web page for the user to see: it will determine what text to show, what font and color to make that text, where to put the images, and is ready to do something else when the user clicks on one of those images. Indeed, at its most basic a web browser is just a computer program that does two things: (1) sends HTTP requests on behalf of the user, and (2) renders the resulting response from the server. Given this interaction, client-side web development involves implementing programs (writing code) that are interpreted by the browser, and are executed by the client. It is the process of authoring the code that is sent in the server’s response. This code specifies how websites should appear and how the user should interact with them. On the other hand, server-side web development involves implementing programs that the server uses to determine which client-side code is delivered. As an example, a server-side program contains the logic to determine which cat picture should be sent along with the request, while a client-side program contains the logic about where and how that picture should appear on the page. This course focuses on client-side web development, or developing programs that are executed by the browser (generally as a response to a web server request). While it will cover how client-side programs can interact with a server, many of the concepts discussed here can also be run inside a browser without relying on an external server (called “running locally”, since the code is run on the “local” machine without going outside to a server). 2.2 URLs and Web Files Whether the user types an address into the browser’s address bar or clicks on a link (which just navigates to a different address), the server determines which content to send to the browser to render based on the URL in the address bar. The URL (Uniform Resource Locator) is a lot like the address on a postal letter sent within a large organization such as a university: you indicate the business address as well as the department and the person, and will get a different response (and different data) from Alice in Accounting than from Sally in Sales. The URL acts as an identifier (think: variable name) for the page you want to see, while the page or data you want to access is the resource that is being identified/located. Inded, more properly URLs are a specialized form of URI (Uniform Resource Identifier), though the two terms are often used interchangeably. Like postal letter addresses, URLs have a very specific format used to direct the request to the right resource. Diagram of the format (schema) of a URL. A URL is generally made up of the following parts (though not all need to be included): scheme (also protocol): the “language” that the computer will use to send the request for the resource (file). In the web, this is commonly http (using the HyperText Transfer protocol). But better practice is to instead use https (secure HTTP), which encrypts the communication. Don’t use insecure http! Other protocols exist as well. If you double-click on a web file from your local computer, it will open that file with the file protocol, meaning that the computer is accessing the resource from the file system. Web page hyperlinks often include URIs with the mailto protocol for email links, or the tel protocol for phone numbers. When working with web systems, you may also encounter ftp (File Transfer Protocol) addresses, which are used when uploading files to some webhosts. When using git, you may encounter ssh (Secure Shell protocol) addressess. And there are many more network protocols as well, though in the web we’ll usually just use https. domain (also host): the address of the web server to request information from. You can think of this as the recipient of the request letter. These are .com addresses you usually think of with a web site, such as google.com or ischool.uw.edu. (The www is often not necessary; it indicates that the address is a web address, as opposed to an ftp address, and most servers will treat any https request as going to a web address). It’s also possible to write the domain in a URL using an IP address, though that isn’t common in web programming. The host can include multiple subdomains, which are written before each .. So ischool.uw.edu refers to the ischool subdomain of the uw.edu domain. The localhost domain (IP 127.0.0.1) is a special domain name that refers to the address of the current computer; you will use this when accessing pages on local development servers. port (optional): used to determine where to connect to the web server. By default, web requests use port 80, but some web servers accept connections on other ports—e.g., 8080, 8000 and 3000 are all common on development servers, described below. path: which resource on that web server you wish to access. For many web servers, you can think of this as the relative path to the file starting from the “root” folder of that server (which may not be the computer’s root folder). Thus in the above diagram the path /example/info/page.html can be understand as referring to the page.html file in the info folder in the example folder inside the root of the server. If you specify a path to a folder rather than a file (including / as the “root” folder), most web servers will serve the file named index.html from that folder (i.e., the path “defaults” to index.html). So https://google.com actually is the same as https://google.com/index.html. As such, index.html is the traditional name for the file containing a website’s home page. While the path can be best understood as being a file path, it doesn’t necessarily correspond to a server’s file structure—indeed later in the course you will learn to specify routes for the path that don’t reflect files at all! As in any computer program, you should always use relative paths in web programming, and these paths are frequently (but not always!) relative to the web server’s root folder. query (optional): extra parameters (arguments) included in the request about what resource to access. The leading ? is part of the query, followed by key-value pairs of parameters separated by &amp; symbols. These are commonly used when including things like “search queries” when using a search engine. fragment (optional): indicates which part (“fragment”) of the resource to access. This is used for example to let the user “jump” to the middle of a web page. The leading # is part of the fragment. Client-Side File Types It is the web browser’s job to interpret and render the source code files sent by a server as part of an HTTP response. As a client-side web programmer, your task is to write this source code for the browser to interpret. There are multiple different types of source code files, including: .html files containing code written in HTML (HyperText Markup Language). This code will specify the textual and semantic content of the web page. See the chapter HTML Fundamentals for details on HTML. Note that opening one of these files through your file system (e.g., by double-clicking on it) will open that the web page it represents in a browser. .css files containing code written in CSS (Cascading Style Sheets). This code is used to specify styling and visual appearance properties (e.g., color and font) for the HTML content. See the chapter CSS Fundamentals for details on CSS. .js files containing code written in JavaScript. This code is used to specify interactive behaviors that the website will perform—for example, what should change when the user clicks a button. Note that JavaScript code are “programs” that sent over by the web server as part of the response, but are executed by the browser on the client’s computer. See the chapter JavaScript Fundamentals for details on JavaScript. HTTP responses may also include additional asset files, such as images (.png, .jpg, .gif, etc), fonts, video or music files, etc. Modern web browsers are able to render (interpret and display) all of these types of files, combining them together into the modern, interactive web pages you use every day. In fact, you can open up almost any file inside a web browser, such as by right-clicking on the file and selecting “Open With”, or dragging the file into the browser program. HTML files act as the basis for web pages, so you can open a .html file inside your web browser by double-clicking on it (the same way you would open a .docx file in MS Word): 2.3 Servers and Hosting While this course focuses on client-side development (writing code that will be rendered by a browser), it’s impossible to do web development work without interactive with a server in some way. As noted above, a server is a computer that “serves” (provides) the resources, files, and data that are requested by a browser. These files are stored on the server before being served—this is called hosting the resource (the resource gets to “live” on the server). Even when focusing on client-side web development, the files you want the browser to render need to be hosted (live) somewhere. You may be doing “local” development and testing, in which the files stay on your own computer rather than being on a remote machine elsewhere on the internet. In this case, it is possible to have your computer’s file system act as the “host”, or to use a development web server (see below). But when you wish to make your website available to others (to “publish” it, called putting the site into production), then you will need to have a dedicated server that is able to host those files at a URL that others can access. There are a wide variety of web hosting services available on the internet. Some of them may be free of cost (often providing limited storage or bandwidth—the amount of data it can serve and number of requests it can respond to), while others may charge a monthly or yearly fee. There is no standard price; you will need to shop around for what service may fit your needs and your budget. The availability and quality of web hosting services changes frequently; recommending hosts are outside the scope of this text—though see Hosting with GitHub Pages for one simple free hosting method (that is used for this book)! Note that in addition to hosting the files on a particular server, making a website available also requires having a URL at which others can access it. Most hosting services will provide such a URL—but if you want a particular name for the domain part of the URL (e.g., your own “.com”), then you will need to purchase and register that domain name. As with web hosting, there are multiple services that facility buying and registering domain names. When you register a domain, you can set it to refer to the location (IP) of your hosting server, so that users who go to that domain URL will be directed to your server, which can then serve the files. Thus if you want to make your own website there are often two things to purchase: web hosting (space and bandwidth) and a domain name. Purchasing a domain name is not necessary for hosting a website if you’re willing to accept the limits of the host’s naming schema—for example, this book is hosted at info340.github.io, which is free as a subdomain of github.io (GitHub Pages). Hosting with GitHub Pages As an easy and free way to make websites available, GitHub offers a free web hosting through a service called Github Pages. Because GitHub repositories already store code online, it is simple to make that code available as a resource to browsers (to host it on the web). You can host a site for a user or organization account, or you can make multiple site for different projects (repos). Project websites will be available at https://username.github.io/reponame—this will serve the root folder of the repo (in particular the index.html file found there). It is possible to configure GitHub Pages for a particular repo through the Settings for that repo. However, I find that one of the best ways to publish a web project with GitHub Pages is use branching: in particular, any content that is on a branch named gh-pages will be automatically served as a hosted web page. This is a special feature provided by GitHub for branches with this particular name. Using a separate branch has the benefit of helping to distinguish between your development code (the main branch—what is currently being worked on, and may containt bugs, errors, or unfinished parts) and the production code (the gh-pages branch—a “working” version that can be shared with others). By keeping these branches separate, you are able to do development and make potentially breaking changes without breaking the website for users who are accessing it. While it is possible to serve the main branch directly, it is best practice in software engineering to keep development and production versions separate. Never make changes in production! Thus in order to publish a website whose code is in a GitHub repository, create a new branch for the repo called exactly gh-pages (using git checkout -b gh-pages). This is your production branch—any code that is on this branch can be pushed to GitHub and thus made available to users. Note that you will need to push the branch to GitHub in order for it to be served (using git push origin gh-pages while on that branch). IMPORTANT: Never make changes on the production gh-pages branch! You always want to make any edits to your code on the main branch, and then merge those changes into the gh-pages branch. In fact, I remember never staying on the gh-pages branch longer than it takes to merge and push. Thus your workflow should look like: ## do all your coding on `main`! # switch to gh-pages to publish git checkout gh-pages # merge the changes from main git merge main # push to GitHub to publish git push origin gh-pages # IMMEDIATELY switch back to main branch for more coding git checkout main Note that if you publish to production (push to gh-pages) and find a bug or problem in your site, you still need to fix that on the main branch following the above process. Yes this can seem awkward and tedious, but that’s why you need to test your work in development (on the main branch) thoroughly before pushing to production. This is an important software engineering practice! Development Servers As noted above, it is possible to request a .html file (open a web page) using the file protocol by simply opening that file directly in the browser. This works fine for testing many client-side programs. However, there are a few client-side interactions that for security reasons only work if a web page is requested from a web server (e.g., via the http or https protocol). In these situations, you will need to develop client-side web applications using a local development web server. This is a web server that you run from your own computer—your machine acts as a web server, and you use the browser to have your computer send a request to itself for the webpage. Think of it as mailing yourself a letter. Development web servers can help get around cross-origin request restrictions, as well as offer additional benefits to speed development—such as automatically reloading the web browser when the source code changes. There are a number of simple development servers that you can use: live-server is a Node package that runs a simple web server on the command line. You can run the program and “serve” files from the current folder using the command npx live-server . (the . referring to the current folder). This will open up your index.html file in a browser (if not, you can view the page at http://localhost:8080 by default). It will also automatically refresh the page whenever you change a file in the folder! The Vite application for scaffolding React apps provides a webserver that is able to transpile React code. This is used when developing React apps (and only then). See Getting Set Up: React and Vite for details. The Python [http.server] module is able to run a simple web server. You will need to have Python 3 installed and available on your machine. You can then use the command python -m http.server to serve the contents of the current folder, by default at http://localhost:8080. There are multiple extensions for VS Code that provide this functionality, including LiveServer and vscode-previw-server. When running a local web server, remember that the address 127.0.0.1 is the IP address for localhost which is the domain of your local machine (the “local host”). Most development servers, when started, will tell you the URL for the server’s root directory. Most commonly, you will want to start the web server from the root directory of your project, so that the relative path index.html finds the file you expect. You can usually stop a command line development server with the universal ctrl + c cancel command. Otherwise, you’ll want to leave the server running in a background terminal as long as you are working on your project. 2.4 Web Standards In client-side development, the web files (.html, .css, and .js files) you author will be delivered to clients upon request and then interpreted and rendered by the web browser. Indeed, a web browser is any piece of software that is capable of rendering these files (and sending HTTP requests to fetch them in the first place). And there are a lot of different web browsers in the world! The below chart from StatCounter shows the relative popularity of different browsers: Source: StatCounter Global Stats - Browser Market Share. See also caniuse.com’s usage table for information on mobile and older browsers. These web browsers are all created by different developers, working for different (often rival!) organizations. And while there may be some clear “winners” in terms of browser popularity, you cannot dismiss less popular browsers. For example, even if only 0.1% of users use a particular browser (such as Internet Explorer), that’s still more than 5 million people worldwide! So in order to make sure that they are all able to render the same served resources, they all attempt to follow a set of web standards. Web Standards are agreed-upon specifications for how web page source code should be rendered by the browser. Web standards detail both the language syntax (e.g., how to write HTML elements) and the language semantics (e.g., which HTML elements to use), so that it can be understood by any browser that follows (agrees to) that standard. And since as a developer you want your pages to render the same across all browsers, web standards give the requirements for how you need to write your code so that your pages render correctly. Modern web standards are created and maintained by a large group of stakeholders known as the World Wide Web Consortium (W3C), which includes major browser developers such as Google, Apple, and Mozilla. However, this group has no enforcement powers: and so browsers often deviate from the published standards! A browser may ignore a standard to “help out” developers (e.g., making a “best guess” to render malformed HTML content), or to introduce new features (e.g., a new CSS property that produces some special effect). Some browsers are better at conforming to the established standards than others. Internet Explorer—IE 6 in particular—is notorious for not meeting standards and requiring extra effort from developers to make pages render correctly on those browsers. This is part of why IE has such a bad reputation and gets so much scorn from developers. (This failure to meet standards does not apply to Microsoft Edge). Getting so many people to agree on a standard of communication takes time; thus web standards change relatively slowly: the HTML 4 standard was adopted in 1997, but the HTML 5 standard (that this course teaches) wasn’t finalized until 2014. The CSS 3 standard is broken up into more than 50 different modules that are developed and introduced independently, and so is continuously being adopted piece-wise. When introducing new or experimental CSS properties, browsers historically used vendor prefixes in naming the properties. As standards are being decided upon, each browser may treat that property in a slightly different way, thus forcing developers who want to use the “latest and greatest” to provide a different definition or value for each vendor. Prefixes are a naming convention that will cause the property to only be understood and applied by a particular browser; e.g., -webkit-hyphens would use the Webkit version of the hyphens property (for controlling word breaks), while -ms-hyphens would use the IE (Microsoft) version. This practice is currently discouraged (with browsers using internal flags to manage experimental features) and being phased out, though prefixes may be required when supporting older browsers. Tools such as Autoprefixer can help automatically manage prefixes. Writing “correct” code in web development means writing code that conforms to web standards. So even if content may seem to render correctly on your browser, if it doesn’t follow the standard then it may not work on someone else’s computer (or on your computer after a software update)! Thus the requirement for code to be correct in web development is that it not only looks correct when rendered, but that it follows the syntactic and semantic specifications of the web standards. In general, as long as your website conforms to the web standards, it will render correctly on all “modern browsers” (Chrome, Safari, Edge, Firefox, etc.)—though there may still be a few differences that appear between browsers or between operating systems. In order to check what features are available on a particular browser, you can use a tool such as caniuse.com. This site lets you search for web features (e.g., “flexbox”) and then shows which browsers—and which versions of those browsers—support that feature. Green boxes indicate that the faeture is supported, yellow boxes indicate partial support, and brown boxes indicate not supported. It is probably the best source of information about browser support for features. https://compat-table.github.io/compat-table/es6/ has a similar table for the latest JavaScript features, and the documentation provided by the Mozilla Developer Network (MDN) also lists browser compatibility at the end of each listing. Always develop for other people’s browsers, not just your own! Test your code against the standards, not just that it looks okay on a single browser. One way to check that the code you are writing follows the standards is to validate it using an automated tool. The W3C provides online tools that can help validate code: W3C HTML Validation Service W3C CSS Validation Service W3C Developer Tools for a complete list of validators To use these services, simply enter your web page’s publicly-accessible URL (or copy and paste the contents of your .html or .css files), and then run the validation. You will definitely need to fix any errors you get. Warnings should be considered; however, it is possible to get false positives. Be sure and read the warning carefully and consider whether or not it is actually a “bug” in your code! This text does not include specifics needed to ensure that web pages work on every single browser—rather the focus is on introducing web development techniques that are standards-compliant. Supporting older browsers that are not standards-compliant (and ensuring that everyone can access your website) is left as an exercise to the reader. 2.5 Web Accessibility Web standards do more than just establish the correct syntax for web code. Consider the following hypothetical webpage user: Tracy is a 19-year-old college student and was born blind. Through high school she did well as she could relying on audio tapes and books and the support of tutors, so she never bothered to really learn Braille. She is interested in English literature and is very fond of short stories; her dream is to become an audiobook author. Tracy uses the Internet to share her writing and to connect with other writers through social networks. She owns a laptops and uses a screen reader called JAWS: a computer program which reads her screen out loud to her in an artificial voice. (Adapted from here) One of the most commonly overlooked limitations on a website’s usability is whether or not it can be used by people with some form of disability. There are many different forms of disability or impairments that may affect whether or not a person can access a web page, including: Vision Impairments: About 2% of the population is blind, so use alternate mediums for reading web pages. Farsightedness and other vision problems are also very common (particularly among older adults), requiring larger and clearer text. Additionally, about 4.5% the population is color-blind. Motor Impairments: Arthritis occurs in about 1% of the population, and can restrict people’s ease at using a mouse, keyboard or touch screen. Other impairments such as tremors, motor-neuron conditions, and paralysis may further impact people’s access. Cognitive Impairments: Autism, dyslexia, and language barriers may cause people to be excluded from using your website. If you fail to make your website accessible, you are locking out 2% or more of users, reducing the availability and use of your site. Indeed, even web companies with their capitalist world-view are see this population as an important but excluded market; for example, Meta has an entire team devoted to accessibility and supporting users with disabilities. “Accessibility Engineers” have good job prospects. Supporting users with disabilities is not just the morally correct thing to do, it’s also the law. US Courts have ruled that public websites are subject to Title III of the Americans with Disabilities Act (ADA), meaning that is a possible and not uncommon occurrence for large organizations to be sued for discrimination if their websites are not accessible. So far, “accessibility” has legally meant complying with the W3C’s Web Content Accessibility Guidelines (WCAG) (see below), a web standard that is not overly arduous to follow if you consider accessibility from the get-go. Finally, designing your website (or any system) with accessibility in mind will not just make it more usable for those with disabilities—it will make it more usable for everyone. This is the principle behind Universal Design (a.k.a. universal usability): designing for accessibility—being usable by all people no matter their ability (physical or otherwise)—benefits not just those with some form of limitation or disability, but everyone. The classic real-world example of universal design are curb cuts: the “slopes” built into curbs to accommodate those in wheelchairs. However, these cuts end up making life better for everyone: people with rollerbags, strollers, temporary injuries, small children learning to ride a bicycle, etc. Universal design applies to websites as well: If you support people who can’t see, then you may also support people who can’t see right now (e.g., because of a bad glare on their screen). If you support people with motor impairments, then you may also support people trying to use your website without a mouse (e.g., from a laptop while on a bumpy bus). If you support people with cognitive impairments, then you may also support people who are temporarily impaired (e.g., inebriated or lacking sleep). If you make sure that your web page is well-structured and navigable by those with screen readers, it will ensure that it is navigable by other machines, such as search engine indexers. Or for unusual or future browsers (such as virtual reality browsers perhaps). Thus supporting accessibility in client-side web development is important both for helping a population that is often overlooked (a form of social justice), as well as for supporting new technologies and systems. This fact is increasingly being acknowledged by companies as key to usability, and thus it is important that you apply it to your own design and web work. In addition to individual capabilities, people are also reliant on a large amount of existing infrastructure to ensure that they have an internet connection and their requests can reach your web server. The lack of such access is often tied to economic or social inequalities, forming what is called the digital divide. Considering the availability of network access and other infrastructural needs is vitally important when developing information technologies. In client-side development, this may include for example considerations such as the amount of data being served (e.g., the size of images used). See also Responsive Design for design considerations for devices with connectivity limitations. Supporting Accessibility Making web pages accessible is important. In this text, we will primarily discuss supporting accessibility for users with visual impairments such as those using screen readers. A screen reader is a piece of software that is able to synthesize and “read” content on a computer’s screen out loud through the speakers, so that users are able to navigate and control the computer without needing to see the screen. Screen readers are often combined with keyboard controls, so that users use just the keyboard to control the computer and not the mouse (almost like a command line interface!). There are a number of different screen reader software packages available: Macs have had VoiceOver built into the operating system since 2005, though it has been refined with each new OS version. Windows has had a built-in screen reader called Microsoft Narrator since Windows 10. But the most popular screenreaders remain more established applications: JAWS and NDVA. You should try out this software! Follow the above links to learn how to turn on the screen reader for your computer, and then try using it to browse the internet without looking at the screen. This will give you a feel for what it is like using a computer while blind. Screen readers are just software that interpret the HTML of a website in order to allow the user to hear and navigate the content—they are basically non-visual web browsers. As such, supporting screen readers just means implementing your web site so it works with this browser. You can do this by ensuring that your site follows the web standards;—and in particular conforms to the Web Accessibility Content Guidelines (WCAG). This is a list of principles and techniques to use when authoring web documents in order to ensure that they are accessible. The guidelines are driven by 4 main principles: Perceivable: Information and user interface components must be presentable to users in ways they can perceive. Operable: User interface components and navigation must be operable. Understandable: Information and the operation of user interfaces must be understandable. Robust: Content must be robust enough that it can be interpreted reliably by a wide variety of user agents, including assistive technologies. More concretely, accessible web pages are those that can be navigated by screen readers (so people can easily get to the information they care about), and have content that can be perceived by screen readers (so is not just presented visually). Throughout this text (and particularly in Semantic HTML), you will learn simple, specific implementation steps that you can use to follow these principles and ensure that your web sites are accessible to all users. "],["html-fundamentals.html", "Chapter 3 HTML Fundamentals 3.1 HTML Elements 3.2 Nesting Elements 3.3 Web Page Structure Resources", " Chapter 3 HTML Fundamentals A webpage on the internet is basically a set of files that the browser renders (shows) in a particular way, allowing the user to interact with it. The most basic way to control how a browser displays content (e.g., words, images, etc) is by encoding that content in HTML. HTML (HyperText Markup Language) is a language that is used to give meaning to otherwise plain text, which the browser can then use to determine how to display that text. HTML is not a programming language but rather a markup language: it adds additional details to information (like notes in the margin of a book), but doesn’t contain any logic. HTML is a “hypertext” markup language because it was originally intended to mark up a document with hyperlinks, or links to other documents. In modern usage, HTML describes the semantic meaning of textual content: it marks what text is a heading, what text is a paragraph, what content is an image, what text is a hyperlink, and so forth. In this sense HTML serves a similar function to the Markdown markup language, but is much more expressive and powerful. This chapter provides an overview and explanation of HTML’s syntax (how to write it to annotate content). HTML’s syntax is very simple, and generally fast to learn—though using it effectively can require more practice. For more details on using HTML effectively, see Semantic HTML. 3.1 HTML Elements HTML content is normally written in .html files. By using the .html extension, your editor, computer, and browser should automatically understand that this file will contain text content that includes HTML markup. As mentioned in Chapter 2, most web servers will by default serve a file named index.html, and so that filename is traditionally used for a website’s home page. As with all programming languages, .html files are really just plain text files with a special extension, so can be created in any text editor. However, using a coding editor such as VS Code provides additional helpful features that can speed up your development process. HTML files contain the content of your web page: the text that you want to show on the page. This content is then annotated (marked up) by surrounding it with tags: Basic syntax for an HTML element. The opening/start tag comes before the content and tell the computer “I’m about to give you content with some meaning”, while the closing/end tag comes after the content to tell the computer “I’m done giving content with that meaning.” For example, the &lt;h1&gt; tag represents a top-level heading (equivalent to one # in Markdown), and so the open tag says “here’s the start of the heading” and the closing tag says “that’s the end of the heading”. Tags are written with a less-than symbol &lt;, then the name of the tag (often a single letter), then a greater-than symbol &gt;. A closing tag is written just like an opening tag, but includes a forward slash / immediately after the less-than symbol—this indicates that the tag is closing the annotation. HTML tag names are not case sensitive, but you should always write them in all lowercase—see the Code Style Guide for details. Line breaks and white space around tags (including indentation) are ignored. Tags may thus be written on their own line, or inline with the content. These two uses of the &lt;p&gt; tag (which marks a paragraph of content) are equivalent: &lt;p> The itsy bitsy spider went up the water spout. &lt;/p> &lt;p>The itsy bitsy spider went up the water spout.&lt;/p> Nevertheless, when writing HTML code, use line breaks and spacing for readability (to make it clear what content is part of what element)—again, refer to the Code Style Guide. Taken together, the tags and the content they contain are called an HTML Element. A website is made of a bunch of these elements—in fact, all content is annoted so that it is part of some element. Some Example Elements The HTML standard defines lots of different elements, each of which marks a different meaning for the content. Common elements include: &lt;h1&gt;: a 1st-level heading &lt;h2&gt;: a 2nd-level heading (and so on, down to &lt;h6&gt;) &lt;p&gt;: a paragraph of text &lt;a&gt;: an “anchor”, or a hyperlink &lt;img&gt;: an image &lt;button&gt;: a button &lt;em&gt;: emphasized content. Note that this doesn’t mean italic (which is not semantic), but emphasized (which is semantic). The same as _text_ in Markdown. &lt;strong&gt;: important, strongly stated content. The same as **text** in Markdown &lt;ul&gt;: an unordered list (and &lt;ol&gt; is an ordered list) &lt;li&gt;: a list item (an item in a list) &lt;table&gt;: a data table &lt;form&gt;: a form for the user to fill out &lt;div&gt;: a division (section) of content. Also acts as an empty block element (one followed by a line break) And lots more! Element names are defined by the HTML specification—often they are abbreviations for what they represent (e.g., &lt;p&gt; for paragraph). In standard HTML you can only use elements that are defined by the specification; you are not allowed to “make up” your own tags. Trying to use a &lt;paragraph&gt; instead of a &lt;p&gt; would be non-standard and wouldn’t be understood or rendered correctly by the browser. You don’t need to memorize every HTML element type (though you will learn the common ones by heart by happenstance); you can always look up more details about specific element types. For many people “knowing” HTML is about knowing what elements exist in the standard, and the proper ways to combine those elements. See Semantic HTML for more examples and discussion of specific HTML elements. Comments As with every programming language, HTML includes a way to add comments to your code. It does this by using a tag with special syntax: &lt;!-- this is a comment --> &lt;p>this is is not a comment&lt;/p> The contents of the comment tag (between the &lt;!-- and the --&gt;) can span multiple lines, so you can comment multiple lines by surrounding them all with a single &lt;!-- and --&gt;. Because the comment syntax is somewhat awkward to type, most source-code editors will let you comment-out the currently highlighted text by pressing cmd + / (or ctrl + / on Windows). If you’re using a code editor, try placing your cursor on a line and using that keyboard command to comment and un-comment the line. Comments can appear anywhere in the file. Just as in other languages, they are ignored by any program reading the file, but they do remain in the page and are visible when you view the page source. Attributes The start tag of an element may also contain one or more attributes. These are similar to attributes in object-oriented programming: they specify properties, options, or otherwise add additional meaning to an element. Like named parameters in R or python, attributes are written in the format attributeName=value (no spaces are allowed around the =); values of attributes are almost always strings, and so are written in quotes. Multiple attributes are separated by spaces: &lt;tag attributeA=\"value\" attributeB=\"value\"> content &lt;/tag> For example, a hyperlink anchor (&lt;a&gt;) uses a href (“hypertext reference”) attribute to specify where the browser should navigate to when the content is clicked: &lt;a href=\"https://ischool.uw.edu\">iSchool homepage&lt;/a> In a hyperlink, the content of the tag is the displayed text, and the attribute specifies the link’s URL. This means that the URL comes “before” the displayed text—the opposite of Markdown hyperlink syntax. Similarly, an image (&lt;img&gt;) uses the src (source) attribute to specify what picture it is showing. (That hyperlink use href and images use src is one of the many quirks of HTML syntax). An image’s alt attribute contains alternate text to use if the browser can’t show images—such as with screen readers (for the visually impaired) and search engine indexers. &lt;img src=\"baby_picture.jpg\" alt=\"a cute baby\"> Because an &lt;img&gt; has no textual content, it is an empty element (see below). Allowable attributes and their names are determined by the HTML specification—each element supports a certain set of attributes (see the HTML attribute reference). Many attributes are supported by some elements and not by others. However, there are also a number of global attributes that can be used on any element. For example: Every HTML element can include an id attribute, which is used to give it a unique identifier so that you can refer to it later (e.g., from JavaScript). id attributes are named like variable names, and must be unique on the page. &lt;h1 id=\"title\">My Web Page&lt;/h1> The id attribute is most commonly used used to create “bookmark hyperlinks”, which are hyperlinks to a particular location on a page (i.e., that cause the page to scroll down to that location). You do this by including the id as the fragment of the URL to link to (e.g., after the # in the URL). &lt;a href=\"index.html#nav\">Link to element on `index.html` with `id=\"nav\"`&lt;/a> &lt;a href=\"#title\">Link to element on current page with `id=\"title\"`&lt;/a> Note that, when specifying an id (i.e., &lt;h1 id=\"title\"&gt;) you do not include the # symbol. However, to link to an element with id title, you include the # symbol before the id (i.e., &lt;a href=\"#title\"&gt;) Every HTML element can include a class attribute, which is used to specify what CSS classes apply to it. See CSS Fundamentals for more details. The lang attribute is used to indicate the language in which the element’s content is written. Programs reading this file might use that to properly index the content, correctly pronounce it via a screen reader, or even translate it into another language: &lt;p lang=\"sp\">No me gusta&lt;/p> The lang attribute is primarily specified for the &lt;html&gt; element (see below) to define the default language of the page; that way you don’t need to mark the language of every element. &lt;html lang=\"en\"> Note that some attributes are written without an explicit value, meaning the value is the boolean true (for the value to be false, you omit the attribute entirely). For example, a &lt;button&gt; can be disabled: &lt;!-- the presence of the `disabled` means the value is `true` --> &lt;button disabled>You can't click me because I'm turned off&lt;/button> Empty Elements A few HTML elements don’t require a closing tag because they can’t contain any content. These elements are often used for inserting media into a web page, such as the &lt;img&gt; element. With an &lt;img&gt; element, you can specify the path to the image file in the src attribute, but the image element itself can’t contain additional text or other content. Since it can’t contain any content, you omit the end tag entirely: &lt;img src=\"picture.png\" alt=\"description of image for screen readers and indexers\"> Older versions of HTML (and current related languages like XML) required you to include a forward slash / just before the ending &gt; symbol. This “closing” slash indicated that the element was complete and expected no further content—what is called a self-closing tag: &lt;img src=\"picture.png\" alt=\"description of image for screen readers and indexers\" /> This is no longer required in HTML5, so feel free to omit that forward slash (though some purists, or those working with XML, will still include it). You will also need to include the closing / on empty elements when writing HTML for React apps. 3.2 Nesting Elements Web pages are made up of multiple (hundreds! thousands!) of HTML elements. Moreover, HTML elements can be nested: that is, the content of an HTML element can contain other HTML tags (and thus other HTML elements): An example of element nesting: the &lt;em&gt; element is nested in the &lt;h1&gt; element’s content. The semantic meaning indicated by an element applies to all its content: thus all the text in the above example is a top-level heading, and the content “(with emphasis)” is emphasized in addition. Because elements can contain elements which can themselves contain elements, an HTML document ends up being structured as a “tree” of elements: An example DOM tree (a tree of HTML elements). In an HTML document, the “root” element of the tree is always an &lt;html&gt; element. Inside this we put a &lt;body&gt; element to contain the document’s “body” (that is, the shown content): &lt;html lang=\"en\"> &lt;body> &lt;h1>Hello world!&lt;/h1> &lt;p>This is &lt;em>conteeeeent&lt;/em>!&lt;/p> &lt;/body> &lt;/html> This model of HTML as a tree of “nodes”—along with an API (programming interface) for manipulating them— is known as the Document Object Model (DOM). See Document Object Model (DOM) for details. Following the “tree” structure metaphor, you refer an element as being the parent of any element it contains, and the contained element as the child. In the above example, the &lt;em&gt; element is the child of the &lt;p&gt; element, and the &lt;p&gt; element is the parent of the &lt;em&gt; element. The &lt;body&gt; is a child of the &lt;html&gt;, and the parent of the &lt;h1&gt; and the &lt;p&gt;. Caution! HTML elements have to be “closed” correctly, or the semantic meaning may be incorrect! If you forget to close the &lt;h1&gt; tag, then all of the following content will be considered part of the heading! Remember to close your inner tags before you close the outer ones. Validating your HTML can help find errors in this. Nesting elements is fundamental to HTML; in fact, all elements on the page are the child of some other element (except the &lt;html&gt; at the root). For example, a list can be specified by nesting list item (&lt;li&gt;) elements inside of an unordered list (&lt;ul&gt;) element. And of course, those &lt;li&gt; elements can contain even more elements, such as additional ordered list (&lt;ol&gt;) elements! &lt;!-- An unordered list &lt;ul> with 3 items &lt;li>. The second item's content contains another ordered list &lt;ol> containing 2 items. --> &lt;ul> &lt;li>Pigeons&lt;/li> &lt;li> Swallows: &lt;ol> &lt;li>African&lt;/li> &lt;li>European&lt;/li> &lt;/ol> &lt;/li> &lt;li>Budgies&lt;/li> &lt;/ul> This example has elements nested 4 levels deep (and that’s relatively shallow for HTML). Note that the second &lt;li&gt; contains text (the word “Swallows:”) as well as an additional element (an &lt;ol&gt;)—but all of that is content of the element! Block vs. Inline Elements All HTML elements fall into one of two categories: Block elements form a visible “block” on a page. In particular, a block element will be rendered below (on a “new line” from) from the previous content, and any content after it will be rendered below it. Block elements tend to be structural elements for a page: headings (&lt;h1&gt;), paragraphs (&lt;p&gt;), lists (&lt;ul&gt;), etc. &lt;p>Block element&lt;/p> &lt;p>Block element&lt;/p> Two block elements rendered on a page. Inline elements are contained “in the line” of content. These will not have a “line break” after them. Inline elements are used to modify the content rather than set it apart, such as giving it emphasis (&lt;em&gt;) or declaring that it to be a hyperlink (&lt;a&gt;). &lt;em>Inline element&lt;/em> &lt;em>Other inline element&lt;/em> Two inline elements rendered on a page. So in general, block elements are used to specify the “parts” of the page or annotate large blocks of content, while inline elements annote parts of that content (individual words or phrases). When nesting elements, inline elements can go inside of block elements or other inline elements, and it’s common to put block elements inside of the other block elements (e.g., an &lt;li&gt; inside of a &lt;ul&gt;, or a &lt;p&gt; inside of a &lt;div&gt;). However, it is invalid to nest a block element inside of an inline element. For example, you can’t put a &lt;p&gt; inside of an &lt;em&gt; to say that the paragraph is emphasized (it would need to go the other way around). The one exception is that you are allowed to nest block elements inside of &lt;a&gt; elements to turn the entire block into a hyperlink, though this isn’t very common. Some elements have further restrictions on nesting. For example, a &lt;ul&gt; (unordered list) is only allowed to contain &lt;li&gt; elements—anything else is considered invalid markup. Each element has a different default display type (e.g., block or inline, but it is also possible to change how an element is displayed using CSS. See the display property. 3.3 Web Page Structure As noted above, HTML documents always follow a particular structure, with all of the content nested inside of a single &lt;html&gt; element. Thus web documents all use the following “template”: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"author\" content=\"your name\"> &lt;meta name=\"description\" content=\"description of your page\"> &lt;title>My Page Title&lt;/title> &lt;/head> &lt;body> ... Content goes here! ... &lt;/body> &lt;/html> (Alternatively, you can use the VS Code shortcut of writing an exclamation point (!) then hitting the tab key in a .html file to create a similar page skeleton). There are a few parts and elements to this template: Doctype Declaration. All HTML files start with a document type declaration, commonly referred to as the “Doctype.” This tells the rendering program (e.g., the browser) what format and syntax your document is using. Since your web document is written in HTML 5, you declare it as &lt;!DOCTYPE html&gt;. &lt;!DOCTYPE&gt; isn’t technically an HTML tag (it’s actually XML). While modern browsers will perform a “best guess” as to the Doctype, it is best practice to specify it explicitly. Always include the Doctype at the start of your HTML files! The &lt;html&gt; element: The &lt;html&gt; element is the “start” of the HTML document (the whole document is contained within that element). Specify a lang attribute for this element. The &lt;html&gt; element contains exactly two child elements: a &lt;head&gt; and a &lt;body&gt;. No other elements can go directly inside of the &lt;html&gt;. The &lt;head&gt; element: The &lt;head&gt; element contains metadata for the document—data about the content that isn’t displayed on the page. It specifies information about the document being rendered. There are a couple of common elements you should include in the &lt;head&gt;: A &lt;title&gt;, which specifies the “title” of the webpage: &lt;title>My Page Title&lt;/title> Browsers will show the page title in the tab at the top of the browser window, and use that as the default bookmark name if you bookmark the page. But the title is also used by search indexers and screen readers for the blind, since it often provides a strong signal about what is the page’s subject. Thus your title should be informative and reflective of the content. A &lt;meta&gt; tag that specifies the character encoding of the page: &lt;meta charset=\"UTF-8\"> The &lt;meta&gt; tag itself represents “metadata” (information about the page’s data), and uses an attribute and value to specify that information. The most important &lt;meta&gt; tag is for the character set, which tells the browser how to convert binary bits from the server into letters. Nearly all editors these days will save files in the UTF-8 character set, which supports the mixing of different scripts (Latin, Cyrillic, Chinese, Arabic, etc) in the same file. You can also use the &lt;meta&gt; tag to include more information about the author, description, and keywords for your page: &lt;meta name=\"author\" content=\"your name\"> &lt;meta name=\"description\" content=\"description of your page\"> &lt;meta name=\"keywords\" content=\"list,of,keywords,separate,by,commas\"> Note that the name attribute is used to specify the “variable name” for that piece of metadata, while the content attribute is used to specify the “value” of that metadata. &lt;meta&gt; elements are empty elements and have no content of their own. Again, these are not visible in the browser window (because they are in the &lt;head&gt;!), but will be used by search engines to index your page. At the very least, always include author information for on the home page of sites you create! Additional elements for the &lt;head&gt; section will be introduced in later chapters, such as using &lt;link&gt; to include CSS and using &lt;script&gt; to include JavaScript. Note that the &lt;head&gt; is different from a header element (like an &lt;h1&gt;), as well as from the &lt;header&gt; element discussed in Semantic HTML. The &lt;body&gt; element: The &lt;body&gt; element contains all of the visible content of the web page. Every heading, paragraph, image, form, etc goes inside of the &lt;body&gt;. Note that you cannot put any visible elements outside of the &lt;body&gt;—not in the &lt;head&gt; or directly in the &lt;html&gt;. Header and footer content are still part of the &lt;body&gt; of the page! Resources Some useful references and documentation as you begin learning HTML include: General HTML 5 Reference Alphabetical HTML Tag Reference The first reference is from the Mozilla Developer Network (MDN). This reference is managed by Mozilla, the organization that creates and maintains the Firefox web browser. It is the most detailed and accurate reference for web programming, and is what I consider the closest “documentation” for code syntax. The second reference is from W3Schools, and is a very friendly beginner reference for many web development topics. However, it is somewhat less extensive and accurate than MDN. Also remember you can view the HTML page source of any webpage you visit. Use that to explore how others have developed pages and to learn new tricks and techniques! "],["css-fundamentals.html", "Chapter 4 CSS Fundamentals 4.1 Why Two Different Languages? 4.2 Including CSS 4.3 CSS Rules 4.4 The Cascade Resources", " Chapter 4 CSS Fundamentals CSS (Cascading Style Sheets) is a declarative language used to alter the appearance or styling of a web page. CSS is used to define a set of formatting rules, which the browser applies when it renders your page. Thus CSS can tell the browser to use a particular font for the page text, a certain color for the first paragraph in an article, or a picture for the page’s background. Files of CSS rules (called stylesheets) act kind of like Styles or Themes in PowerPoint, but are way more customizable. You can control nearly every aspect of an element’s appearance, including its overall placement on the page. To give you some idea of just how much can be done with CSS, check out the examples in the CSS Zen Garden. Every one of those examples uses the exact same HTML content, but they all look completely different because each one uses a different CSS stylesheet. This chapter will introduce how to include CSS in your web page and the syntax for declaring basic CSS rules. Further CSS syntax, details, and options will be discussed in later chapters. 4.1 Why Two Different Languages? If you are new to web programming, you might be wondering why there are two different languages: HTML for your page content; and CSS for formatting rules. Why not just include the formatting right in with the content? There is an old, tried-and-true principle in programming referred to as “separation of concerns”. Well-designed software keeps separate things separate, so that it’s easy to change one without worrying about the other. And one of the most common forms of separation is to keep the data (content) in a program separate from the presentation (appearance) of that data. By separating content (the HTML) from its appearance (the CSS), you get a number of benefits: The same content can easily be presented in different ways (like in the CSS Zen Garden). In web development, you could allow the user to choose different “themes” for a site, or you could change the formatting for different audiences (e.g., larger text for vision-impaired users, more compact text for mobile users, or different styles for cultures with different aesthetic sensibilities). You can have several HTML pages to all share the same CSS stylesheet, allowing you to change the look of an entire web site by only editing one file. This is an application of the Don’t Repeat Yourself (DRY) principle. You can also dynamically adjust the look of your page by applying new style rules to elements in response to user interaction (clicking, hovering, scrolling, etc.), without changing the content. Users who don’t care about about the visual appearance (e.g., blind users with screen readers, automated web indexers) can more quickly and effectively engage with the content without needing to determine what information is “content” and what is just “aesthetics”. Good programming style in web development thus keeps the semantics (HTML) separate from the appearance (CSS). Your HTML should only describe the meaning of the content, not what it looks like! For example, while browsers might normally show &lt;em&gt; text as italic, you can use CSS to instead make emphasized text underlined, highlighted, larger, flashing, or with some other appearance. The &lt;em&gt; says nothing about the visual appearance, just that the text is emphatic, and it’s up to the styling to determine how that emphasis should be conveyed visually. 4.2 Including CSS The best practice for adding CSS styling in your HTML page to create a separate CSS stylesheet file to contain the CSS code, and reference that file from your HTML content. These files are named with the .css extension, and are often put in a css/ folder in a web page’s project directory, as with the following folder structure: my-project/ |-- css/ |-- style.css |-- index.html style.css, index.css (the CSS for the index.html file), and main.css are all common names for the “primary” stylesheet. You include the stylesheet in your HTML by adding a &lt;link&gt; element to the page’s &lt;head&gt; element: &lt;head> &lt;!--... other elements here...--> &lt;link rel=\"stylesheet\" href=\"css/style.css\"> &lt;/head> The &lt;link&gt; element represents a connection to another resource. The element includes a rel attribute indicating the relation between the resources (e.g., that the linked file is a stylesheet). The href attribute should be a relative path from the .html file to the .css resource. Note also that a &lt;link&gt; is an empty element so has no closing tag. It is both possible and common for a webpage to include multiple stylesheets, each specified with its own &lt;link&gt; element in the &lt;head&gt;. The stylesheet code will be applied in order: the first linked stylesheet is applied, then the second linked stylesheet, etc.. Note that the &lt;link&gt; element is not a hyperlink—it is different from the &lt;a&gt; element used to create navigational links! When someone says “add a link to a page”, you’ll need to determine from context if they mean a hyperlink (&lt;a&gt;) or a stylesheet link (&lt;link&gt;). If your styling isn’t showing up in your page, double-check that the CSS file is linked correctly—especially that you have the correct path to the file! While using a separate stylesheet is the best practice for keeping your code separated and organized, it is also possible to include CSS code directly in your HTML. You can do this by putting that code inside of a &lt;style&gt; element (usually inside of the &lt;head&gt;): &lt;head> &lt;style> /* CSS code goes here */ &lt;/style> &lt;/head> However this means that the CSS styling you write will only apply to that page (it can’t be shared across multiple files), and violates the separation of concerns principle. Embedded CSS should only be used for quick experiments. It is also possible to specify CSS styling for a particular element by giving that element a style attribute whose value is the list of CSS properties to apply to that element. However, this is less flexible (and more repetitive!) than using separate CSS rules, so is also considered bad practice and should be avoided. Always define CSS code in separate stylesheet files! 4.3 CSS Rules A CSS stylesheet lists rules for formatting particular elements in an HTML page. The basic syntax a CSS rule looks like: /* This is pseudocode for a CSS rule */ selector { property: value; property: value; } /* This would be another, second rule */ selector { property: value; } A CSS rule rule starts with a selector, which specifies which elements the rule applies to. The selector is followed by a pair of braces {}, inside of which is a list of formatting properties. Properties are made up of the property name (e.g., color), followed by a colon (:), followed by a value to be assigned to that property (e.g., purple). Each name-value pair must end with a semi-colon (;). If you forget the semi-colon, the browser will likely ignore the property and any subsequent properties—and it does so silently without showing an error in the developer tools! Like most programming languages, CSS ignores new lines and whitespace. However, most developers will use the formatting shown above, with the brace on the same line as the selector and indented properties. As a concrete example, the below rule applies to any h1 elements, and makes them appear in the ‘Helvetica’ font in white text on a dark gray background: h1 { font-family: 'Helvetica'; color: white; background-color: #333; /* dark gray */ } Note that CSS comments are written using the same block-comment syntax used in Java (/* a comment */), but cannot be written using inline-comment syntax (//a comment). CSS stylesheet files will often contain dozens, or even hundreds or thousands of rules. Do not attempt to keep the number of rules small; define any rules that you need to in order to achieve your desired appearance! When you modify a CSS file, you will need to reload the page in your browser to see the changed appearance. Some development servers such as live-server may perform this reloading automatically. CSS Selector Basics The first part of the rule is the selector. Selectors are used to “select” which HTML elements the CSS rule should apply to. Any element on the page that “matches” what the selector indicates will have the properties of the rule applied to it. This means that each rule can and will style multiple elements on the page! CSS supports multiple different types of selectors (with different syntax for selecting which specific elements to style). This chapter will introduce the two most basic selectors; more options and syntax are discussed in CSS Selectors. The most basic selector, called the type selector, selects elements by their type (tag name). For example, the below rule will apply to the all &lt;p&gt; elements, regardless of where they appear on the page: p { color: purple; } CSS rules can use the type selector to style any type of element: /* style all h1 elements to be purple */ h1 { color: purple; } /* style all h2 elements to be gold and italic */ h2 { color: gold; font-style: italic; } /* style all images to fit within a maximum width */ img { max-width: 300px; } It’s important to note that that CSS rules will apply to all elements on the page that match the selector. So the above rules will style all &lt;h1&gt;, all &lt;h2&gt;, and all &lt;img&gt; elements regardless of where they are. This means that you can write one rule to style lots of parts of the page—one rule will change all of the &lt;h1&gt; headings. But sometimes you want a rule to apply to only some elements of a particular type—to only some &lt;p&gt; or only some &lt;img&gt; for example. You will most often make these more limited selections by using a class selector. A class selector will select elements with a class attribute that contains the specified name. For example, if you had HTML: &lt;!-- HTML --> &lt;p class=\"highlighted\">This text is highlighted!&lt;/p> &lt;p>This text is not highlighted&lt;/p> You could color just the correct paragraph by using the class selector: /* CSS */ .highlighted { background-color: yellow; } Class selectors are written with a single dot (.) preceding the name of the class (not the name of the tag!) The . is only used in the CSS rule, not in the HTML class attribute. In the above example, the HTML element has the class highlighted (no dot), and the CSS selector uses .highlighted to mean “elements with class highlighted”. If you try to use a class selector and forget the dot, then the browser will think that you’re using an type selector instead—likely selecting an element type that doesn’t exist in HTML! /* Bug: forgot the dot . in the class selector Instead selects elements of type &lt;highlighted> (do not exist in HTML) */ highlighted { background-color: yellow; } CSS class names should start with a letter, and can contain hyphens, underscores, and numbers. Words are usually written in lowercase and separated by hyphens rather than camelCased or snake_cased. Classes should be given informative names—like you would name a variable! See Naming CSS Classes for more details. Class selectors will apply to any element that contains that class, regardless of the element’s type. This can let you apply a single consistent styling to multiple different types of elements: &lt;h1 class=\"alert-flashing\">I am a flashing alert!&lt;/h1> &lt;p class=\"alert-flashing\">So am I!&lt;p> HTML elements can have multiple classes; each class name is separate by a space (not a comma): &lt;p class=\"alert flashing\">I have TWO classes: \"alert\" and \"flashing\"&lt;/p> &lt;p class=\"alert-flashing\">I have ONE class: \"alert-flashing\"&lt;/p> &lt;p class=\"alert flashing fast\">I have THREE classes: \"alert\", \"flashing\", and \"fast\"&lt;/p> The class selector will select any element that contains that class in its list. So the first paragraph in the above example would be styled by either the selector .alert or the selector .flashing. The second paragraph would not be styled by either selector, because \"alert-flashing\" is not the \"alert\" or the \"flashing\" class. It is common for HTML elements to be given lots of classes, particularly under a modular class naming scheme. Class selectors are the best way to style a single particular element (just give it a class and then write a rule to refer to that), as well as one of the most clearest and effective ways of styling large portions of the page. CSS Property Basics There are many, many different CSS formatting properties you can use to style HTML elements. All properties are specified using the name: value; syntax described above. The task is then to determine which property produces the appearance you want, and provide a valid value for that property. Making beautiful webpages involves combining lots of different properties to style lots of different HTML elements. Pro Tip: modern editors such as VS Code will provide auto-complete suggestions for valid property names and values. Look carefully at those options to discover more! Discussing every single CSS property is beyond the scope of this book (especially as more are introduced every year!) Later chapters will discuss some common or important properties in more detail. For now, below is a short list of common styling properties you might specify in CSS to get you started: font-family: the “font” of the text (e.g., 'Comic Sans'). Font names containing white space must be put in quotes (single or double), and it’s common practice to quote any specific font name as well (e.g., 'Arial'). Note that the value for the font-family property can also be a comma-separated list of fonts, with the browser picking the first item that is available on that computer: /* pick Helvetic Nue if exists, else Helvetica, else Arial, else the generic sans-serif font */ p { font-family: 'Helvetica Nue', 'Helvetica', 'Arial', sans-serif; } See Fonts for more about working with fonts. font-size: the size of the text (e.g., 12px to be 12 pixels tall). The value must include units (so 12px, not 12). See CSS Units for more details on units and sizes. color: text color (e.g., either a named color like red or a hex value like #4b2e83. See CSS Colors for more details on colors in CSS. The background-color property specifies the background color for the element. width: the width of a block element. The value is usually defined in px units (e.g., 300px). This proeprty can be useful especially for sizing image elements. There is also a similar height property. border: a border for the element (see “Box Model”). Note that border is a short-hand property which actually sets multiple related properties at once. The value is thus an ordered list of values separated by spaces: /* border-width should be 3px, border-style should be dashed, and border-color should be red */ p { border: 3px dashed red; } Read the documentation for any individual property to determine what values it can take! Note that not all properties or values will be effectively or correctly supported by all browsers. Be sure and check the browser compatibility listings when using the latest CSS features! 4.4 The Cascade CSS is called Cascading Style Sheets because multiple rules can apply to the same element (in a “cascade” of style!) CSS rules are additive—if multiple rules select the same element, the browser will combine all of the style properties of those rules when rendering the content: /* CSS */ p { /* applies to all &lt;p> elements */ font-family: 'Helvetica' } .alert { /* applies to all elements with class=\"alert\" */ font-size: larger; } .success { /* applies to all elements with class=\"success\" */ color: #28a745; /* a pleasant green */ } &lt;!-- HTML --> &lt;p class=\"alert success\"> This paragraph will be in Helvetica font, a larger font-size, and green color, because all 3 of the above rules apply to it. &lt;/p> This means you can write one rule that applies to a type of element in general (e.g., “all paragraphs have Helvetica font”), and then write another rule that adjusts or customizes specific elements (e.g., “this one paragraph is (also) green”). Combining rules in this way allows you to make very complex styling out of simple and understandable parts. It also allows you to easily reuse such styling across multiple pages or contexts. In addition to multiple rules specifying property values for an element, an element can also inherit property values from its parent. /* CSS */ ul { /* applies to all &lt;ul> elements */ font-size: larger; } li { /* applies to all &lt;li> elements */ color: red; } &lt;!-- HTML --> &lt;ul> &lt;li> This element's content will be in a larger font size (inherited from the parent), as well as red (specified directly). &lt;/li> &lt;li>(So will this element's content because the same rules apply)&lt;/li> &lt;/ul> In the above example, the &lt;li&gt; elements will be in a larger font size even though a rule doesn’t specifically apply that property to them—the parent &lt;ul&gt; element gets that property value, and then the child &lt;li&gt; elements inherit it. Property inheritance means that rules can apply to entire “sections” of the page, and all the content within that section will be styled in the same way. Indeed, you can even use inheritance to apply formatting rules to the entire page by selecting the &lt;body&gt; element. (Note that for clarity/speed purposes, you generally do not apply formatting to the &lt;html&gt; element). Note that if a rule explicitly specifies a property’s value, that value will be used instead of any inherited value: /* CSS */ p { /* applies to all &lt;ul> elements */ color: purple; } em { /* applies to all &lt;em> elements */ color: gold } &lt;!-- HTML --> &lt;p> This text will be purple &lt;em>(but this text will be gold; it does not inherit the purple)&lt;/em> &lt;/p> Property values can be inherited, but styling classes are not. An element is not considered to have a particular class just because its parent does (though it may inherit the properties that are applied to the parent by having that class). Because multiple rules may apply to a single element, it’s possible that multiple values for the same property will be specified for that element: /* css */ p { color: blue; } .alert { color: red; } &lt;!-- html --> &lt;p class=\"alert\"> This element is styled by both rules, both of change its `color`. The text will be red, because the `.alert` selector has higher specificity. The `p` rule's property will be overridden. &lt;/p> If multiple rules try to specify the same property, then the value from the more specific rule is applied. Class selectors are considered more specific than type selectors, so the rule with the class selector “wins”. If two rules are equally specific (e.g., two class selector rules), then the last declared rule is applied. See Selector Specificity for more details. The property value from the less specific rule is said to be overridden. Note that property values that don’t conflict will still be applied even if one value is overrriden. The cascade of rules enabled by CSS makes it powerful and expressive, allowing you to write flexible, reuseable rules that can be combined to produce amazing visual appearances. It’s like making your own Lego bricks! That said, the cascade of rules does create a trade-off: you can have lots of reusable rules that apply to multiple elements, but these rules may combine in a scattered way that makes it difficult to intuit about what the page may look like just from considering the code. Having reusable components increases complexity—sometimes too much. Managing this complexity—determining when rules should apply to which elements and when to combine them—is part of the “skill” in working with CSS. Heuristics for designing rules are discussed more in a later chapter; you will also develop a sense for working with CSS as you practice over time. My best advice for managing the large number of CSS rules used in web pages is to follow the KISS principle: “Keep it simple, silly!”. CSS rules don’t need to be complex; think about rules that apply to general elements or to “sections” of a page. Many elements may only have one or two rules applying to them—and that’s okay! Resources Some useful references and documentation for CSS (in general); more specific resources will be included in later chapters. CSS Reference (MDN) a complete alphabetical reference for all CSS concepts. CSS Selectors Reference a handy table of CSS selectors. CSS Properties Reference a table of CSS properties, organized by category. Getting started with CSS (MDN) - an MDN guide for learning CSS CSS-Tricks a blog about tips for using CSS in all kinds of ways. Contains many different useful guides and explanations. "],["semantic-html.html", "Chapter 5 Semantic HTML 5.1 Specific HTML Elements 5.2 ARIA for Accessibility Resources", " Chapter 5 Semantic HTML As explained in previous chapters, the purpose of HTML markup is to semantically annote text. When we say that HTML is “semantic”, we mean that it is used to describe the meaning, structure, or purpose of text—not to describe that content’s visual appearance. Using HTML only for semantics helps follow the separation of concerns principle (making your code more flexible and easier to modify and maintain). It also helps to make web pages more accessible, as they can be better understood and navigated by assistive technology such as screenreaders. Un-semantic HTML is HTML that doesn’t actually describe the meaning of some content, but may have a visual appearance that suggests that meaning through the use of CSS. For example, an &lt;h1&gt; element is used to indicate a top-level heading, such as the title of the page. But by default, browsers will give &lt;h1&gt; elements a different visual appearance than unmarked content (usually by making it larger and bold). It is possible to achieve a similar visual effect just using CSS: &lt;!-- HTML --> &lt;h1>This is a real heading!&lt;/h1> &lt;p class=\"fake-header\"> This just LOOKS like a heading. &lt;/p> /* CSS */ .fake-header { font-size: 2em; font-weight: bold; } A real heading (top) and a fake heading (bottom). In this example, the second line looks like a heading (it’s big and bold)—but the HTML says that it isn’t a heading, it’s just a paragraph. This can cause problems and confusion, especially for screenreaders and other systems that aren’t concerned with the visual appearance. A blind user visiting this page wouldn’t know that the second paragraph is supposed to act as a heading, because that isn’t indicated in the HTML (just by the rendered visual appearance). For this reason, it’s vitally important that HTML markup is only used to provide accurate semantic annotation. Don’t use an un-semantic element type (such as a heading) because of its default appearance, and do use elements that provide additional information about the purpose of content when possible so that screenreaders and other assistive technology will know about that. Many of the rules in the code style guide are about making sure that HTML is used semantically. This cahpter discusses a number of specific HTML elements, providing details on including them in your documents and how to use them semantically to make sure your page best supports assistive technologies. It also discusses the ARIA standard for adding additional semantic meanings to elements to further support accessibility. 5.1 Specific HTML Elements There are over 100 different HTML elements, each of which provides its own semantic meaning. This chapter is not intended to be a complete reference (use the MDN element reference for that!), but rather to provide specific points and requirements to use them effectively and semantically. Hyperlinks Hyperlinks are fundamental to HTML (it’s right in the name!), so the anchor element &lt;a&gt; may be the most important. The &lt;a&gt; element denotes a hyperlink: text that when activated (e.g., clicked or selected) will cause the browser to navigate to a different URL than the current one. Clicking on a hyperlink is called following the link. As discussed in HTML Fundamentals, the &lt;a&gt; element most always has an href attribute that indicates where the text of the element goes to: &lt;!-- a external hyperlink to `https://ischool.uw.edu` --> &lt;a href=\"https://ischool.uw.edu\">iSchool homepage&lt;/a> The value of the href attribute can be any valid URL (including ones that use protocols other than https). Most a hyperlink will have one of two types of URLs: external hyperlinks are hyperlinks that navigate to a different domain. For example, a link to Google or the iSchool homepage (such as the above example) from this book would be an external hyperlink, because the book’s pages aren’t on the same domain. External hyperlinks are usually written as full URLs, including the protocol, since they include the other domain they link. internal hyperlinks are hyperlinks that navigate to other web pages in the same domain. For example, links to other chapters in this book are internal hyperlinks. The URLs for these hyperlinks are just specified as just the path portion of the other URLs; the domain and protocol are assumed to be the same and so ommitted as redundant. For example: &lt;!-- An internal hyperlink to a different `.html` file in the same domain --> &lt;a href=\"/client-side-development.html\">Chapter 2: Client-Side Development&lt;/a> Internal hyperlinks may use absolute paths as in the above example. The URL path is then determined from the “root folder” of the server. Such URLs will still resolve even if the link is in a page that is nested inside of one or more folders on the server. It is also possible for internal hyperlinks to use relative paths, in which case the target of the hyperlink is relative to the URL of the current page (which is usually rendering the file that includes the link): &lt;!-- An internal hyperlink to a file in a different folder on the same domain. Note that the relative URL cam include moving up a folder. --> &lt;a href=\"../assignments/exercise-01.html\">Exercise 01&lt;/a> And as noted in HTML Fundamentals, a hyperlink’s URL can also include the fragment (the part after the #) to create a bookmark link to an element with a particular id attribute on a page: &lt;a href=\"index.html#nav\">Link to element on `index.html` with `id=\"nav\"`&lt;/a> &lt;a href=\"#title\">Link to element on current page with `id=\"title\"`&lt;/a> In order to make a hyperlink open in a new tab or window (browser-dependent), provide a target=\"_blank\" attribute. The \"_blank\" value is a special keyword that tells the browser to open the link in a new context. Finally, it is important to note that activating a hyperlink (such as by clicking on it) sends a new HTTP request to the server, who then responds with the new page for the browser to render. This means that even if you have a hyperlink to the same page (with the exception of bookmark links), it will still cause the page to “reload”: &lt;!-- in index.html --> &lt;a href=\"index.html\">A link to this same URL will cause the page to reload&lt;/a> Reloading a page means that all of the assets (images, etc) may be re-downloaded, and any state information in JavaScript will be lost. Be careful about when you trigger page reloads. HTTP is a stateless protocol. That means that every single HTTP request—every page load—is considered to be independent and have no inherent relationship. Visiting or loading a page once will have no impact on future page loads; ever visit is a “first and last time”. Servers and browsers can and often do include extra logic to help track sessions to make it seem like page loads are related (e.g., so that items in an online shopping cart stay around), but this is extra work separate from the page encoding itself. In client-side development its best to act as if each page load were a unique one-time occurrence, unless informed otherwise by the server. Hyperlinks are for navigation—activating a hyperlink directs the user to a different URL. The &lt;a&gt; element is not used for clickable elements on a page that do not perform navigation (such as submitting a form or expanding a dropdown). Clickable non-navigation should be annotated as &lt;button&gt; elements. Similarly, do not use a &lt;button&gt; for navigation—that should instead be a hyperlink &lt;a&gt;! If you want a hyperlink to look like a button, you can use CSS to style it in that way—Bootstrap provides support for doing this easily for example. Accessible Hyperlinks Assistive technologies such as screenreaders are able to quickly jump between hyperlinks on a page—this helps users understand what navigation elements are available and to quickly get around without needing to listen to extra content. For this reason, in order to make a hyperlink accessible, the text content of a link should indicate where it goes even when taken out of context: &lt;!-- Do this --> &lt;a href=\"/assignments\">see assignments here&lt;/a> &lt;!-- Don't do this --> see assignments &lt;a href=\"/assignments\">here&lt;/a> In the second example, the link only consists of the word “here”, meaning that when a screenreader lists all of the navigational elements, it will just list the word “here” without any context for the user to understand what is there! This will also help sighted users, who are more easily able to see and understand the links in context. Similarly, you’ll want to make sure that “similar” link text that refers to different locations are made unique: &lt;!-- Don't do this; screenreaders can't distinguish between the links --> For the first &lt;a href=\"exercise-01.html\">exercise&lt;/a> you'll practice HTML, for the second &lt;a href=\"exercise-02.html\">exercise&lt;/a> you'll practice CSS. Using ARIA attributes such as aria-label (see below) can also help ensure that hyperlink text is accessible by providing screen-reading specific context if you struggle to make the prose itself self-contained. Inline Textual Elements //historically individual words of a sentence can be typo-graphically formatted to be marked as distinct by making them either boldface or italicized. But these are appearance/formatting properties only—they don’t provide any semantic information about the text. So while HTML does includes elements &lt;b&gt; for italics and &lt;i&gt; for italics, these are historical artifacts and should not be used. For example, the &lt;b&gt; causes the browser to render text as bold, but doesn’t do anything to indicate why that text is bold. A sighted user may be able to infer something about the boldness from context, but a screenreader will able to make no such guesses from such un-semenatic elements. HTML instead includes a wide number of inline textual elements that you can use to semantically set apart text. By default these may cause the text to render in boldface or italics (and that can be further customized with CSS), while also providing additional semantic support for the text to make it more accessible to assistive technologies. Some of the more useful or interesting inline semantic elements are described below, along with links to their documentation in MDN for further information: &lt;em&gt; marks text as emphasized, which by default is italicized. &lt;strong&gt; marks text as strongly important, which by default is boldface. This is distinct from &lt;em&gt; emphasis, as it’s not just stressed by particularly important. &lt;code&gt; marks text as computer code, which by default is in monospace. The &lt;pre&gt; element can be used to manage pre-formatted text to help with larger code blocks. &lt;del&gt; marks text as deleted, which by default is strike-through. &lt;u&gt; marks text as having a non-textual annotation, such as an underline or “energy lines” or some other decoration. While by default such text renders with an underline, the meaning of this element is to annote that element has having something like an underline (even if that underlining is provided by the tag!) Overall, it is best to avoid this element as mostly un-semantic (similar to how you avoid &lt;i&gt; and &lt;b&gt;), and just use the CSS text-decoration property to create underlines instead. &lt;cite&gt; marks text as being the title of a cited creative work—like the title of a book or movie. Note that this doesn’t mark what you may think of as a “citation” in an essay—it isn’t the inline (Brown, 1999) from MLA-style, or an item in a biblography—it just marks the title of a work. By default this renders text italicized. &lt;abbr&gt; marks text as being an abbreviation or acronym. In particular, if you give the element a title attribute that is the expanded meaning of the acronym, the user will be able to hover over that element and see a pop-up of the meaning: &lt;abbr title=\"Hypertext Markup Language\">HTML&lt;/abbr> This helps with providing definitions outside the flow of the text—though when presenting information its best to include those definition as part of the sentence! &lt;time&gt; represents a time or date. Providing the datetime attribute will can encode the time in machine-readable format, which can help with search engine optimization or other systems: &lt;time datetime=\"2023-12-23\">New Year's Eve&lt;/time> Importantly, although many of these elements provide some default styling, you should only use them for semantic purposes. Don’t use the &lt;em&gt; element just because you want text to be italic: instead you could use another semantic element (or a &lt;span&gt;, see below) and then use CSS to style that element: the font-style property can make content italic, the font-weight property can make it bold, the text-decoration property can add underlines, etc. The &lt;i&gt; (italics) and &lt;b&gt; (bold) elements were originally part of HTML as purely styling elements, without semantic meanings (and thus should not be used). Modern HTML does assign semantic meaning to these elements: &lt;i&gt; is used for content that is “set apart” (but for a reason covered by another element), and &lt;b&gt; is used for content that “deserves attention” (but for a reason not covered by another element). Because the meaning of these elements is vague, its often best to just not use them to avoid confusion. If you want to make some text italic, think about why: is it because it is being emphasized (so should be &lt;em&gt;) or because it is a term that needs to be defined or a work that is being cited? There is almost always a better, more informative element that you can use to annotate content. Images and Media All though webpages are primarily a textual medium, they often contain significant amounts of purely visual information. This includes media such as images or video, but also visual labels such as icons (e.g., a “search” button labeled with a magnifying class or a hamburger button). These features can be created through multiple elements, though specific care is needed to ensure that they are accessible and can be perceived by screnreaders. The most common form of visual media in the web are images, created with the &lt;img&gt; element. As noted in HTML Fundamentals, the src attribute specifies the path to the location of the image file that will be displayed. Most commonly, this will be a relative path to a file served from the same domain (e.g., src=\"imgs/my_pic.jpg\"). But it also possible to use an absolute path to an image location on another domain (e.g., src=\"http://pictures.com/cat_pic.jpg\")—this is known as hotlinking an image. Hotlinking is often considered bad practice—not only does it for another domain to provide download bandwidth for content on your site, but it also means that the file being served may change without your knowledge, causing your site to accidentally include undesired content. In order to make images accessible, always include an alt attribute that gives alternate text for when the image cannot be displayed (e.g., on screen readers, but also if the image fails to load): &lt;img src=\"puppy_picture.jpg\" alt=\"a cute puppy\"> This element will be read by screen readers as “a cute puppy, image”. Note that the “alt-text” should not include introductory text such as “a picture of”, as screen readers will already report that something is an image! The WAI (Web Accessibility Initiative) provides further guidance on writing effective alt text. For more complex images (such as charts or infographics), you can additionally provide a hyperlink to a longer description by using the longdesc attribute. This attribute takes a value that is a URI (relative or absolute; what you would put in the href attribute of a hyperlink) referring to where the description can be found. Screen readers will prompt the user with the option to then navigate to this long description. &lt;img src=\"accessibility_infographic.png\" alt=\"an infographic showing how to make web pages accessible\" longdesc=\"infographic_text.html\"> &lt;!-- link to other page with text description --> Of course, providing descriptive text for images can be useful for all users (so they know what they are looking at)! You can semantically add a caption to an image by placing the image inside a &lt;figure&gt; element, and then using a &lt;figcaption&gt; element for the caption: &lt;figure> &lt;img src=\"chart.png\" alt=\"a chart showing some information\"> &lt;figcaption> A caption for the above figure. It provides the same information, but in a text format. &lt;/figcaption> &lt;/figure> The &lt;figure&gt; and &lt;figcaption&gt; element are good examples of semantic elements that are used together: a &lt;figcaption&gt; can only be used inside of a &lt;figure&gt; (and must be the first or last child of that element!). If you wish to adjust the appearance or placement of the caption, you would use CSS. It is also possible to embed video or audio elements into a webpage by using the &lt;video&gt; and &lt;audio&gt; elements respectively. These elements expect a “source”, specified either with the src attribute or &lt;source&gt; child element (used to have multiple simultaneous sources): &lt;!-- basic example of &lt;video> element, adapted from MDN --> &lt;video controls width=\"400\"> &lt;source src=\"media/videos/cat-video.mp4\" type=\"video/mp4\" /> &lt;!-- text to show if video isn't supported --> Video not supported. &lt;a href=\"/media/videos/cat-video.mp4\">download the video&lt;/a> &lt;/video> Both &lt;video&gt; and &lt;audio&gt; support a large number of additional attributes (such as controls in the above example) that are used to customize the presentation, controls, and playback. Full discussion of all these options is outside the scope of this text; see the documentation for more details and examples. Note that video controls in particular may not be fully accessible to screen readers depending on the browser. At the very least, you should add captions and subtitles to videos (by providing &lt;track&gt; child elements) in to make sure all users can access them. Finally, the &lt;canvas&gt; element is used for programmatically generating graphical images (2d or 3d) using JavaScript, It is the HTML basis for many graphical interactions or web games—though most of the actual work is done in JavaScript and other languages. Headings Heading elements (&lt;h1&gt;, &lt;h2&gt;, through &lt;h6&gt;) are used to provide structure to a web page, allowing users and screenreaders to easily navigate and move through different parts of the content. &lt;h#&gt; elements are block-level elements that are by default larger and bolder than normal text (with smaller headings rendered as smaller). However, do not use heading elements only to change the formatting of text—use CSS for that! Be careful not to confuse a heading (&lt;h1&gt;) element with the &lt;head&gt; element (used for meta-data), or wth the &lt;header&gt; sectioning element described below! Heading elements are used by browsers and screenreaders to automatically construct a “table of contents” for the page. Thus you should think of them similar to chapter or section titles—how you would label parts of an “outline” of the page. Each web page should only have a single &lt;h1&gt;, representing the “title” of the page. Different sections may be marked by &lt;h2&gt; section titles, while subsections would be marked by &lt;h3&gt; subsection titles and so on. A page may have many &lt;h2&gt; or &lt;h3&gt; elements, each marking a “level” in the outline. For example, the sections of this chapter are annotated with &lt;h#&gt; headings: &lt;h1>Semantic HTML&lt;/h1> &lt;h2>Specific HTML Elements&lt;/h2> &lt;h3>Hyperlinks&lt;/h3> &lt;h3>Inline Textual Elements&lt;/h3> &lt;h3>Images and Media&lt;/h3> ... &lt;h2>ARIA for Accessibility&lt;/h2> It’s possible that a page won’t have any sections or subsections, and thus may not have any &lt;h2&gt; or smaller elements. Because screenreaders and other systems will use headings to automatically generate a “table of contents” (which helps screenreaders to quickly navigate the page), it’s important that headings are both meaningful and hierarchical. They should be meaningful in that they describe what content is in the section they start, similar to a book section title. They should be hierarchical in that they don’t skip levels: every &lt;h3&gt; has an &lt;h2&gt; above it—you can’t have a sub-section that isn’t in a section! See also Sectioning Elements below for more about structual organization of page content. Non-Semantic Elements While the purpose of HTML is to provide semantic information about content, there are some elements that have no specific meaning or appearance of their own. The &lt;div&gt; (division) element is use to “group” other content together, providing a shared parent or container for that content. It is a block element that has no additional semantic or apperance impact on its own; it is just used to organize content within the tree of HTML elements. &lt;!-- these three paragraphs will all have the same \"parent\" which can be styled on its own --> &lt;div> &lt;p>Lorem ipsum dolor&lt;/p> &lt;p>sit amet consectetur&lt;/p> &lt;p>Adipisicing elit&lt;/p> &lt;/div> &lt;!-- these paragraphs are in a different \"group\" --> &lt;div> &lt;p>Lorem ipsum dolor&lt;/p> &lt;p>sit amet consectetur&lt;/p> &lt;/div> This is particularly for organizing content and for applying styling with CSS: &lt;!-- A collection of \"cards\" on a page --> &lt;div class=\"card-group\"> &lt;div class=\"card\"> &lt;div class=\"card-header\">Featured&lt;/div> &lt;div class=\"card-body\"> &lt;h2>Card 1&lt;/h2> &lt;p>An information card&lt;/p> &lt;/div> &lt;/div> &lt;div class=\"card\"> &lt;div class=\"card-body\"> &lt;h2>Card 2&lt;/h2> &lt;p>Another information card&lt;/p> &lt;/div> &lt;/div> &lt;/div> In the above example, &lt;div&gt; elements are given different CSS classes in order to style them differently: the elements with the card class may be styled to look like a “card” of content, while the elements with card-header may be styled to look like the headers of those cards. As in this example, it is very common to have multiple nested &lt;div&gt; elements (a &lt;div&gt; inside of a &lt;div&gt; inside of a &lt;div&gt;)—indeed, &lt;div&gt; is possibly the most common HTML element used in the web! Remember that a &lt;div&gt; provides no semantic information; any styling changes that are applied through it will only be perceivable by sighted users! Thus it is always good to consider whether another block element—such as a paragraph, a heading, or a sectioning element—may be more appropriate (and they may not be). Similarly, a &lt;span&gt; element is like a &lt;div&gt; (it has no semantic or appearance impact on its own), but is an inline element so goes inside of text of text content to mark short passages: &lt;p>Baa baa &lt;span class=\"dark\">black&lt;/span> sheep, have you any wool?&lt;/p> A &lt;span&gt; can be used to apply styling to inline content, such as to make a certain work a different color. But because there is usually a reason for such styling changes, it is almost always better to use an appropriate semantic textual element instead. For example, if the word is important, use an &lt;em&gt; instead. You can think of &lt;span&gt; as the element to use when inline styling is needed but no other element is appropriate. Sectioning Elements The &lt;h#&gt; heading elements are part of the original HTML specification, and so will be supported by all screen reader systems. However, HTML 5 introduced additional elements that can be used to help organize web page content in order to make its structure more explicit. These are often referred to as sectioning elements These are all block-level elements that have no appearance impact on their own, but do provide semantic information about the organization of their content. You can think of these as specialized &lt;div&gt; elements—they group elements together, but also provide some meaning as to why they are grouped! These are often referred to as semantic elements or “sectioning elements”. These are all block-level elements that produce no visual effects on their own, but provide semantic structuring to web content. You can think of them as specialized &lt;div&gt; elements. Common sectioning elements are described below. A &lt;section&gt; represents a specific section of content. In particular, a “section” is a portion of content that would be identified by a heading (e.g., an &lt;h2&gt; or an &lt;h3&gt;)—a section should almost always contain a heading element as a child. Thus this element can be used to semantically group all of the content of that section (that falls below that heading). If a group of content would not have a heading, it probably isn’t a &lt;section&gt; (and would liekly just be represented by a &lt;div&gt;). &lt;section> &lt;h2>HTML&lt;/h2> &lt;p>...&lt;/p> &lt;section> &lt;h3>Introduction&lt;/h3> &lt;p>....&lt;/p> &lt;/section> &lt;section> &lt;h3>Syntax&lt;/h3> &lt;p>....&lt;/p> &lt;/section> &lt;/section> Note that as in the above example, &lt;section&gt; elements can contain other &lt;section&gt; elements (“subsections”), each with an appropriate heading. Remember that a &lt;section&gt; has no default appearance, though you can use CSS to customize the elements. They are used to provide organizational semantics that can be used by screenreaders and other systems. The &lt;section&gt; is the most generic of the sectioning elements; other sectioning elements cna be seen as “more specific” types of sections. A &lt;header&gt; represents introductory content, such as heading elements, titles, or banner images. It may also include common page elements such as navigation or search bars. Be careful not to confuse a &lt;header&gt; with a heading (&lt;h1&gt;) element or the &lt;head&gt; element. A &lt;header&gt; is a sectioning element for introductory content that is shown on the page and can contain multiple child elements. The &lt;head&gt; is an element that is NOT part of the &lt;body&gt; (so is not shown in the web page), and contains metadata about that page. A page almost always should contain a &lt;header&gt; element that has introductory content for that page, such as the &lt;h1&gt; and banner images. This usages implies the role=\"banner\" landmark role (see ARIA for Accessibility below). In addition, specific &lt;section&gt; elements may include a &lt;header&gt; to contain the introductory content for that section. &lt;body> &lt;!-- this is is the header (\"banner\") for the entire page --> &lt;header> &lt;h1>Page Title&lt;/h1> &lt;/header> &lt;section> &lt;!-- this is the header for this section --> &lt;header> &lt;h2>About Section&lt;h2> &lt;/header> &lt;/section> &lt;/body> While it’s possible to provide a &lt;header&gt; for every section (and every &lt;section&gt; should have a heading), in practice a &lt;section&gt; with limited introductory content—such as just a single heading element—won’t have a separate &lt;header&gt; defined since it doesn’t provide a lot of additional information about the page structure. It can be useful but is not required. A &lt;footer&gt; usually contains information about the author or source of the page’s content, including copyright information. This element implies the role=\"contentinfo\" landmark role (see ARIA for Accessibility below). A &lt;footer&gt; still contains visible page content, so it goes inside of the &lt;body&gt;! Typically pages will have a single &lt;footer&gt; element—this is placed at the bottom of the page as the last element of the &lt;body&gt;, but not always (using this sectioning element can help with page navigation if the &lt;footer&gt; is elsewhere!) The &lt;footer&gt; contains page-visible information about the content, such as the author and copyright information. It does not contain the “conclusion” section of a page (that would be a normal &lt;section&gt;)! Author information is often placed within an &lt;address&gt; element, which represents contact information. &lt;footer> Created by &lt;address>&lt;a href=\"mailto:joel@uw.edu\">joel@uw.edu&lt;/a>&lt;/address>. &amp;copy; 2024 &lt;/footer> Individual &lt;section&gt; elements can also have their own &lt;footer&gt;, but this isn’t common since sections rarely have different author information than the rest of the page. It is more common for an &lt;article&gt; element to have its own &lt;footer&gt;. The &lt;main&gt; element represents the “main” or central content of the document. A web page can only have a single &lt;main&gt; element. This element implies the role=\"main\" landmark role (see ARIA for Accessibility below). Most all pages will have a &lt;main&gt; element. It usually comes after the &lt;header&gt; (but not inside—in fact, &lt;main&gt; cannot be a descendant of &lt;header&gt;). The &lt;main&gt; element will then contain any &lt;section&gt; elements of the page, and be followed by the &lt;footer&gt;: &lt;body> &lt;header> introductory content &lt;/header> &lt;main> ...main content &lt;section> ...section content &lt;/section> ... more content (including more sections) &lt;/main> &lt;footer> author and copyright information &lt;/footer> &lt;/body> The above is a typical structure for an HTML document. A &lt;nav&gt; represents the part of a page that provides navigation links, such as a navigation bar or table of contents. Not all links need to be in a &lt;nav&gt;; this element represents a section of the webpage that are purely navigational (think of it as a specialized &lt;section&gt;). This element implies the role=\"navigation\" landmark role (see ARIA for Accessibility below). A &lt;nav&gt; element will often be found in the &lt;header&gt; (for the nav bar at the top of the page), though that is not required—a page may have multiple &lt;nav&gt; sections. An &lt;article&gt; is similar to a &lt;section&gt;, but represents standalone content that could be published independently—such as a news article or a blog post. If a section would likely be published as its own document, then it may be an &lt;article&gt;. Note that a &lt;section&gt; may group together multiple &lt;article&gt; elements (such as a blog roll), and an &lt;article&gt; might contain more than one &lt;section&gt;. This mirrors how a newspaper is structured (e.g., with a “Sports Section” that contains articles, which may themselves have different sections). Overall, using semantic sectioning elements can help make the content by clearly structured, as well as organize the content for screenreaders and make it more accessible for users to navigate the page. Most every page should have a &lt;header&gt;, &lt;main&gt;, and &lt;footer&gt;; pages with more content will be broken up into &lt;section&gt; elements; and sites with multiple pages will organization navigation through a &lt;nav&gt;. Tables The &lt;table&gt; element represents tabular data, such as for a data table like you might find in a spreadsheet program. Tables are one of the more complex structures in HTML, requiring several different elements and attributes. This section provides a brief example of making simple and accessible tables; for more examples and guidance see MDN’s documentation for the &lt;table&gt; element as well as the MDN’s Learn HTML tables guide. In HTML, a table is made up of rows, each of which contains a number of cells. Corresponding cells across rows imply a column, though such columns are not explicitly noted in HTML. A diagram showing the rows, columns, and cells of a table. Tables are encoded in HTML by using the &lt;table&gt; element. A &lt;table&gt; contains multiple &lt;tr&gt; (table row) elements representing the rows of the data. Each &lt;tr&gt; row contains multiple &lt;td&gt; (table datum) elements representing the individual data cells. &lt;table> &lt;!-- whole table --> &lt;tr> &lt;!-- a row --> &lt;td>Ada&lt;/td> &lt;!-- a cell --> &lt;td>64&lt;/td> &lt;td>135&lt;/td> &lt;/tr> &lt;tr> &lt;td>Bob&lt;/td> &lt;td>74&lt;/td> &lt;td>156&lt;/td> &lt;/tr> &lt;/table> The rendered data table produced by the HTML code. A &lt;th&gt; (table header) element represents a cell that is in the “header” row or column, can is used in place of a &lt;td&gt; (it is also a cell, just a specialized kind of cell). For example, the first row a table might contain &lt;th&gt; element instead of &lt;td&gt; elements because those cells are the headings for their respective columns. By default, &lt;th&gt; elements will render their content in bold type. A &lt;th&gt; element expects a scope attribute indicating whether it is a header for a \"row\" or for a \"col\" (column). While the scope may be redundant for simple tables, it is best practice to include it to ensure that assistive technologies like screenreaders best support presenting and navigating the table. &lt;table> &lt;tr> &lt;th scope=\"col\">name&lt;/th> &lt;!-- header cell --> &lt;th scope=\"col\">height&lt;/th> &lt;th scope=\"col\">weight&lt;/th> &lt;/tr> &lt;tr> &lt;td>Ada&lt;/td> &lt;td>64&lt;/td> &lt;td>135&lt;/td> &lt;/tr> &lt;/table> Tables can also be made more accessible by including table sectioning elements (similar in concept to the sectioning elements &lt;header&gt;, &lt;main&gt;, and &lt;footer&gt;). The &lt;thead&gt; element groups rows that are the head of the table with information about the columns (usually filled with &lt;th&gt; cells); the &lt;tbody&gt; element groups rows that include the main body of the table, and the &lt;tfoot&gt; element groups rows that are at the bottom of the table with information about the columns (e.g., summary data). These elements have no appearance impact, but do help with organizing and presenting and organizing the table. They are also the closest you can get to using a &lt;div&gt; to style different sections of the table! &lt;table> &lt;thead> &lt;!-- the \"header\" section --> &lt;tr> &lt;th>name&lt;/th> &lt;th>height&lt;/th> &lt;th>weight&lt;/th> &lt;/tr> &lt;/thead> &lt;tbody> &lt;!-- the \"main\" section --> &lt;tr> &lt;td>Ada&lt;/td> &lt;td>64&lt;/td> &lt;td>135&lt;/td> &lt;/tr> &lt;/tbody> &lt;/table> Cell elenents (&lt;td&gt; or &lt;tr&gt;) can be made to stretch across multiple rows or columns by specifying the colspan and rowspan attributes. If one cell stretches across multiple columns or rows, then you omit the &lt;td&gt; cells that it is replacing. Note that spanning rows or columns is not common in tabular data (since a datum won’t span multiple features or multiple observations), and can make it difficult for people using screenreaders to understand the structure of the data. Better practice is to organize the data so that it doesn’t need to do such spanning. As with any other elements, tables are primarily styled using CSS; HTML attribute should only be used for the structure of the table. Note that CSS rules will usually apply to the cells (&lt;td&gt;, &lt;th&gt;) in a table, and not to the rows or sections—many properties are unintutively not inherited from rows, and so need to be applied directly to the cells. There are also some specific CSS properties that apply only to table elements, such as border-collapse and border-spacing (which are used to style the spacing between cells). Never use a &lt;table&gt; element to structure documents and position content. The &lt;table&gt; element should only be used for content that is semantically a table (e.g., a data table). If you want to lay out content on your page in columns or a grid, use CSS properties such as a flexbox or grid. Remember that HTML is for semantic annotation, not for appearance! Forms In web pages, a form is a part of a web page which enables a user to interact with the page by providing information. Users are able to enter input data (in the form of written text, boxes selected, etc) which is then submitted to the web server. Forms are a common part of web pages that you’ve likely used every day—and it’s possible some of your interactions have been through forms without realizing it! Similar to tables, forms are complex sturctures in HTML; this section describes how to create basic forms and how to make them accessible. For more examples and guidance see MDN’s guide to web forms. Web forms are defined by using the &lt;form&gt; element. This block element annotes a part of the page that will accept data inputted by the user (though &lt;input&gt; elements, described below), and specifies what should be done with that data when the form is submitted. When a form is submitted (such as by the user clicking a submit-type &lt;button&gt;), the browser collects the data the user has entered and sends that data to a server through an HTTP request—similar to the request sent when a user clicks on a hyperlink (this means that submitting a form loads a new page!) Where and how that data is sent depends on two attributes on the &lt;form&gt; element: the action and the method. &lt;!-- a very simple form --> &lt;form action=\"result.html\" method=\"GET\"> &lt;!-- labeling text for the input --> &lt;label for=\"greetInput\">Provide a greeting:&lt;/label> &lt;!-- Where the user provides input data --> &lt;input type=\"text\" id=\"greetInput\" name=\"greeting\"> &lt;!-- Submit button --> &lt;button type=\"submit\">Submit&lt;/button> &lt;/form> The action attribute specifies the URL where the user data will be sent to when the form is submitted. Most commonly this will be a URL on the same domain as the current page, and so only a relative path is provided. So in the above example, the submitted form data will be sent to the server to the result.html URL; the server will handle that submitted data and then return a response for that URL (in effect loading that page). Note that servers may do all kinds of things with the submitted data including redirecting the users, so that the page that loads for the user won’t necessarily be the same one as specified in the action. The method attribute indicates which HTTP Method the resulting HTTP request will use. Valid options are \"GET\" (for GET requests—used when the request is only retrieving data from the server) or \"POST\" (for POST requests—used when the request is adding or updating the data stored by the server). Forms that send GET requests will transmit the user-entered data as query parameters (one for each &lt;input&gt;) appended to the action URL—for example, submitting the above form with the user-entered message \"Hello\" would send an HTTP request to result.html?greeting=Hello. Forms that send POST requests will include the user data in the HTTP request’s body (where it can be accessed by the server). React apps and similar systems often handle form data on the client-side; thus the action and method attributes are omitted since they aren’t actually used. You can prevent a form from sending a new HTTP request using the event.preventDefault() method in JavaScript; see DOM Manipulation for more details. &lt;input&gt; elements Users provide data for forms to send through &lt;input&gt; elements. An &lt;input&gt; provides an interactive control, such as a text area or a box to check. &lt;input&gt; elements are inline, empty elements—similar to an &lt;img&gt;, they have no text content of their own. &lt;!-- example input elements --> &lt;label for=\"usernameInput\">Username:&lt;/label> &lt;input type=\"text\" id=\"usernameInput\" name=\"username\"> &lt;label for=\"passwordInput\">Password:&lt;/label> &lt;input type=\"password\" id=\"passwordInput\" name=\"password\"> There are many different kinds of &lt;input&gt; elements, specified with the type attribute, including: text: a single-line text field for users to type into. This is the default type for an &lt;input&gt;. password: like a text input, but whatever the user types is obscured (e.g., shown as dots or stars) so that others can’t see it. checkbox: A box that the user can check or uncheck. Note that there is no text associated with the input; you need to use a &lt;label&gt; to tell the user what they’re checking! radio: A button that the user can select out of a set of (the “circle” checkbox). It is called a “radio button” because like with a radio you can only select a single channel. Radio buttons are noted as a group by giving them all the same name attribute. number: A field in which the user can enter a numeric value date: An input where the user can select a calendar date. Most browsers will provide a calendar drop-down interface, while also allowing users to type in the date. A time input works similarly, but for selecting the time of day, and a datetime-local input will let users select both at once. file: An input where the user can choose a file from their operating system. By default this looks like a button, which when clicked will provide an operating-system dependent interface for choosing the file. hidden: An input that is not shown to the user, though its data values will still be submitted along with the form. hidden inputs are used to data values that are not directly specified or modified by the user, but may be dynamically generated by the web page or system (e.g., through JavaScript). Each &lt;input&gt; element may support additional attributes depending on its type. For example, a number input supports min and max attributes that can limit which numbers are allowed. Such attributes can also be used for built-in client-side form validation, informing users if the values they’ve enetred are invalid. While &lt;input&gt; is the most common element for collecting user input in a &lt;form&gt;, there are others as well. A &lt;textarea&gt; provide a larger text box where users can write and format multiple lines of text. A &lt;select&gt; element provides a drop-down menu; each item in the menu is specified through a child &lt;option&gt; element: &lt;!-- A simple select dropdown --> &lt;select name=\"animal\"> &lt;option value=\"\">Choose an Animal&lt;/option> &lt;option value=\"lion\">Lion&lt;/option> &lt;option value=\"tiger\">Tiger&lt;/option> &lt;option value=\"bear\">Bear&lt;/option> &lt;/select> See the documentation for more options when using these elements. Collectively, &lt;input&gt;, &lt;select&gt;, and similar are referred to as form control elements. As in the above examples, all form controls and inputs support and expect a name attribute. This attributes provide an identifier for the input in order to distinguish it from others in the form (the form itself doesn’t know what descriptive text is around or labeling the inputs). Note that the name is distinct from the id attribute—a name is used to identify the user-entered value within the form’s data, while the id is used to identify the &lt;input&gt; element itself (regardless of what data has been entered). Because id attributes are used with &lt;label&gt; elements for accessibility, most &lt;input&gt; elements will have both attributes—they may even use the same identifier making it look redundant, but the attributes do serve different purposes. All inputs also support a value attribute. This attribute stores whatever value the user has inputted or selected. You can use it to provide a “default” value for an input that the user can replace. &lt;!-- example inputs with different names and default values --> &lt;label for=\"firstnameInput\">First Name:&lt;/label> &lt;input type=\"text\" id=\"firstnameInput\" name=\"firstname\" value=\"Joel\"> &lt;label for=\"passwordInput\">Last Name:&lt;/label> &lt;input type=\"text\" id=\"lastnameInput\" name=\"lastname\" value=\"Ross\"> Text-like inputs also support a placeholder attribute, which provides initial text that will be shown to the user but is not a default value (the value is blank \"\"). Checkboxes, radio buttons, and select dropdowns also use the value attribute to distinguish between options the user has selected: &lt;!-- a set of radio buttons --> &lt;label for=\"smallRadio\">Small&lt;/label> &lt;input type=\"radio\" id=\"smallRadio\" name=\"size\" value=\"small\"> &lt;label for=\"mediumRadio\">Medium&lt;/label> &lt;input type=\"radio\" id=\"mediumRadio\" name=\"size\" value=\"medium\"> &lt;label for=\"largeRadio\">Large&lt;/label> &lt;input type=\"radio\" id=\"largeRadio\" name=\"size\" value=\"large\"> When the form is submitted, the data the user has entered is encoded with the name attribute of each input as the identifier or “key”, and the value attribute as the value. This can be seen in the query parameter’s of a GET request’s target URL. For example, without any changes by the user, the above firstname and lastname inputs in the above example would produce a query parameter list that looks like: ?firstname=Joel;lastname=Ross—the keys (before the =) are the name attributes, and the values (after the =) are the value attributes. As such the name attributes are often named and structured to produce an data identifiers that are easy for a server to consume. In addition to &lt;input&gt; and related elements, a &lt;form&gt; will often contain &lt;button&gt; elements. In particular a &lt;button type=\"submit\"&gt; will submit its parent form when clicked. It is best practice to have an explicit submit button (including for things like search forms) and not just rely on the user hitting “enter”—this makes the form more accessible. Labels and Accessibility As complex structures in HTML that are also key to user interaction, you need to take particular care to ensure that forms are accessible. One of the most important steps to making a form accessible is to provide labels for all form controls and inputs. Labels are specified by using the &lt;label&gt; element (which you can see used in previous examples). The text content inside a &lt;label&gt; element is the text that the user sees that describes the input (which are often instructions for what data the user enters). You explicitly associate a &lt;label&gt; with a particular input using the &lt;label&gt;‘s’ for attribute—this attribute takes a value that is the input element’s id (the id is used to uniquely identify an element on the page): &lt;!-- this label is a description for the element with the `nameInput` id --> &lt;label for=\"nameInput\">Name:&lt;/label> &lt;input type=\"text\" id=\"nameInput\" name=\"name\"> By default, when a user clicks on the &lt;label&gt; text, the associated form control element will gain focus (be selected, with the cursor moved there and ready to receive input). This makes it easier for users to select the relevant input, and is particularly helpful for smaller input elements such as checkboxes that may be harder for a user to target (because of Fitts’ Law). All form controls should be labeled to support screenreaders and other assistive technology. If you don’t want any descriptive text for sighted users (due to other visual context clues), you can use CSS to visually hide the &lt;label&gt;, but it should always be included. It is also possible to implicitly associate a &lt;label&gt; and an &lt;input&gt; by making the &lt;input&gt; a child element of the &lt;label&gt;. This can be useful for dynamically generated content when you may not be able to specify an id for the &lt;input&gt; (e.g., a form where the user can dynamically add more textboxes). However, explicit association with the for attribute is better supported by assistive technology so should be used whenever possible. &lt;!-- implicitly labeling an input, used only when `id` cannot be specified --> &lt;label> Name: &lt;input type=\"text\" name=\"name\"> &lt;/label> Keeping forms short and simple (with as few inputs as possible) is good for both accessibility and overall usability—generally users prefer small forms. For more complex forms, you can also group inputs by putting them together inside of a &lt;fieldset&gt; element. This is particularly helpful for radio buttons. The &lt;legend&gt; element is used to give a “title” to a &lt;fieldset&gt;. &lt;fieldset> &lt;legend>Programming Language&lt;/legend> &lt;div> &lt;input type=\"radio\" name=\"language\" id=\"htmlInput\" value=\"html\"> &lt;label for=\"htmlInput\">HTML&lt;/label> &lt;/div> &lt;div> &lt;input type=\"radio\" name=\"language\" id=\"cssInput\" value=\"css\"> &lt;label for=\"cssInput\">CSS&lt;/label> &lt;/div> &lt;/fieldset> For more guidance on making accessible forms, see WAI’s Forms Tutorial. 5.2 ARIA for Accessibility As noted in Client-Side-Development, making web pages accessible involves conforming to the W3c’s Web Content Accessibility Guidelines (WCAG), which was developed by the Web Accessibility Initiative (WAI) (a part of the W3c). The WAI has also authored an additional web standard for supporting accessibility. This standard is called the Accessible Rich Internet Applications Suite, or ARIA. ARIA specifies an extension to HTML, defining additional HTML attributes that can be included in elements in order to provide additional support for screen readers and other assistive technology. These attributes help screen readers navigate through a page (for people who can’t just visually scroll), as well as providing a mechanism by which “rich” interactive web apps (such as those you will create with JavaScript) can communicate their behavior to screen readers. This section describe some of the most common ARIA-defined attributes that you may use in assuring that web pages are accessible to all users. You will notice that many ARIA attributes are made redundant by semantic HTML usage—HTML as a standard has evolved to better support accessibility since the ARIA standard was created. That said, there are still places that HTML falls short, and so ARIA needs to step in. ARIA Labeling A fundamental step in making web pages accessible is to ensure they are perceivable to screen readers. This means that content cannot just be presented visually. The most common example is including alt attributes for &lt;img&gt; elements, which allows those visual elements to be perceived and understood by assistive technology. But the alt attribute is only supported by the &lt;img&gt; element, even though other element types may also be used for purely visual information (e.g., a &lt;div&gt; that is styled to contain a certain backgound image, or an &lt;svg&gt; containing graphics). ARIA allow you to provide “alternate text” for these other element by using the aria-label attribute, whcih specifies what text should be read in place of the normal content. &lt;div class=\"green-rect\" aria-label=\"a giant green rectangle\">&lt;/div> Note that aria-label is only needed for element that are purely visual (with no textual content); you don’t need to put an aria-label on every &lt;div&gt; or on any &lt;p&gt;. If the element contains text content—even if that text is nested within multiple child elements—it probably doesn’t need an aria-label. For longer (multiple sentence) descriptions, you can alternatively include the aria-describedby attribute with a reference to the id of a different element on the same page that contains the textual description. aria-describedby takes as a value a fragment reference (similar to a bookmark hyperlink) to the element containing the description. &lt;div class=\"green-rect\" aria-describedby=\"#rectDetail\">&lt;/div> &lt;p id=\"rectDetail\">The above rectangle is giant and green.&lt;/p> The descriptive text can be anywhere else on the page; it’s fine to have a visual element separated from its description by multiple other elements. As with bookmark links, notice that the aria-describedby value starts with the # fragment symbol, but the target element’s id does not. Additionally, note that while aria-label attributes replaces its elements content, the aria-describedby attribute will be read after the element’s content, as it provides more information (also compare this to the similar aria-labelledby attribute). Overall, the best way to make purely visual information accessible is to not have purely visual information in the first place! A pages content should always be supportive of non-visual users and browsers: include textual descriptions and captions for images, use text labels instead of icons for buttons, etc. This is the best way to support universal design. While alt attributes and aria-label will let you make visual elements perceivable, there are some images (or other elements) that are purely decorative: company logos, icons that accompany text descriptions on buttons, etc. You can make this content more accessible and cause a screen reader to “skip” reading these decorative elements by using another ARIA attribute aria-hidden=\"true\". An element with this attribute will still appear on the rendered page, it just will be ignored by screen readers. (This attribute is an exception to the general rule that boolean attributes don’t take values). &lt;!-- a search button with an icon --> &lt;!-- the icon img will not be read, but the button text will be --> &lt;button> &lt;img src=\"search_icon.png\" aria-hidden=\"true\"> Search &lt;/button> Note that elements that are hidden through CSS (e.g., using display:none) are already removed from what is read by a screen reader so do not need the additional ARIA attribute. ARIA Roles and Landmarks The ARIA specification defines a role attribute that details the semantic purpose of an elements for screen readers in case that purpose is only clear through visual styling. For example, A page may have a &lt;div&gt; or an &lt;svg&gt; that has been styled to look and act like button; the ARIA attribute helps screen readers understand that this element can be pressed to cause an action: &lt;div class=\"btn\" role=\"button\">Submit&lt;/div> From the screenreader’s perspective, this element acts like a &lt;button&gt;, even if it’s actually a different element type for some reason. There are a large number of different ARIA roles of different roles, including roles for structure and for interactive widgets such as a popup dialog, a switch, or a menu. Some of these, such as button in the above example, are redundant with semantic elements that were added after the ARIA standard was created. It best to always use elements that best reflect their semantic purpose instead of falling back to ARIA roles. If an element is going to be clicked to cause an action, you should use a &lt;button&gt; instead of role=\"button\"—then just style it to look how you want with CSS. In addition the ARIA role attribute can be used to indicate landmark regions. A landmark role indicates specific locations in the document, and allows a screen reader to easily “jump” to that section of content. This helps ensure that the page is navigable. Landmark roles include: banner: content that is related to the website as a whole, rather than to the specific page itself (named after the “banner” often found at the top of a page). The &lt;header&gt; sectioning element implies this role. main: the “main” content. This is useful for allowing the screen reader to jump to the meat of the page, past e.g., the banner and navigation sections. The &lt;main&gt; sectioning element implies this role. contentinfo: a section that contains information about the webpage, such as author contact info and copyright information. This is usually found at the bottom of the page. The &lt;dooter&gt; sectioning element implies this role. navigation: a section of links for moving around the page, such as a navigation bar. This allows screen readers to jump to the “quick links” and move around the page as rapidly as possible. Note though that listening to all of the links read can be time consuming, so allowing the user to jump to the rest of the content is also important (using a technique called a “skip link”). The &lt;nav&gt; sectioning element implies this role. As noted, these landmark roles are also implied by sectioning elements; you do not need to also include a role on these elements, and it is best practice to use the explicit elements themselves rather than the landmark roles! Considering your content in terms of these roles can be a good design trick for figuring out how to organize your page in a way that will be understandable and accessible to all users! ARIA and Interactivity ARIA also provides accessibility support for interactive web pages, where the displayed content may change as the page is being used, by providing attributes that explicitly note the state of the web application. For example, consider a page with a hamburger menu) or similar dropdown or “slide-out” content. Assistive technologies need to inform the users about whether or not the hamburger menu is expanded or whether the sliding content is visible. This can be managed through ARIA state attributes such as aria-expanded: &lt;!-- an example hamburger menu with ARIA attributes --> &lt;button aria-expanded=\"false\" aria-controls=\"menuContent\" aria-label=\"Expand Menu\"> &lt;img src=\"hamburger-icon\" alt=\"a hamburger menu\"> &lt;/button> &lt;ul id=\"menuContent\" class=\"collapsed\"> &lt;li>Link 1&lt;/li> &lt;li>Link 2&lt;/li> ... &lt;/ul> In the above example, the &lt;button&gt; element controls whether or not the &lt;ul&gt; is expanded or not—in the current HTML, the &lt;ul&gt; is collapsed (hidden) through a CSS class. By using JavaScript (see DOM Manipulation), clicking the button can cause the CSS styling of the &lt;ul&gt; to change so that it is no longer collapsed and is instead visible. The ARIA attribute aria-expanded is placed on the the button to indicate to assistive technologies that this button is (a) an interactive control for part of the page, and (b) that it’s current state is that it is not collapsed. When the button is pressed, the JavaScript would also change the aria-expanded attribute to have a value of \"true\", now indicating to screen readers that the menu is open. The aria-controls references the id of the element which the button is adjusting (telling screen readers what element has been modified and controlled). Different interactive widgets and patterns may require other ARIA attributes to best support assistive technologies. When looking at examples of such widgets (e.g., those provided by Bootstrap), be sure to check for appropriate ARIA attributes and consult ARIA documentation for best practices. The WAI strongly states that No ARIA is better than Bad ARIA. Misusing ARIA attributes can grossly misinform users of assistive technologies, making it harder for them to understand the page—instead of semantics being unclear, they may be wrong. Good semantic HTML usage will go far in making web pages accessible; ARIA can and should be used only to fill in explicit gaps where the semantic HTML falls short. Resources Most details on specific HTML elements can be found in the resources noted in previous chapters (e.g., MDN). Some additional resources for writing accessible HTML are listed below. Teach Access Tutorial for creating accessible web pages. Provides lost of examples and details. Be sure and check out the code checklist and the design checklist. UW Accessibility Checklist a thorough and detailed list of considerations for developing accessible systems put together by UW. See also their complete list of tools and resources. Using ARIA (w3c) official guidance for using the ARIA specification ARIA Resources (MDN) WAVE Accessibility Evaluation Service "],["css-selectors.html", "Chapter 6 CSS Selectors 6.1 Basic Selectors 6.2 Complex Selectors 6.3 Selector Specificity Resources", " Chapter 6 CSS Selectors CSS Fundamentals introduced ths basic syntax and usage of CSS. This chapter details additional syntax and options for selectors that specify to which elements on a web page a CSS rule should apply. Development environments such as VS Code can help show which elements will be selected by a different rule depending on the selector. In VS Code, you can hover the mouse over the selector part of a written CSS rule, and a small pop-up will give a generic example of what element that rule applies to! This can be useful for checking your understanding of the selector syntax, as well as for confirming that the rule applies to the elements you intend. 6.1 Basic Selectors Almost all CSS selectors are made up of the most basic selector types: type selectors, class selectors, or id selectors. Type and class selectors were introduced in CSS Fundamentals; those explanations are repeated here for ease of reference. Type Selector The most basic selector is the type selector, which selects elements by their type (tag name). For example, the below rule will apply to the all &lt;p&gt; elements, regardless of where they appear on the page: p { color: purple; } CSS rules can use the type selector to style any type of element: /* style all h1 elements to be purple */ h1 { color: purple; } /* style all h2 elements to be gold and italic */ h2 { color: gold; font-style: italic; } /* style all images to fit within a maximum width */ img { max-width: 300px; } Class Selector A class selector will select all elements with a class attribute that contains the specified name. For example, if you had HTML: &lt;!-- HTML --> &lt;p class=\"highlighted\">This text is highlighted!&lt;/p> &lt;p>This text is not highlighted&lt;/p> You could color just the correct paragraph by using the class selector: /* CSS */ .highlighted { background-color: yellow; } Class selectors are written with a single dot (.) preceding the name of the class (not the name of the element!) The . is only used in the CSS rule, not in the HTML class attribute. In the above example, the HTML element has the class highlighted (no dot), and the CSS selector uses .highlighted to mean “elements with class highlighted”. CSS class names should start with a letter, and can contain hyphens, underscores, and numbers. Words are usually written in lowercase and separated by hyphens rather than camelCased or snake_cased. Classes should be given informative names—like you would name a variable! See Naming CSS Classes below for further discussion. Class selectors will apply to any element that contains that class, regardless of the element’s type. This can let you apply a single consistent styling to multiple different types of elements: &lt;h1 class=\"alert-flashing\">I am a flashing alert!&lt;/h1> &lt;p class=\"alert-flashing\">So am I!&lt;p> HTML elements can have multiple classes; each class name is separate by a space (not a comma): &lt;p class=\"alert flashing\">I have TWO classes: \"alert\" and \"flashing\"&lt;/p> &lt;p class=\"alert-flashing\">I have ONE class: \"alert-flashing\"&lt;/p> &lt;p class=\"alert flashing fast\">I have THREE classes: \"alert\", \"flashing\", and \"fast\"&lt;/p> The class selector will select any element that contains that class in its list. So the first paragraph in the above example would be styled by either the selector .alert or the selector .flashing. The second paragraph would not be styled by either selector, because \"alert-flashing\" is not the \"alert\" or the \"flashing\" class. It is common for HTML elements to be given lots of classes, particularly under a modular class naming scheme. Class selectors are the best way to style a single particular element (just give it a class and then write a rule to refer to that), as well as one of the most clearest and effective ways of styling large portions of the page. Id Selector It is also possible to select HTML elements by their id attribute by using an id selector. Every HTML element can have an id attribute, but unlike the class attribute the value of the id must be unique within the page. That is, no two elements can have the same value for their id attributes. (While technically an id selector will apply to all elements with that id, it’s invalid HTML for two elements to share the same id). The id selectors is written with a # character, followed by the value of the id: &lt;div id=\"sidebar\"> This div contains the sidebar for the page &lt;/div> /* Style the one element with id=\"sidebar\" */ #sidebar { background-color: lightgray; } Similar to with class selectors, the # is only used in the CSS rule, not in the HTML id attribute. The CSS selector uses #sidebar to mean “the element with id sidebar”. The id attribute is more specific (it’s always just one element!) but less flexible than the class attribute, and makes it harder to “reuse” your styling across multiple elements or multiple pages. Thus best practice to use class or type selectors instead of id selectors when styling content (see the code style guidelines). However, id selectors are often used in JavaScript when referring to elements on the page (since such identifiers will be unique). 6.2 Complex Selectors The type selector, class selector, and id selector are the core types of selectors used in CSS. However, it is also possible to combined these basic types into more complex selectors in order to specify rules that apply only to particular elements or groups of elements. This section describes different syntax used to combine basic selectors. Grouping Selector The grouping selector allows you to have a single rule apply to elements matched by lots of different selectors. Technically this isn’t a distinct complex selector: rather it is just a “short-cut syntax” for writing multiple multiples rules with different selectors (but the same properties) at once. The grouping selector combines each component selector with a comma (,) separating them: /* grouping selector: applies to h1, h2, AND h3 elements */ h1, h2, h3 { font-family: Helvetica; color: #4b2e83; /* UW purple */ } The above example applies to all elements that would be selected by an h1 selector, that would be selected by an h2 rule, and that would be selected by an h3 selector. It is precisely equivalent to writing out the three rules separately; the grouping selector just lets you avoid having to repeat the same set of property specifications. /* Two rules written as one with the grouping selector */ h1, h2 { color: #4b2e83; } /* This is exactly the same as writing the two rules separately */ h1 { color: #4b2e83; } h2 { color: #4b2e83; } It is totally acceptable to have the same property and value defined multiples times in multiple different rules. Do not go out of your way to “minimize” duplicated properties by using the grouping selector. It’s best to only grouping selectors if they semantically are applying “the same style”. The component selectors in the grouping selector can be any kind of selector, including .class selectors, #id selectors, or any of the other complex selectors described in this chapter: /* grouping selector can also combine class or id selectors */ /* this rule applies to h2 elements, \"menu\" classed elements, and the id=\"sidebar\" element */ h2, .menu, #sidebar { background-color: gray; } Note that since later rules take precedence earlier ones, you can use a group select to apply a property to multiple different elements, then include additional rules to add variations to those elements. For example, you can have one rule that applies “general” styling to a large class of elements, with further rules then customizing particular elements. /* all headings are Helvetica, bold, and purple */ h1, h2, h3 { font-family: Helvetica; font-weight: bold; color: #4b2e83; /* UW purple */ } /* h2 elements are also underlined */ h2 { text-decoration: underline; } Compound Selector A compound selector combines element, class, and id selectors together to be more specific about where a rule applies. You do this by simply putting a class or id selector immediately after the previous selector, without a space or comma or anything between them. The selector will apply to elements that match all of the component parts. /* Selects only p elements that have class=\"alert\" Other p elements and \"alert\" classed elements not affected */ p.alert { color: red; } /* Selects only h1 elements that have id=\"title\" */ /* Note that this is redundant, since only one element can have the id! */ h1#title { color: purple; } /* Selects elements that have class \"alert\" AND class \"success\" */ .alert.success { color: green; font-size: larger; } /* Can combine as many compnent parts as desired */ /* Selects elements that are `&lt;img>` and have class \"avatar\" AND class \"small\" */ img.avatar.small { width: 80px; height: 80px; border-radius: 50%; } /* Can combine with grouping selector */ /* Selects &lt;p class=\"highlighted\"> and &lt;li class=\"selected\"> */ p.highlighted, li.marked { background-color: yellow; } Note that putting a space between the selectors components (e.g., p .alert instead of p.alert) instead specifies a descendant selector (described below), which has a totally separate meaning. Every character matters in CSS! Use tools such as VS Code’s selector pop-up to confirm that you’ve written selectors as intended. A compound selector adds additional specificity to a selector, allowing you to reuse class names (e.g., for shared semantics and readability purposes) but have those classes apply different styles to different elements. For example, a compound selector would allow a “highlighted” paragraph p.highlighted to look different from a “highlighted” heading h1.highlighted. It also allows you to combine modular classes to produce customizations: a successful alert (.alert.success) can look different from a warning alert (.alert.warning), which can have specialized changes that wouldn’t apply to general .warning elements. Descendant Selector The selectors mentioned so far will apply to matching elements regardless of where they are in the HTML element tree. But sometimes you want to be more specific and style only a set of elements that exist within a particular parent or ancestor element, and not all the other matching elements elsewhere in the page. You can do this form of targeted selecting using a descendant selector. This is written by putting a blank space ( ) between selector components. The rule will apply to elements that match the final component only if they have parents that match the preceding selector components: &lt;header> &lt;h1>Welcome to the page&lt;/h1> &lt;p>I am a special paragraph&lt;/p> &lt;/header> &lt;section> &lt;p>some other paragraph&lt;/p> &lt;/section> /* Selects &lt;p> elements that exist within &lt;header> elements Other &lt;p> elements will not be affected */ header p { /* ... */ } This selector can be read as “select all &lt;header&gt; elements, then style each &lt;p&gt; inside of those elements”. Alternatively, I often find it easier to read a descendant selector “backwards”: style the &lt;p&gt; elements that are inside of a &lt;header&gt;. A descendant selector can have as many “levels” as desired, and each level can be made up of any kind other selector (including e.g., compound selectors). However, it is good style to only have 2 or 3 levels in a descendant selector. If you find you need to be more specific than that, then perhaps defining a new .class is in order. /* selects elements with class=\"logo\" contained within &lt;p> elements that themselves are contained within &lt;header> elements */ header p .logo { /* ... */ } Mind the space! header p .logo is different than header p.logo—the first refers to .logo elements that are inside of a &lt;p&gt; (and inside of a &lt;header&gt;), while the second refers to &lt;p&gt; elements that have the class \"logo\" (and are inside of a &lt;header&gt;). To be clear: the component parts of any selector can be made up of any other selector: /* Using multiple different selectors in combination! Styles &lt;p> with class \"subtitle\" inside a `&lt;header>`, as well as &lt;legend> inside of &lt;fieldset> inside of an element with both the \"sidebar\" and \"form\" classes */ header p.subtitle, .sidebar.form fieldset legend { } Note that descendant selectors will select matching descendant elements anywhere lower in the tree branch, not just direct children, so the .logo elements here could be nested several layers below the &lt;p&gt; element (perhaps inside a &lt;span&gt;). This is usually a good idea because you may introduce new nesting layers to your page as you go along, and don’t want to need to then modify the CSS. But if you really want to select only direct children, you can use a variant known as a child selector, which uses a &gt; symbol to indicate direct descendants only: &lt;body> &lt;p>Body content&lt;/p> &lt;section> &lt;p>Section content&lt;/p> &lt;/section> &lt;/body> /* Selects paragraph \"Body content\" (immediate child of &lt;body>), not paragraph \"Section content\" (immediate child of &lt;section>) */ body > p { color: blue; } Similarly, the sibling selector (~) will select elements that are siblings of the preceding component selector, while the adjacent-sibling selector (+) will select elements that are the immediately following sibling of the preceding component. These selectors are more rarely used, as they more heavily rely on the specific layout of elements on a page and are more likely to require updating if new content is added. /* Sibling Selector: selectors elements that are siblings Selects *all* &lt;p> that share the same parent as an `&lt;img>` and come after it */ img ~ p { } /* Adjacent Sibling Selector: selects elements that are the *next* sibling Applies to the single &lt;p> that shares the same parant as an `&lt;img>` and comes immediately after it (with no other elements inbetween) */ img + p { } Pseudo-classes A pseudo-class is a selector component that is used to select elements depending on their current state of use, rather than their explicit identity such as element type or class. You can almost think of these as pre-defined classes built into the browser, that are added and removed as you interact with the page. This allows you to define styles based on user interactions (among other things). Pseudo-classes are written with a colon (:) and the name of the pseudo-class immediately after a selector component (whether basic or complex): /* Selects &lt;li> elements that the user hovers over with a mouse (while being hovered only */ li:hover { font-size: 200%; } For example, this rule will apply to any &lt;li&gt; element the user hovers over with a mouse, so that while that element is in the “hovered” state it will have a larger font size. When the element is no longer hovered, this rule no longer applies and the element will not have that size. Note that the styling applies to the element—the pseudo-class just describes which element the rule applies to. Pseudo-classes can be combined with complex selector components: /* Style hovered &lt;li> only that are descendants of &lt;ul> elements */ ul li:hover { } /* Style the &lt;img> element that is inside a paragraph that is hovered */ p:hover img { } While neat looking, in general modifying page appearance based on the :hover property is not a great idea and should be used sparingly if at all. The :hover property isn’t accessible (a screen reader can’t hover over text). The :hover property doesn’t work with mobile devices (you can’t hover with your finger). And changing element styling on hover—particularly any styling that affects the rendered size of an element—can cause cascading effects on the rest of the page (making an image or text larger will move everything else around) that will make the page harder to read and interact with. There are many different supported pseudo-classes, which range from user interactions to form state: /* Selects &lt;input> elements that are disabled */ input:disabled { background-color: grey; } /* Selects &lt;input> elements (checkboxes and radio buttons) that are checked */ input:checked { color: green; } Some additional common types of pseudoclasses are described in the following sections. Styling Hyperlinks Hyperlink (&lt;a&gt;) elements come with their own browser-dependent default styling behavior—such as making links blue and underlined, and then purple if they’ve been visited previously. CSS can be used to override these styles, and additional psuedo-classes can be used to specify the style based on the state of the link: /* Applies to &lt;a> elements that have NOT been visited before */ a:link { } /* Applies to &lt;a> elements that HAVE been visited before */ a:visited { } /* Applies to &lt;a> elemeents that have focus. You can see focus when you use the `tab` key to navigate a page. Especially relevant to screenreaders */ a:focus { } /* Applies to &lt;a> elements while being \"activated\" (e.g., clicked by a user) */ a:active { } These selectors may often apply to an element at the same time: a link may be unvisited (:link), and have :focus at the moment it is being clicked (:active). To ensure that rules are not overridden, they need to be applied in LVHFA order: :link, :visited, :hover, :focus, :active. Indeed, rules are often written to apply to all states in this order: /* Applies to &lt;a> elements no matter the state */ a:link, a:visited, a:hover, a:focus, a:active { ... } Remember to always set both hover and focus, to support accessibility for people who cannot use a mouse! Tree Structure Pseudo-classes Another helpful type of pseudo-class are those that select elements based on their location within the document’s tree of elements. These can serve a similar purpose to the descendant, child, or sibling selectors, but with more capabilities. For example, pseudo-classes can be used to select a single element of a particular type based on which child it is: /* Selects the first `&lt;li>` element in its parent */ li:first-of-type { font-weight: bold; } /* Selects any `&lt;p>` element if it is the first child element of its parent */ /* If the first child isn't a `&lt;p>`, it won't be selected */ p:first-child { font-size: 120%; } These pseudo-classes are similar to the descendant selector or the child selector, but rather than styling an element if it is a child, they style an element if is a particular child. There are equivalent :last-of-type and :last-child pseudo-classes as well). A more complex variation of these selectors are the :nth-of-type and :nth-child pseudo-classes. These are similar the “first” and “last” version, but select elements based on an arbitrary number or position: the “second child”, “fifth child”, or “every third child”. /* Selects the 2nd &lt;li> element */ li:nth-of-type(2) { } /* Selects every \"even-numbered\" &lt;li> element (counting starts at 1) */ li:nth-of-type(even) {} /* Selects every third &lt;li> element */ li:nth-of-type(3n) { } /* Selects every third element starting at #2 (so 2, 5, 8, etc) */ li:nth-of-type(3n+2) { } These are an example of a pseudo-class that are written like a function, expecting an argument indicating which elements to select. The argument can be a single number (to select that number element), the keywords even or odd to select every other element (count starting at 1), or an expression of the form An+B, where the A is how many elements to count and the B is where to start counting from. Sturctural pseudo-classes like this are particularly useful for repeated elements, such as lists or tables. For example, you can use these to style “every other row” or a table, or to give the last row a particular appearance: /* Select every other row (for a \"striped\" table appearance) */ tr:nth-of-type(even) { background-color:#eee; } /* Selects the last row (to put a thicker border on the bottom) */ tr:last-of-type { border-bottom: 5px solid black; } Pseudo-classes and other complex selectors are not required when writing CSS. You can often achieve the same effect by using CSS classes or clever applications of e.g., the descendant selector. However, pseudo-classes can make your code more expressive and easier to write and modify: rather that needing to add a class to every other row (and then changing that if a row gets inserted into the midddle!), you can use :nth-of-type(even) to achieve the same effect. There are many other pseudo-classes, some of which expect arguments, that can be useful when needing to style a particular element. Refer to the documentation for more details. Additional Selectors While this is not a comprehensive list of all CSS selectors and options (see e.g., MDN’s documentation for that!), there are a few additional selector types that are worth mentioning. These are not as commonly used, but it is helpful to be aware of them in case them come up in examples or existing sites you are modifying. If you ever find a symbol or a selector in CSS that you don’t understand, look it up! Attribute Selectors The attribute selector selects elements that have a particular attribute. Attribute selectors are written by placing brackets [] after a basic selector; inside the brackets you list the attribute and value you want to select for using attribute=value syntax: /* select all p elements whose \"lang=sp\" */ p[lang=\"sp\"] { color: red; background-color: orange; } It is also possible to select attributes that only “partially” match a particular value; see the attribute selector documentation for details. Note that it is most common to use this selector when styling form inputs; for example, to make checked boxes appear different than unchecked boxes: /* select &lt;input type=\"checkbox\"> that have the \"checked\" state */ input[type=checkbox]:checked { color: green; } Do not use attribute selectors to style based on the class or id attributes—that’s what class and id selectors are for! Attribute selectors should only be used when the presence of the attribute is the characteristic that prompts a particular styling, such as the type for an &lt;input&gt;. Do not use attribute selectors for specific values of general attributes, such as to style an &lt;img&gt; with a particular src or an &lt;a&gt; with a particular &lt;href&gt; Those values are highly “fragile” in that they may change often, and thus would require you to change the selector. Write CSS rules based on information about the semantic meaning of elements (including those semantics defined by attributes), not based on the contents of a particular element. If you want to style a very particular element, give it a class! Universal Selector Although very rarely used, it is possible to select all elements on the page using the universal selector. Written as a * (like a wildcard from the command line), this selector refers to “any” element: /* Selects all elements on the page */ * { box-sizing: border-box; /* all elements include border and padding in size */ } /* Combined with the Adjacent-Sibling Selector; clear the next sibling (whatever it is) after a floating element. Example from MDN. */ .floating + * { clear: left; } There are few legitimate reasons to use this selector—you very rarely want to apply a styling rule to every single element (the box-sizing example above is an exception). In general it’s better practice to apply a styling rule to a single high-level element such as the &lt;body&gt; and then rely on property inheritance to apply that styling through the page as appropriate. 6.3 Selector Specificity As noted in CSS Fundamental, because multiple rules may apply to a single element, it’s possible that multiple values for the same property will be specified for that element: /* css */ p { color: blue; } .alert { color: red; } &lt;!-- html --> &lt;p class=\"alert\"> This element is styled by both rules, both of change its `color`. The text will be red, because the `.alert` selector has higher specificity. The `p` rule's property will be overridden. &lt;/p> If multiple rules try to specify the same property, then the value from the more specific rule is applied. The property value from the less specific rule is said to be overridden. You can see which properties have been overridden in the Chrome Developer Tools—overridden properties are crossed out. Note that property values that don’t conflict will still be applied even if one value is overrriden. The specificity of a rule is determined by counting the number of element, class, and id selector components within a rule’s selector: /* Counting selector components for specificty */ p { } /* 1x type selector */ nav a { } /* 2x type selector */ ul li a { } /* 3x type selector */ .highlighted { } /* 1x class selector */ p.alert { } /* 1x class, 1x type selector */ div.alert.success strong { } /* 2x class, 2x type selector */ #side-nav a { } /* 1x id, 1x type selector */ /* Items in a grouping selector are counted separately! Each selector in the grouping has different specificity and is applied separately */ .green, p.alert.success { } /* 1x class selector; 2x class, 1x type selector */ Thus the number and category of selector components in a complex selector contribute to how specific that selector is. Attribute selectors and pseudo-classes are counted like class selectors. Each selector category is counted separately, producing a “score” with 3 numbers: id, class, and type. These are often written as a triple in that order; you can see such specificity noted in VS Code if you hover over a selector. Which rule is more specific is determined by which rule has the highest id count, and in the case of a tie which has the highest class count, and in the case that ties which has the highest type count. /* CSS Selectors with specificity counts, ordered from most specific to least */ #side-nav a { } /* (1,0,1) */ div.alert.success strong { } /* (0,2,2) */ p.alert { } /* (0,1,1) */ .highlighted { } /* (0,1,0) */ ul li a { } /* (0,0,3) */ nav a { } /* (0,0,2) */ p { } /* (0,0,1) */ Importantly, each selector category (id, class, or type) is considered in order. A rule with a single class selector (e.g., .highlighted, score of (0,1,0)) is more specific than a rule with only type selectors, no matter how many there may be (e.g., nav ul li a em, score of (0,0,5)). Scores are not place values: a rule with 11 class selectors (it can happen!) would have a score of (0,11,0). Precedence rules are not a reason to use #id selectors instead of .class selectors or other combinators. Write selectors that are appropriately specific. If two rules are equally specific—they have the exact same specificity score—then the last declared rule is applied, overriding the previously declared rule. CSS rules are applied “in order”, with later rules overridding those of equal or lesser specificty. /* Two rules, both alike in specificity */ p { color: red; } p { color: blue; } &lt;p>This text will be blue, because that rule comes last!&lt;/p> It is technically possible to override any rule specificty by using the !important declaration. However this is considered bad practice and should be avoided. You can always write a correctly specific rule to achieve your desired styling. While selector specificity is an important aspect of CSS, in generall you’ll find that you don’t need to worry about it too often. Most “semantic” CSS is written to be appropriately specific; you think about rules at a sufficient level specificty in the first place. Moreover, people tend to talk about rules in increasingly specific order naturally, so code will be written to follow that. You won’t often have rules that override each other unintentionally. If you notice that one of your style rules is not being applied, despite your syntax being correct, be sure to check your browser’s developer tools to see if your rule is being overridden by a more specific rule earlier in the spreadsheet (or in a different sheet even)! Then adjust your selector so that it has the same or greater specificity, such as by clarifying the parent class or element type using the descendant selector. Resources More details about CSS selectors can be found in the documention (e.g., MDN’s CSS Selector reference). Some additional learning resources are noted below. CSS Diner a fun game for practicing with different CSS selectors "],["css-properties.html", "Chapter 7 CSS Properties 7.1 Specifying Property Values 7.2 Fonts and Text 7.3 Colors and Backgrounds 7.4 Spacing with the Box Model 7.5 Flow Layout 7.6 Alternate Positioning 7.7 Flexbox Resources", " Chapter 7 CSS Properties CSS Fundamentals introduced ths basic syntax and usage of CSS. This chapter provides additional details about some common appearance properties that can be modified with CSS. This chapter is not intended to be a complete reference (use the MDN reference for that!), but rather to provide specific explanations and examples for styling pages with CSS. 7.1 Specifying Property Values As described in CSS Fundamentals, properties are specified by the name of the property, followed by a colon (:), and ending with a semicolon (;): p { /* A basic property */ color: purple; } Values may be keywords specific to that property (including color names like purple), strings (in quotes), or numeric values (see Units &amp; Sizes below). What values are valid options depends on the property; use the reference and examples like this chapter as a guide. Some properties are written with multiple values, usually separated by a space (not a comma). For example, the border property described can be specified with 3 values: the first value is the width of the border, the second is the style, and the third is the color: div { /* A property that has 3 values. They are separated by spaces */ border: 3px dotted red; } Most (but not all) properties that have multiple values are actually shorthand properties—properties that allow you to specify multiple component properties at once. The above border property example is actually a shorthand for 3 different properties: the border-width, the border-style, and the border-color: div { /* Border set as individual properties; equivalent to the previous example */ border-width: 3px; border-style: dotted; border-color: red; } Shorthand properties often can be specified with a variable number of values, the number and order of which determines which component properties are indicated: .all-sides-padding { /* Specify padding (spacing) on all 4 sides at once--top, right, bottom, left */ padding: 1px 2px 3px 4px; } .x-and-y-sides-padding { /* Specify padding on top &amp; bottom, then on left &amp; right */ padding: 10px 20px; } What options are available for a shorthand property depends on that property—use the documentation to check. Including a shorthand property is interpreted as writing out all of the properties it replaces; so will replace any previous properties within the same rule (if the same property is declared multiple times, the “last” declaration is applied). Thus it is best to eitehr use just the shorthand property, or to specify each of the component properties explicitly. body { border-color: red; border: 3px solid blue; /* later property override previous ones */ /* border will be blue instead of red */ } Inherited Property Values If you don’t explicitly set a property for an element, then the element will still be styled (it will still have a size, font, color, etc)—the value will be inherited from the parent element. /* CSS */ ul { /* applies to all &lt;ul> elements */ font-size: larger; } li { /* applies to all &lt;li> elements */ color: red; } &lt;!-- HTML --> &lt;ul> &lt;li> This element's content will be in a larger font size (inherited from the parent), as well as red (specified directly). &lt;/li> &lt;li>(So will this element's content because the same rules apply)&lt;/li> &lt;/ul> In the above example, the &lt;li&gt; elements will be in a larger font size even though a rule doesn’t specifically apply that property to them—the parent &lt;ul&gt; element gets that property value, and then the child &lt;li&gt; elements inherit it. If the parent styling hasn’t been specified by you, then the element might still be inheriting a style! It will get these styles from the browser’s built-in stylesheet, often called the user-agent stylesheet. This is often the “default” styling that applies to elements, such as making headings big and bold. While most browsers have similar stylesheets, these can be adjusted and customized by the user (such as by making the “default font” size larger to help with accessibility). Thus sometimes you may need to explicitly style an element in order to override the browser’s built-in styling. If you want to explicitly note that an element should be styled the same as its parent, you can give that property an inherit value. If you want to explicitly have an element be styled to the browser-default value, you can give that property an initial value. These are particularly useful when you want to “override” a more general rule to remove a specified styling. h1 { /* color should be the same (inherited) from the parent element */ color: inherit; /* font-size should use the browser-initial value */ font-size: initial; } It’s important to note, however, that not all properties are inherited! For example, the border property is a non-inherited property; a child element will not gain its own border just because a border was specified for the parent. Most properties that style text or colors are inherited, while those properties that deal with size and layout are often non-inherited (it usually works the way you’d expect). You can check for any particular property by referring to its documentation. Length Units &amp; Sizes Many CSS properties affect the size of things on the screen, whether this is the height of the text (the font-size) or the width of a box (the width). In CSS, you can use a variety of different units to specify sizes. In general, CSS sizes are fundamentally measured in pixels (px). A pixel represents a single rasterable point of a display (it is not a tiny square), and is the usual unit used to measure display size. In the web a pixel is defined to be \\(\\frac{1}{96}\\) of an inch; that may vary depending on the display size and resolution, but thinking of 100px as about an inch of screen space is a good starting heuristic. A pixel is an absolute length unit; a size specified in pixels is considered to always be the same size. CSS does support a number of alternate absolute length units, including inches (1in = 96px), centimeters (1cm = 37.8px), millimeters, and points (\\(\\frac{1}{72}\\) of an inch. 1pt = 1.33px; do not use this for font sizes). These however are generally inappropriate for computer displays and more useful e.g., in printing, so should not be used in styling web pages. CSS also uses a variety of relative length units, which will produce sizes based on (relative to) the size of other elements. The most common relative units are described below. em: An em is measured relative to the parent element’s font-size: /* A parent element has a font-size of 16px */ .parent { font-size: 16px; } /* The child element would have a font-size of 32px */ .child { font-size: 2em; } If the parent’s font-size was 20px, then a font-size of 2em for the child would be valued at 40px. This can be useful for indicating e.g., that you want an element’s font to be “twice as big”. Careful use of em-based font-sizes also allow for effective scaling: you can change the font-size of a parent and then all of the children will resize accordingly. Note that although an em was originally a typographic measurement, this unit does not change based on the font-family. An em can also be used for non-typographic properties such as width; in those situations the pixel value is calculated relative to the current element’s font-size. rem: An rem is measured relative to the root element’s (&lt;html&gt; element’s) font-size. Since most browsers have a default root font-size of 16px, this generally means that 2rem = 32px. Using rem units can allow for relative scaling, but at a document-level rather than at an element-level. This can help keep things consistent; elememts won’t accidentally “balloon” in size because of increasing em multipliers. But using relative rem units rather than absolute px units allows your page to be more accessible (users can change the default font-size to be larger and more readable) and betters supports different browsers. %: A % value is measured relative to the parent element’s value for that property (font-size, width, etc). For example, if the parent element’s width is 300px, then an element with a width of 50% would be 150px wide. For font-sizes, percentages act equivalent to em units. For example, .75em is the same as 75%; 2em is the same as 200%. In general, its best practice to use em when sizing fonts to be consistent. Percentages can appropriate for dimensions such as width or height. vw, vh: These units are relative to the viewport dimensions—the size of the browser window. 1vw is 1% of the viewport’s width, and 1vh is 1% of the viewport height ()25vw would be 25% of the viewport width, etc). If the browser is resized, then these values will change. This can be a desired effect, but can also make it difficult to style a page that looks good across a wide range of browser sizes. Indeed, a regular % can achieve the a similar effect to a vw. Most browsers have a default font size of 16px, so 1em and 1rem will both be initially equivalent to 16px. For length values of 0 (used e.g., for padding or margin), you omit the units as irredundant—you don’t need to say 0 of what. So you just use 0, not e.g., 0px. In general, you should specify font sizes using relative units (e.g., em)—this will support accessibility, as vision-impaired users will be able to increase the default font-size of the browser and all your text will adjust appropriately. Absolute units are best for things that do not scale across devices (e.g., image sizes, or the maximum width of content). However, using relative sizes will allow those components to scale with the rest of the page. Font-sizes should always be relative (em or rem); layout dimensions may be absolute (but relative units are best). 7.2 Fonts and Text You specify the typographical “font” (the typefac) for text using the font-family property. This property takes a comma-separated list of font names (strings). The browser will attempt to render the text using the first font in the list; if that font isn’t available on the client computer, then it will use the next in the list and so on (you can then of these secondary fonts as “fall-backs”). Font family names are required to be put in quotes (single or double) if there is a whitespace in the name, such as with \"Helvetica Neue\". But it is good practice to put all font family names in quotes anyway—this makes it easier to modify if you change them to a font name with multiple words, and helps distinguish them from generic font names (see below). p { font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif; } In this example, the computer will attempt to render the text in 'Helvetica Neue'. If that font isn’t installed on the user’s computer, then it instead tries to use 'Helvetica', then 'Arial', and finally if none of those work will use a generic sans-serif font. Indeed, the last font in the list should always be a generic family name. These are a list of “categories” that the browser can draw upon even if the computer doesn’t have any common fonts available. In pracice, the most common generic families used are serif (fonts with serifs, e.g., “Times”), sans-serif (fonts without serifs, e.g., “Arial”), and monospace (fonts with equal width characters, e.g., “Courier”). Note that generic font families are not quoted: it’s sans-serif, not \"sans-serif\". If you put them in quotes, the the browser will intepret them as a family name and not as generic. Serif vs. Sans-Serif fonts. From 99designs.ca. Research (roughly) suggests that sans-serif fonts are easier to read on screens, as well as more accessible for users with e.g., dyslexia. Thus it is recommended to use sans-serif fonts for most text on your page. It is also possible to include specific typefaces in your web page, which will be delivered to the browser by the web server in case the client doesn’t have the previously available. You do this manually by using the @font-face rule, and specifying the url for the font file (usually in .woff2 format). However, it is usually easier to instead include a stylesheet that already has this rule in place. For example, the Google Fonts collection provides more than 800 different freely available fonts that you can include directly in your web page: &lt;head> &lt;!-- ... --> &lt;!-- load stylesheet with font first so it is available --> &lt;link href=\"https://fonts.googleapis.com/css?family=Encode+Sans\" rel=\"stylesheet\"> &lt;!-- load stylesheet next --> &lt;link href=\"css/style.css\" rel=\"stylesheet\"> &lt;/head> body { font-family: 'Encode Sans', sans-serif; /* can now use Encode Sans */ } Notice that the &lt;link&gt; reference can be to an external file on a different domain! This is common practice when using fonts and CSS frameworks. Important When using Google Fonts, you’ll need to specify if you also want variations such as bold or italic typesets. For example, the Encode Sans font is available in font weights (what you would set with font-weight) from 100 to 900, but you need to specify these in the linked resource: &lt;!-- includes normal (400) and bold (700) weights --> &lt;link href=\"https://fonts.googleapis.com/css?family=Encode+Sans:400,700\" rel=\"stylesheet\"> If you don’t include the different set of glyphs for the bolded font, then setting the text in that font to bold won’t have any effect (because the browser doesn’t now how to show text in “Bold Encode Sans”)! Other font libraries can be used to add icons or symbols to a web page. For example, the Material Design icon font for the web lets you specify different icons by giving elements a particular class. Other icon-based fonts include Octicons and Font Awesome. Emoji are defined using a different set of Unicode values, and are browser and operating-system dependent instead of being available through a font. You can make a font italic using the font-style property, or bold using the font-weight property. Font weights are measured in different ordinal values ranging from 100 to 900. For most fonts these are specific values: there is no such thing as a font weight of 340 (only 300 and 400). Often using keywords for font weights (e.g., normal, bold, black) is easier to read and understand. 7.3 Colors and Backgrounds Colors of CSS properties (foreground or background) can be specified in a few different ways. You can use one of a list of 140 predefined color names: p { color: mediumpurple; background-color: gold; } While this list does not offer a lot of flexibility, they can act as useful placeholders and starting points for design. The list of CSS color names also has a fascinating history. Alternatively, you can specify a color as a “red-green-blue” (RGB) value. This is a way of representing additive color, or the color that results when the specified amount of red, green, and blue light are aimed at a white background. RGB values are the most common way of specifying color in computer programs. p { color: rgb(147, 112, 219); /* medium purple */ } This value option is actually a function that takes a couple of parameters representing the amount of red, green, and blue respectively. Each parameter ranges from 0 (none of that color) to 255 (that color at full). Thus rgb(255,0,0) is pure bright red, rgb(255,0,255) is full red and blue but no green (creating magenta), rgb(0,0,0) is black and rgb(255,255,255) is white. Note that if you want to make the color somewhat transparent, you can also specify an alpha value using the rgba() function. This function takes a 4th parameter, which is a decimal value from 0 (fully transparent) to 1.0 (fully opaque). Elements with transparent colors will “blend” with any other elements behind them (which requires some non-standard positioning). CSS also supports hsl() and hsla() functions for specifying color in terms of a hue, saturation, lightness color model. Finally, and most commonly, you can specify the RGB value as a hexadecimal (base-16) number. p { color: #9370db; /* medium purple */ } In this format, the color starts with a #, the first two characters represent the red (ranging from 00 to FF, which is hex for 255), the second two characters represent the green, and the third two the blue: How to reading a hex value, from Smashing Magazine. This is a more compact and efficient way to describe the RGB of a color, and is how most digital artists convey color. See this article for more details about encoding colors. Backgrounds and Images You have previously seen how to use the the background-color property to color the background of a particular element. CSS also supports a much wider list of background-related properties. For example, the background-image property will allow you to set an image as the background of an element: header { background-image: url('../img/page-banner.png'); } This property takes as a value a url() data type, which is written like a function whose parameter is a string with the URI of the resource to load. These URIs can be absolute (e.g., http://...), or relative to the location of the stylesheet (not to the web page!—you may need to use .. if your .css file is inside a css/ directory). There are additional properties used to customize background images, including where it should positioned in the element (e.g., centered), how large the image should be, whether it should repeat, whether it should scroll with the page, etc. header { background-image: url('../img/page-banner.png'); background-position: center top; /* align to center top */ background-size: cover; /* stretch so element is filled; preserves ratio (img may be cropped) */ background-repeat: no-repeat; /* don't repeat */ background-attachment: fixed; /* stay still when window scrolls */ background-color: beige; /* can still have this for anything the image doesn't cover (or for transparent images) */ } This is a lot of properties! To understand all the options for their values, read through the documentation and examples for backgrounds. To try and make things easer, CSS also includes a shorthand property called just background. Using this property, the above is equivalent to: header { background: url('../img/page-banner.png') top center / cover no-repeat fixed beige; } Note that the background-position and background-size are separated by a / since they both can have more than one value. You can include some or all of the available background properties in the shorthand. Unlike most shorthand properties, the background properties can go in any order (though the above order is recommended). Additionally, all of the background properties support multiple backgrounds by using a comma-separated list of values. This can enable you to easily overlay partially-transparent images on top of each other, similar to using layers in a photo-editing application such as Photoshop. 7.4 Spacing with the Box Model The CSS Box Model is one of the core concepts in CSS, and is one of the central frameworks by which elements are visually presented on the page. All HTML elements (including text!) include an imaginary “box” around their content. Elements are laid out with their boxes next to each other (side by side for inline elements, stacked on top for block elements—see Flow Layout). These boxes are normally just large enough to contain the content inside the element, but you can use CSS to alter the size of and spacing between these boxes in order to influence the layout. First off, you can set the width and height of elements explicitly. Note that if the width or height are too small for the element’s content, then the content will be clipped by default (a behavior controlled by the overflow property). It’s generally best to set only the width or the height, but not both. You can also specify a min-width or min-height to ensure that the width or height is at least a particular size. Conversely, you can use max-width and max-height to constrain the size of the element. The width and height can only be adjusted for block elements (such as &lt;p&gt; or &lt;div&gt;); inline elements (such as &lt;em&gt; or &lt;a&gt;) are always sized to fit their content. In order to adjust the spacing between boxes, you can manipulate one of 3 properties: the padding, the border, and the margin. A diagram of the box model properties These three properties can be seen in the Chrome Developer Tools when you select an element: the content is shaded in blue, the padding is shaded in green, the border is shown in its own color (or yellow), and the margin is shaded in orange. Padding The padding is the space between the content and the border (e.g., the edge of the box). If you think of the element’s content as being in a shipping box, then this is the “packing peanut” space around that content that is used to keep it from touching the boundaries of the box. An element’s padding. Padding can be specified for an individual side of the box individually using e.g., padding-top, or by using the padding shortcut property to specify multiple sides at once: /* specify each side individually */ .individual-sides-padding { padding-top: 1em; padding-bottom: 1em; padding-left: 2em; padding-right: 0; /* no units needed on 0 */ } /* specify one value for all sides at once */ .all-sides-padding { padding: 1.5em; } /* specify one value for top/bottom (first) and one for left/right (second) */ .x-and-y-sides-padding { padding: 1em 2em; } The padding is considered be “inside” of the element. Thus background styling (colors or images) will also apply to the padding area. Adding padding is a good way to increase the “size” of an element without needing to specify the width and height explicity. Border As noted above, the border (edge of the box) can be made visible and styled in terms of its width, color, and “style”. While thse can be set individually, it is most common to use the shorthand property to specify all three aspects at once. .boxed { border: 2px dashed black; /* border on all sides */ } Similar to with padding, you can specify the border on a specific side with properties such as border-top. In fact, you can specify each aspect of the border (width, color, style) individually for each side— the border property is actually a shorthand for 12 different properties! .underlined { border-bottom: 1px solid red; /* border one side */ } .individual-op-border { /* control border properties separately */ border-top-width: 4px; border-top-color: blue; border-top-style: dotted; } Relatedly, the border-radius property can be used to “round” the corners of the box. The value specified is the radius of the rounded arc. .rounded-rect { border-radius: 5px; /* rounded corners! */ } .circle { border-radius: 50%; /* radius is half the width, so produces a circle */ } Margin Finally, the margin specifies the space between this box and other nearby boxes. An element’s margins. The margin is declared in an equivalent manner to padding, with similar individual and shorthand properties: .individual-sides-margin { margin-top: 1em; margin-bottom: 1em; margin-left: 2em; margin-right: 0; /* no units needed on 0 */ } /* specify one value for all sides at once */ .all-sides-margin { margin: 1.5em; } Note that browsers typically collapse (overlap) the margins of adjacent elements. For example, if you have two paragraphs on top of one another, and you set margin-bottom on the first and margin-top on the second, most browsers will overlap those margins and just use the larger of the two values to determine the spacing. Padding vs. Margin Padding and margin are both used to add space around content on the page—indeed, without a visible border or background color, adding either will achieve close to the same appearance! It can sometimes be challenging to decide which property to use when adding spacing between elements. To help determine which to use, first remember that padding adds space inside the element, while margin adds space outside of it. If you want to make the element’s size larger—to have the border be further away or to have a larger background area, use padding. And if you want to put space between visible borders or visible background areas, use margin. More challenging is when the boundaries between elements are not visible. In those situations I consider the semantics: am I adding spacing because I want this element to take up more space (padding), or because I want it to be kept further away from other elements (margin)? I often default to using padding when styling smaller or inline elements, and margin when styling block or section elements. But either can be appropriate; just be aware of choices if you end up needing to adjust the spacing later! Box-Sizing An element’s padding, border, and margin can be used to put space between element content on the page. However, when you assign an explicit width or height to an element, the dimension you specify does not include the padding or border when calculating the size of the element on the page! That is, if you have an element with the properties .my-box { width: 100px; padding: 10px; /* includes both left and right */ } The above element will take up 120px on the screen: the width plus the left and right padding. This may seem intuitive, but can make sizing complex when including small adjustments such as borders. Indeed, when specifying more complex or responsive layouts, it’s often useful to have the width represent the entire width of the box, and not need to account for the border and padding separately in calculations. You can do this using the box-sizing property—a value of border-box will indicate that specified size of the box (e.g., the width) should include the size of the padding and border when determining the content area. .my-better-box { box-sizing: border-box; width: 100px padding: 10px; border: 1px solid black; } The above element will take up 100px on the screen. This means that the content may be given a smaller space than anticipated, but it allows you to adjust the padding or border without worrying about changes to the overall element width. It’s common to want to apply this property to all of the elements on the page, which you can do with the universal selector. * { box-sizing: border-box; /* all elements include border and padding in size */ } This is a good rule to include at the top of any .css file, and is often found in reset stylesheets. 7.5 Flow Layout By default, HTML elements are are displayed on the page in a default layout called normal flow. This layout is determined by the order that HTML elements appear in the source code, and whether each element is a block element or an inline element. As described in HTML Fundamentals, inline elements (e.g., &lt;em&gt;, &lt;a&gt;, &lt;span&gt;) are positioned next to each other on a single line (left to right, unless you specify a right-to-left language). Block elements (e.g., &lt;p&gt;, &lt;ul&gt;, &lt;div&gt;) are placed on subsequent “lines”, from top to bottom. &lt;div>Block element&lt;/div> &lt;div>Block element&lt;/div> Example of block elements, placed on top of each other. &lt;span>Inline element&lt;/span> &lt;span>Other inline element&lt;/span> Example of inline elements, next to each other (even if the code is on separate lines). It’s good practice to allow the browser to display elements using normal flow whenver you can. If the normal flow positioning based on element’s type and source code location gets that element into the correct position on the page, then don’t try to change it. It’s better to let the browser do what it can, and then use CSS to provide small adjustments (e.g., by adding a little padding or margin). This will help keep your CSS simplier and help ensure that the content continues to render reasonably on different browsers and devices. All HTML elements are classified as either block or inline elements. However, it is possible to change the element type by declaring the the display CSS property: .inlined { display: inline; } &lt;!-- this will produce the same result as using &lt;span> elements --> &lt;div class=\"inlined\">Inline element&lt;/div> &lt;div class=\"inlined\">Other inline element&lt;/div> Changing the display can be useful if the semantics of an HTML element are appropriate, but you want that element to be rendered in a different way. For example, you can have &lt;li&gt; elements display as inline elements instead of blocks, allowing you to have inline lists. In addition to specifying elements as either block or inline, elements can also be given a display value of inline-block. An inline-block element will be layed out as if it were inline (so other elements will be positioned next to it), but can still have its width, height, and other block-specific properties specified An example of an element with display: inline-block. The display property also allows you to remove elements from the page flow entirely by specifying a value of none. This will remove the element entirely from the normal flow, as well as from the content that is read by assistitive technologies such as screen readers. .hidden { /* do not show element at all */ display: none; } The display: none property is most commonly used when JavaScript and dynamic styling (e.g., to allow a user to remove or “hide” an element interactvity); for static pages, if content shouldn’t be shown then often you just don’t include it in the HTML. 7.6 Alternate Positioning By default elements are positioned on the page based on the normal flow described above. In general this is the best and easiest way to position elements. Nevertheless, it is possible to position elements outside of the normal flow (to “break” the regular flow). One way to position elements outside of normal flow is to use the position property. This property lets you specify the relative or exact position of an element in the document. The position property indicates by approach other than normal flow should be used to position the element, and then the top, bottom, left and right properties are used to indicate where or by how much that positioning should be changed. For example, an element with position: relative will adjust the element’s position relative to its normal flow position on the page, moving it some distance in the specified direction: .relative-element { position: relative; /* position will be relatively changed */ top: 10px; /* adjust position 10px down from the top */ left: 20px /* adjust position 10px over from the left */ } The top, left, etc properties take an offset as a value. Thus a property of top: 10px says to move an element down (away from the top) by 10px, and a propery of down: 20px says to move an element to the right (away from the left) by 20px. These values can also be negative: a property of top: -15px would move the element up by 15px. Because top and bottom both specify vertical position (and right and left both specify horizontal position), you only ever set one for a particular element—an element should not have both a top and a bottom property as they would be redundant or in conflict. Because these values are offsets applied to an inverted-y coordinate system, it can sometimes be hard to intuit where elements are positioned. Thus you should always visually inspect the outcome of your CSS rules, as well as minimize how many elements are take out of normal flow. It is also possible to give an element a position: absolute. An absoslutely positioned element will be displayed at the specified coordinates from its (first non-static) parent element. This allows you to specify where within a parent element you want an element to be positioned. .absolute-element { position: absolute; /* position will be absolutely determined */ top: 0; /* position 0px from the top of the page */ left: 30% /* position 30% of the page width from the left */ } Importantly, absolute positioned elements are positioned according to the first non-static parent (static is the default position value, indicating normal flow). With no other changes, this would be the &lt;body&gt; element, thus having the absolutely positioned element be specified relative to the entire page (and moving as the browser changes size). However, common practice is to place any absolutely positioned elements as children of a position: relative parent (that may have no further adjustment), so that the absolute elements are still placed relative to that element. See this post on absolute positioning inside of relative positioning for additional examples. It is also important to note that an element that has an absolute position is not given any space in the normal flow: other elements won’t move to accommodate date; the absolute element will overlap them. Thus using an absolute positioned element often requires you to create additional whitespace through other positioning or padding. In general, you should not use position: absolute. Such positioning is often inflexible—you’re hard-coding a position!—and thus is not likely to adjust well to different browsers, devices, or user needs. It makes it harder to adjust to changes in the code or content. Using normal flow whenever possible tends to work better. Finally, the position property can also take a value of fixed to specify the element’s position relative to the viewport (browser window), similar to using position: absolute without a relative parent. An element with position: sticky will be offset relative to its nearest scrolling parent (also usually the browser window) and then stay there even as the page scrolls. This is how you can create a “sticky navbar” that is always at the top of the page—though such effects consume valuable screen real estate with content the user may be need at the moment. Floating You can also position an element outside of normal flow by making it float. This is commonly done with pictures, but can be done with any element. A floated element is shoved over to one side of the screen, with the rest of the content wrapping around it: .floating-image { float: right; margin: 1em; /* for spacing */ } Content will continue to sit along side a floated element until it “clears” it (gets past it to the next line). You can alternatively force content to “clear” a float by using the clear property. An element with this property cannot have other elements floating to the indicated side: .clear-float { clear: both; /* do not allow floating elements on either side */ } The float property is good for when you simply want some content to sit off to the side. But you should not try to use this property for more complex layouts (e.g., multi-column structures); there are better solutions for that, such as a Flexbox. Never use the &lt;table&gt; tag to structure documents and position content. The &lt;table&gt; tag should only be used for content that is semantically a table (e.g., a data table). If you want to lay out content in a grid, use a CSS system such as Flexbox. 7.7 Flexbox A Flexbox is a technique for easily arranging items in flexible rows or columns. A flexbox is an alternate to relying on normal flow, and is particularly useful for creating complex effects such as multi-column layouts. A Flexbox layout allows you to efficiently lay out elements inside a container (e.g., columns inside a page) so that the space is flexibly distributed. This provides additional advantages such as ensuring that columns have matching heights. Flexbox is a new standard that is now supported by most modern browsers; it has a buggy implementation in Microsoft IE, but is supported in the standards-compliant Edge. For older browsers, you can instead rely on a grid system from one of the popular CSS Frameworks such as Bootstrap. Despite it’s capabilities, Flexbox still is designed primarily for one-directional flows (e.g., having one row of columns). To handle true grid-like layouts, browsers are adopting another emerging standard called Grid. The Grid framework shares some conceptual similarities to Flexbox (configuring child elements inside of a parent container), but uses a different set of properties. Learning Flexbox will help if you wish to learn Grid later. At its most basic, a flexbox is an element with the display: flex property. An element with this property will be a block element, but its children will be positioned following a “flexbox flow” rather than than the normal flow. Making an element into a flexbox (giving it display: flex) doesn’t change how that element is positioned, but changes how its children are positioned. When discussing flexboxes, the flexbox itself (the element with display: flex) is referred to as the flex container (or just the parent), while the child elements inside that flexbox are referred to as flex items or (or just the children) /* A flex container, or \"the flexbox\". The class name is not important */ .my-flex-container { display: flex; } By default, a flexbox will position its children horizontally (even if they are block elements), though you can adjust this by also specifying the flexbox’s flex-direction property. The child elements will be sized so that their width fits their content area, and their heights are all equal to the height of the flexbox. Thus with no other work, the elements inside of the flexbox will be layed out in “columns”! &lt;div class=\"flex-container\"> &lt;!-- Parent --> &lt;div class=\"flex-item\">Child 1&lt;/div> &lt;div class=\"flex-item\">Child 2&lt;/div> &lt;div class=\"flex-item\">Child 3&lt;/div> &lt;/div> An example of a simple Flexbox layout. Additional margin included for illustration. Further properties can then be used to modify the flow of the child elements within the flexbox, as well as the size and position of the individual child elements. For example, the following additional properties can be specified on the flex container (the flexbox itself—the parent): justify-content specifies how the items should be spread out across the container if there is extra space. This can be easily used to center the child elements—and if there is only a single child element, then that element will be centered in its parent. If the child elements’ width takes up the full span of the flexbox (so there is no extra space), then this property will have no visible effect. flex-wrap specifies if items should “wrap around” to the next line when they overflow the container instead of shrinking to fit. This is similar behavior to what you see with text wrapping to the next line when it gets too long. Items that have wrapped will continue to have the same height as others on their “row”, and will be justified as specified .my-flex-container { display: flex; /* make this element a flexbox */ flex-wrap; /* wrap children to next line if larger than the container */ justify-content: space-around; /* justify with equal space around the children */ } For more information on other properties that can be used to customize a flexbox, see the MDN documentation or the Flexbox Guide. You also can specify additional properties on the flex items (the immediate children of the flexbox) in order to adjust e.g., how much space of the flexbox they take up. These properties include: flex-grow specifies what “share” or ratio of any extra space in the container the item should take up. That is, if the container is 500px wide, but the items only take up 400px of space, this property determines how much of the remaining 100px is given to the specific item. The value is a unitless number (e.g., 1 or 2, defaulting to 0), and the amount of remaining space is divided up proportionally among the items with a flex-grow. So an item with flex-grow:2 will get twice as much of the remaining space as an item with flex-grow:1. If there are 4 items and 100px of space remaining, giving each item flex-grow:1 will cause each item to get 25px (100/4) of the extra space. If one of the items has flex-grow:2, then it will get 40px (\\(\\frac{2}{1+1+1+2}=\\frac{2}{5}=40\\%\\)) of the extra space, while the other three will only get 20px. In practice, you can give each item a property flex-grow:1 to have them take up an equal amount of the remaining space in the container. There is an equivalent flex-shrink property that specifies the ratio an item should shrink to accommodate overflow space. This property doesn’t do anything when the items are in wrapping container (flex-wrap:wrap); and in practice, it is rarely used. It’s generally better practice to focus on elements at their smallest allowed size and give them space to grow, rather than worry about how they may shrink. The most common usage is to specify that an item should not shrink by giving it a flex-shrink:0. Top: visual example of flex-grow. Bottom: visual example of flex-shrink. Notice how much extra “space” each item has after the text content. flex-basis allows you to specify the “initial” dimensions of a particular item. This has a similar effect to specifying the width property, except that flex-basis has a higher priority and may be slightly more flexible. Note that like width, this value can be an dimensional measurement (absolute units like 100px, or a relative unit like 25%). In practice, using percentages for the flex-basis will let you easily size the columns of your layout. There is also a shorthand property flex that allows you to specify three values at once: give the flex-grow, flex-shrink, and flex-basis values separated by spaces (the second two being optional if you want to use the default values). Note that if unspecified in the shorthand property, the flex-basis property will be set to 0, rather than the auto value it has if unspecified. For more information on other properties that can be used to customize a flex item, see the MDN documentation or the Flexbox Guide. While it may seem like a lot of options, it’s often enough to just use a basic flexbox (e.g., a &lt;div&gt; with display:flex). Adding such a container to “wrap” around content can help size the items and line them up horizontally. When using a flexbox, start by adding in the container, and then making small adjustments to achieve the effect you desire. You don’t always need to use a flexbox for layout! If the normal flow sufficiees, then use that. Resources Many resources are linked in the text to describe particular properties. Some additional (or important!) general resources can be found below. CSS Reference (MDN) a complete alphabetical reference for all CSS concepts. Learn to style HTML using CSS (MDN) CSS Units and Values (MDN) The Code Side of Color CSS Tricks Flexbox Guide "],["responsive-css.html", "Chapter 8 Responsive CSS 8.1 Mobile-First Design 8.2 Media Queries Resources", " Chapter 8 Responsive CSS These days the majority of people accessing any web site you build will be using a device with a small screen, such as a mobile phone. But phones come in a wide range of sizes and resolutions, and many people will still access that same site from a laptop or desktop with a much larger monitor (as well as other capabilities, such as a mouse instead of a touchscreen). Different screens may require different visual appearances: for example, a three-column layout would be hard to read on a mobile phone! This poses and interesting design dilemma: how do you build one site that looks good and works well on both tiny phones and gigantic desktop monitors? The modern solution to this problem is Responsive Web Design, which involves using CSS to specify flexible layouts that will adjust to the size of the display: content can be layed out one column on a small mobile screen, but three columns on a large desktop. Example of a responsive web site on multiple devices, with content and layout changing at each size. From responsivedesign.is. This chapter discusses CSS techniques used to create responsive web sites. These techniques underlie popular CSS frameworks, so it is important to understand them even if you rely on such tools. 8.1 Mobile-First Design Responsive design is often framed as a technique to “make it also work on mobile”. This approach feels easy since websites are usually developed and tested on desktops, and follows from the software principle of graceful degradation (systems should maintain functionality as portions break down, such as the “capability” of having screen real estate). But since websites are more likely to be visited on mobile devices, a better approach is to instead utilize mobile-first design. This is the idea that you should develop a website so it content and purpose is effectively presented on mobile devices (e.g., the most restricted in terms of screen size, capabilities, etc). Only once this base level of functionality is in place should you add features to make it also look good on larger devices such as desktops. This approach is also known as progressive enhancement: provide the core functionality, and then add “extra” features as more capabilities become available. Rather than viewing mobile devices as “losing” features, look at desktops as “gaining” features! This will help you to focus on better supporting more common mobile devices. Remember: working on your personal machine doesn’t ensure that it will work on anyone else’s! A great way to test the responsiveness of your design is to click on the Toggle Device Toolbar icon in your element inspector: toggle device toolbar This will allow you to specify a variety of different screensizes for specific devices of interest (i.e., an iPhone 5s, etc.). Mobile-First Design Principles While there is no magic formula for designing websites to support mobile devices, there are a few general principles you should follow: Layout: On mobile devices, blocks of content should stack on top of each other, rather than sitting side by side in columns—mobile devices want to only scroll on one axis. fixed content should be kept to a minimum, as it reduces the amount of scrollable screen real-estate. As you gain more screen space on desktops, you will want to break content up into columns or otherwise constrain its width so that it doesn’t stretch to ridiculous lengths; this helps with readability. Media: Small screens don’t have enough space to necessitate very large, high-resolution images and video. Moreover, large images have large file sizes, and so will take a long time to download on slow mobile connections (not to mention eating away at limited data plans). Use compressed or lower-resolution images on mobile, and consider using background colors or linear gradient fills instead of background images. You can use higher-resolution media (and more of it!) on desktops, which usually have higher bandwidth available for downloading. Page bloat is a real problem. You don’t need huge images… or possibly any images at all! Fonts: Make sure to use a large enough font that it is readable on small screens… but don’t make headings or callout text too large so that you lose that precious real estate! You can make them more styled and prominent on desktop, where there is room for such flourishes. Be sure to use relative units to accommodate mobile user preferences and screen size variation. Also remember that special web fonts you may be downloading will also take up extra bandwidth! Navigation: Site navigation links take up a lot of room on small screens and may end up wrapping to multiple lines. Use small tab bars, or menu icons (e.g., the “hamburger icon”) to show complex menus on command. Most CSS frameworks provide some kind of collapsible navigation for mobile devices. Input and Interaction: Tap/click targets need to be large-enough on mobile to select using a finger, especially for people with poor eyesight or thick fingers. Tiny icons placed right next to one another, or one-word hyperlinks are difficult to select accurately. Specifying a data type on form fields (e.g., email address, phone number, date, integer) also generates optimized on-screen keyboards, making data entry much easier. Content: For some sites, you may even want to adjust what content is shown to mobile users as opposed to desktop users. For example, a phone number might become a large telephone icon with a tel: hyperlink on mobile phones, but simply appear as a normal telephone number on desktop displays. Specifying Viewport Mobile web browsers will do some work on their own to adjust the web page in response to screen size—primarily by “shrinking” the content to fit. This often produces the effect of the website being “zoomed out” and the user enlarging the web page to a readable size and then scrolling around the page to view the content. While it may “work” it is not an ideal user interaction—this behavior can also interfere with attempts to be explicit about how webpages should adjust to the size of the screen. To fix this, you need to specify the viewport size and scale by including an appropriate &lt;meta&gt; element in your HTML: &lt;head> &lt;meta charset=\"utf-8\"> &lt;!-- always need this --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> &lt;!-- more head elements, including &lt;link> ... --> &lt;/head> Including this element will keep the text size from adjusting to the browser’s width (though very narrow browsers may still shrink the text). While not technically part of any web standard, the viewport meta element was introduced by Safari and is supported by most mobile browsers. The content attribute for the above meta tag sets 3 properties for mobile browsers: width (how big the viewport should be, specified to be the size of the device screen), initial-scale (how much to initially “zoom” the page, specified to be 1x or no zoom), and shrink-to-fit (tells Safari 9.0+ not to shrink the content to fit). You should include the viewport meta tag in all of your responsive pages. Make it part of your default HTML template! 8.2 Media Queries In order to define a webpage with a responsive appearance, you need to be able to conditionally change the applied style rules depending on the size of the screen (or browser window). We can conditionally apply CSS rules by using media queries. A media query is a bit like an if statement in CSS: it specifies a condition and the rules (selectors and properties) that should apply when that condition is true. Media queries have syntax similar to the following: /* A normal CSS rule, will apply to all screen sizes */ body { font-size: 14px; } /* A Media Query */ @media (min-width: 768px) { /* these rules apply ONLY on screens 768px and wider */ /* a normal CSS rule */ body { font-size: 18px; background-color: beige; } /* another CSS rule */ .mobile-call-icon { display: none; /* don't show on large displays */ } } A media query is structurally similar to a normal CSS rule. The “selector” is written as @media, indicating that this is a media query not a normal CSS rule. The @media is then followed by a query expression, somewhat similar to the boolean expressions used in if statements. Expressions are written in parentheses, with the media feature to check, followed by a colon (:), followed by the value to check against. There are no relational operators (no &gt; or &lt;) in media queries, so you use media features with names such as min-width and max-width (to represent width &gt; x and width &lt; x respectively). Media feature comparisons are not strict inequalities, so min-width: 1000px can be read as “width greater than or equal to 1000px”. It is also possible to use the logical operators and and not to combine media feature checks. You can produce an “or” operator using a group selector (a comma ,). /* style rules for screens between 768px and 992px */ @media (min-width: 768px) and (max-width: 992px) { } /* style rules for screens larger than 700px OR in landscape orientation */ @media (min-width: 700px), (orientation: landscape) { } The @media rule is followed by a {} block, inside of which are listed further regular CSS rules. These rules will only be applied if the @media rule holds. If the @media rule does not apply, then these “inner” rules will be ignored. These “inner” rules can utilize all the selectors and properties value outside of media queries—think of them as mini “conditional” stylesheets! You need to put full rules (including the selector!) inside of the media query’s body. You can’t just put a property, because the browser won’t know what elements to apply that property to. Media queries follow the same ordering behavior as other CSS rules: the last rule on the page wins. In practice, this means that media queries can be used to specify conditional rules that will override more “general rules”. So in the example above, the page is set to have a font-size of 14px using a rule that will apply on any screens. However, on larger screens, the media query will also apply, overriding that property to instead make the default font size 18px. Following a mobile-first approach, this means that your “normal” CSS should define the styling for a the page on a mobile device. Media queries can then be used to add successive sets of rules that will “replace” the mobile styling with properties specific to larger displays. /* on small mobile devices, the header has a purple background */ header { font-size: 1.2rem; background-color: mediumpurple; } /* on 768px OR LARGER displays */ @media (min-width: 768px) { header { font-size: 1.5rem; /* make the header larger font on larger displays */ } } /* on 992px OR LARGER displays */ @media (min-width: 992px) { header { background-image: url('../img/banner.png') /* use background image */ } } In this example, the &lt;header&gt; is given a simple purple background and default font size. When loaded on mobile devices, this is the only rule that applies (the media queries don’t apply to the given screensize), so that is all the styling that occurs. But on devices 768px or wider (like a tablet), the first media query is activated. This will then run a second rule that applies to the &lt;header&gt;, overriding the font to be larger (1.5rem)—it’s as if we had listed those two header rules one after another, and the later one wins. But the first rule continues to apply, making the background purple. Finally, a device 992px or wider (like a desktop computer), will cause both of the media queries to execute. (since a device whose width is greater than 992px is ALSO greater than 768px). Thus the &lt;header&gt; will be given a purple background and default font size, which will then be overridden to be a larger font by the first media query. The second media query will add an additional property (a banner image background), which will combine with the previous purple background (e.g., if the banner has any transparency). So on large displays, there will be a banner background on top of purple, with text in a larger (1.5rem) font. This structure (starting with “default” mobile rules and then using media queries with increasingly larger min-width values) produces an effective mobile-first approach and clean way of organizing how the appearance will change as the screen gets larger. Note that while you can define as many media queries as you want, most professionals define only a few that match the common breakpoints between phone, tablet, and desktop screen widths. Since the media queries need to come after the mobile rules, they are often included at the end of the stylesheet—give all the mobile rules first, then all the media queries that modify them. (You can and should put multiple rules in each media query). (Alternatively, it’s also reasonable to organize your stylesheets based on page “section”, with the mobile rules for that section given before the media queries for that section. E.g., after all your rules for creating the page header, put the media query with variations for desktop headers. Use whatever organization makes your code readable and maintainable, and leave plenty of comments to guide the reader!) Example: Responsive Flexbox As another example of using media queries to produce a responsive website, consider how they can combine with Flexbox to produce a single-column layout on mobile devices, but a multi-column layout on larger displays. Because a Flexbox layout is just a property applied to existing elements, we can effectively “turn on” the flex layout by using media queries. Consider some simple HTML: &lt;div class=\"row\"> &lt;div class=\"column\">column ONE content&lt;/div> &lt;div class=\"column\">column TWO content&lt;/div> &lt;div class=\"column\">column THREE content&lt;/div> &lt;div class=\"column\">column FOUR content&lt;/div> &lt;/div> By default (without any style rules applied to the .row or .column classes), the four inner &lt;div&gt; elements (as block elements) will stack on top of each other. This is the behavior you want on mobile narrow screens, so now additional CSS or Flexbox usage is needed. In order to turn these divs into columns on larger displays, introduce a media query that applies the flex layout to the .row (which acts as the container), thereby lining up the .column elements (which act as the items) /* on devices 768px OR WIDER */ @media (min-width: 768px) { .row { /* row becomes a flexbox container */ display: flex; } .column { /* column becomes a flexbox item */ flex-grow: 1; /* make the columns grow equally to fill the row */ } } You can also add an additional media query at another breakpoint so that the layout starts out stacked, then switches to two columns on medium-sized displays (leading to a two-by-two grid), and then switches to four columns on large displays: /* on devices 768px OR WIDER */ @media (min-width: 768px) { .row { /* row is a flexbox container */ display: flex; flex-wrap: wrap; /* wrap extra items to the next \"line\" */ } .column { /* column is a flexbox item */ flex-basis: 50%; /* columns take up 50% of parent by default */ flex-grow: 1; } } @media (min-width: 1200px) { .column { flex-basis: auto; /* columns are automatically sized based on content */ } } In this case, the first media query (768px + or medium-sized displays) applies the flex layout and specifies that the items should wrap if they overflow the container… which they will, since each item has a default flex-basis size of 50% of the container. This will cause each of the 4 items to take up 50% of the parent, wrapping around to the next line. Then when the screen is larger (1200px + or large-size displays), the second media query is applied and overrides the flex-basis so that it will automatically calculate based on the content size, rather than being 50% of the parent. That way as long as the columns fit within the parent, they will all line up in a row (they have the flex-grow property to make them equally spread out). The best way to get a feel for how this works is to see it in action: see this CodePen for an example of the above behavior—resize the browser and watch the layout change! Media rules are a powerful and declarative way to create a single page that looks great on everything from a small mobile touchscreen to a large desktop monitor with a mouse, and form the foundation for responsive CSS frameworks that can help you easily create fantastic looking pages. Resources Responsive Web Design Basics (Google) Using media queries (MDN) "],["css-frameworks.html", "Chapter 9 CSS Frameworks 9.1 Using a Framework 9.2 Bootstrap Resources", " Chapter 9 CSS Frameworks The previous chapters have covered how to use CSS to make your page both stylish and responsive. While it is certain possible to implement an entire site by creating your own CSS rules, that can quickly get tedious: often you’d like a page to have a “standard” set of rules (because the browser’s style-less appearance) and then customize those rules to your liking. For this reason, most professional web developers utilize an existing CSS Framework instead. A CSS Framework is a stylesheet (a .css file!) that contains a large list of pre-defined rules that you can apply to your page. CSS frameworks provide a number of benefits: Applies attractive default styling to all HTML elements: CSS frameworks make your pages instantly look better through a bunch of element selector rules. Frameworks provide pleasant default fonts, line spacing, spacing, and link styling without any extra effort on your part. Provides style classes for common UI components: framework stylesheets will also include CSS classes you can add to your markup to easily include badges, in-page tabs, drop-down buttons, multi-column layouts, and more. Frameworks enable you to add style your page by specifying CSS classes, rather than needing to define multiple CSS rules for a single effect. CSS frameworks are thus designed to make your life easier and your development more efficient—while still enabling you to provide your own customizations and styling with all of the power of CSS. There are many different CSS frameworks to choose from. Some popular ones include: Bootstrap is the most commonly used CSS framework on the web. Sometimes called “Twitter Bootstrap”, it was originally created at Twitter to enforce some consistency among their internal tools, but was released as an open-source project in 2011. Its popularity has benefits and drawbacks: it’s very well tested, documented, and supported, but it’s also so prevalent that it’s default look has become cliché. As of this writing, the latest major version of Bootstrap is v5, released in May 2021. This is a major update of v4 (released in 2017). Note that Bootstrap 4 introduced Flexbox as a foundation for its grid system, offering better performance. For this and other reasons, Bootstrap 4+ does not support IE 9 or earlier browsers. For older browsers, you’d need to use an even earlier version—or probably just skip the framework entirely at that point. This text discusses Bootstrap 5 as an example. It is recommended to always use the latest version of a library or framework. Be careful that you are looking at information about the right version if you seek out documentation or help online! Foundation has a reputation for being more ahead-of-the-curve than Bootstrap (introducing new features sooner). For example, it was the first framework to use a responsive mobile-first design, and provided a Flexbox-based grid long before Bootstrap. Foundation has most of the same UI elements as Bootstrap, but with a different look and feel (that can be customized through a web-based tool). Material Components for the Web (MCW) is an official implementation of Google’s Material Design visual language. This is the look-and-feel found in most Google products and Android applications. Material Design is very opinionated so MCW is very difficult to customize. The MCW style class names are also very verbose, as they follow the Block, Element, Modifier (BEM) naming scheme. Materialize is the other popular Material Design implementation. This is an open-source project, so it is not provided nor supported by Google. However, it is structurally similar to Bootstrap, making it easy to learn and popular among people who know that framework. normalize.css is not so much a full framework as a small utility that performs browser normalization (also called a “reset”). normalize.css standardizes the quirks across browsers and making it so that the same HTML and CSS is displayed more consistently and without errors. Note that most other frameworks include some version of this package (for example, Bootstrap contains a fork called Reboot). If you choose not to use a framework, you should still include normalize to make your sites consistent across browsers! Other frameworks exist as well, each with its own benefits and drawbacks (e.g., Skeleton is designed to be as lightweight as possible, but at the cost of features). 9.1 Using a Framework The important thing to realize is that a CSS framework is just a stylesheet with a bunch of rules that someone else wrote for you. There’s nothing magic about them. You can look at the stylesheet and see all the rules that have been defined, and it’s all stuff you could have written yourself (though some of it can be quite complex). But those rules have been crafted by professionals and tested on a wide array of browsers to ensure consistent results, so it’s a good idea to build on top of them rather than trying to re-invent the wheel. For example, you can view the normalize.css file at https://necolas.github.io/normalize.css/8.0.1/normalize.css and see that it looks exactly like the CSS you might write on your own! Including a Framework Because a CSS framework is just a CSS file, you include one in your page using a &lt;link&gt; element just like with any other stylesheet: &lt;head> &lt;!--... other elements here...--> &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css\"> &lt;link rel=\"stylesheet\" href=\"css/my-style.css\"> &lt;/head> Important! Note that you link the CSS framework before you link your own stylesheet. Remember that CSS is read top-to-bottom, and that the last rule on the page wins. By putting your stylesheet second, any rules you define will override the rules specified in the framework, thereby allowing you to continue to customize the appearance. For example, bootstrap.css gives the &lt;body&gt; a font-family of \"Segoe UI\" (a sans-serif font); you may instead want to have a different default typeface: /* my-style.css */ body { font-family: 'Comic Sans'; } If you included your stylesheet first in the &lt;head&gt;, then your rule would be applied initially but would be overridden by the bootstrap.css file, causing your rule to seem to have no effect! Thus you should always put your own custom CSS as the last &lt;link&gt; in the page, after any CSS frameworks. It is most common to include the minified versions of CSS frameworks: these are usually named as .min.css files (e.g., bootstrap.min.css). A minified file is one that has extra comments and white space removed, creating a file with a much smaller size (remember that each space and line break is a character so takes up a byte! Bootstrap goes from 160 kilobytes to about 127 kilobytes when minimized). Because web pages have to be downloaded, smaller pages will be downloaded faster, and thus will be “quicker” for the user. While an unminimized CSS file won’t “break the bank”, the extra white space doesn’t provide anything that you need. You can almost always switch between the minimized and non-minimized file just by changing the file name between file.css and file.min.css (when using a CDN). There are a few different ways of accessing a CSS framework’s stylesheet in order to link it into your page: Linking to a CDN The easiest option is usually to link to a Content Delivery Network (CDN), which is a web service intended to quickly serve files commonly used by multiple websites. To do this, you simply provide the URL for the file on the CDN’s servers as the href of your link (as in the example above). CDNJS is a CDN for packages and libraries operated by Cloudflare, and is a good place to start if you’re unsure of the CDN link for a packages. Other packages may have different CDN hosting (e.g., Bootstrap recommends a link from jsdeliver.net). In addition to being simple, CDNs also provide a distinct speed benefit: CDNs replicate their content to machines in several regions of the world, and use dynamic Domain Name Service (DNS) resolution to steer users to the machine nearest them. So a user in Australia might download the Bootstrap CSS from a server located in Singapore, while a user in France might get the same CSS file from a server located in Ireland. This helps increase the speed that the files are downloaded. Additionally, CDNs allow a site to take advantage of browser caching: browsers will save previously downloaded versions of a file to avoid downloading it again. If multiple sites all use the CDN version of Bootstrap, then the browser only has to download that file the first time you visit one of those sites. With popular frameworks like Bootstrap, it’s highly likely that your user has already visited a site that links to Bootstrap’s CDN version, and thus the Bootstrap files are already in the user’s browser cache. Finally, CDNs allow the frameworks to be accessed as a service, meaning that framework developers may be able to quickly patch bugs (if the fix doesn’t break existing code) without the web developer (i.e., the user of the framework) having to do anything. (This feature can also be seen as a drawback, as you need to trust the library developer not to break anything or accidentally include malicious code). The only real disadvantage to linking to a CDN is that it won’t work when you are offline. If you commonly do your development offline, or if you are building a web application that is meant to run offline, you’ll need to utilize a different method. Downloading the Source If you can’t link to a CDN, you’ll need to download the source file directly to your computer and saving it as a source code file in your project (often in a lib/ folder). These files can be found on the framework’s website, or often in their GitHub repo (look for the .css file, or for a dist/ distribution folder). In addition to being available offline, downloading CSS files directly provides a few other advantages: Frameworks may allow you to customize their content even before you include the file: selecting only the components you need, and adjusting base styling properties before downloading your customized source file. If you use a CSS pre-compiler such as SASS, you can often modify the source-code mix-ins to more easily provide your own customizations and override the default fonts, colors, sizes, etc. simply by changing some variables. If you use a build system such as webpack, then you can often combine all of your CSS files into a single file. This reduces the total number of files that need to be downloaded, which can increase the page load speed—especially on slower mobile networks. Note that it is also possible to utilize a package manager such as npm to download and manage the source for frameworks. This has the advantage of enabling you to avoid adding large extraneous source files to your code repo, as well as managing any dependencies for those libraries. Recall that you can install a package using npm, saving the dependency into your project’s package.json file: # install bootstrap (latest version) npm install bootstrap This will install the library’s source code into your project’s node_modules/ folder. Because you’ve saved the dependency in your package.json file, you can use the .gitignore file to exclude the node_modules/ folder from your code repo, having new developers install the required framework via npm install. You can also use npm to easily upgrade the packages (such as when a new version of Bootstrap comes out. Note that in order to then include the framework in your page, you would need to link in the actual .css file which would be found somewhere in the node_modules folder. You’ll need to dig around for it; the location is in no way consistent across all frameworks or even all versions of a framework: &lt;!-- notice the RELATIVE path to the file --> &lt;link rel=\"stylesheet\" href=\"node_modules/bootstrap/dist/css/bootstrap.min.css\"> Importantly, this relative &lt;link&gt; will only work if the node_modules folder is available at at the expected path—and since you never want to commit the node_modules folder to git (because of its size), this is not a viable solution for anything that will be published e.g., to Github Pages. For this reason, you should almost always use a CDN when importing a CSS framwork. The only exception will be when using a build system (such as React’s use of Webpack) which will automatically build the module file into your source code. 9.2 Bootstrap This section discusses some of the features and uses of the Bootstrap CSS framework. Note that many other frameworks are used in a similar fashion (though the specific classes and components may be different). You include the Bootstrap framework by linking its .css file to your page (whether from a CDN or a local file). You can get the link for the latest version from the Bootstrap Home Page. &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css\" integrity=\"sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65\" crossorigin=\"anonymous\"> (This &lt;link&gt; example has 2 additional (optional) attributes: integrity gives a cryptographic hash of the source code so the browser can make sure you didn’t download a malicious file by mistake, and crossorigin which says that no credentials are sent to the remote server—see the AJAX chapter for a more detailed discussion). When you first include the Bootstrap framework, you’ll immediately see the effects (usually for the better!): the default font has changed, margins are different, and so forth. The Bootstrap CSS file contains a number of rules that apply to elements without an extra work, including the &lt;body&gt; and headers. See the documentation for details about the default styling (as well as the entire “Content” section of the documentation). Utility Classes In addition to the base styling rules, Bootstrap also includes a huge number of rules that can be applied to elements by giving them a particular CSS class. These utility classes are what gives Bootstrap its power and flexibility. For example, Bootstrap provides text utilities that allow you to style text just by giving it a CSS class, rather than needing to write a new rule for that element. For example, you can make text center-aligned by using the text-center utility: &lt;p class=\"text-center\">This text will be centered on all viewport sizes.&lt;/p> Note that all you have done is add a class to the HTML, exactly like you would for any CSS rule. Bootstrap just happens to contain a rule which will apply to elements that have that class: /* from bootstrap.css */ .text-center { text-align: center !important; } While it would be entirely possible for you to write such a rule yourself, Bootstrap provides these classes as “built-in”, so you can focus on the semantics of the content rather than the CSS. (You might notice that the bootstrap.css file gives a lot of properties the !important flag. This is used to override other rules no matter how specific, allowing the Bootstrap rule to take effect no matter what. If you find yourself wanting to override this rule—e.g., you didn’t want the text to be centered—don’t try to write one that is more specific by using the !important flag yourself. Instead, just remove the Bootstrap class. If you don’t want the text to be centered, don’t give it the text-centered class! Don’t include Bootstap classes if you don’t want their effects, and never use the !important flag). Many elements need to be given an additional utility class to indicate that they should use Bootstrap styling. For example, in order to give a &lt;button&gt; a Bootstrap style, it needs to have the class btn. This allows you to utilize Bootstrap’s styling, but to not be forced to “override” that look and feel if you want to do something different. &lt;button>Plain button&lt;/button> &lt;button class=\"btn\">Bootstrap button&lt;/button> &lt;button class=\"btn btn-primary\">Primary colored button&lt;/button> Bootstrap button classes. Note that the second button has no color specified, so is white on a white background. The last button in this example has an additional utility class btn-primary that specifies which color style it should use. Bootstrap provides a number of pre-defined color styles, named after semantic meaning (e.g., primary or warning): Bootstrap Button colors. These same color classes can be applied to text elements (e.g., text-primary), element backgrounds (e.g., bg-primary), alert blocks (e.g., alert-warning), and more. Modifying the SASS source code for Bootstrap will allow you to easily customize these colors while keeping the theme consistent. Note that you can even use the btn class to style other elements (e.g., &lt;a&gt; links) so that they look like buttons! &lt;a class=\"btn btn-primary\" href=\"#\">A link&lt;/a> This allows you to keep the semantic meaning of the HTML even if the styling changes. Something that the user clicks to navigate to a different location is a hyperlink (an &lt;a&gt;), even if you want it to look like a button. “Stacking” utility classes like this is quite common in Bootstrap; it is not unusual for an element to have 4 or 5 different utility classes to fully specify its appearance. For example, you could use the spacing utilities to specify the spacing around an element: &lt;div class=\"p-3 pt-1 mx-2 mb-2\">An element with padding and spacing&lt;/div> This element has the p-3 class, which gives it “3 spacers” worth of padding on all sides. But pt-1 causes it to only have 1 spacer worth of padding on the top. The mx-2 class gives it 2 spacers of margin on the x axis (th left and right), and the mb-2 class gives it 2 spacers of margin on the bottom. Bootstrap is filled with utility classes, both for generic styling (e.g., borders or position), and for specific types of content (e.g., lists, tables, forms). It even provides classes for specifying and managng flexboxes. Explore the documentation and examples for details on how to style particular elements and achieve specific effects. Bootstrap also includes guidance and classes that can specifically support screen readers. For example, the .visually-hidden class can be used to style an element so it is only perceivable to screen readers. Utility classes do not mean you never have to write any CSS rules! While Bootstrap provides classes to handle lots of “common” styling, you’ll almost always need to add your own customizations on top of it to produce the appearance you want. At the very least, writing CSS rules that apply to lots of elements can help make your styling more readable and consistent. Responsive Design A major feature of Bootstrap (and other CSS frameworks) is the ability to support mobile-first, responsive webpages. Many Bootstrap utility classes use media queries to cause them to respond to the device’s screen size. Bootstrap’s responsive utilities utilize a predefined set of responsive breakpoints: screen widths that mark the “boundaries” between different size devices. Screen Width Abbreviation Approximate Device Size &lt; 576px (default) Extra-small devices (e.g., portrait phones) ≥ 576px sm Small devices (e.g., landscape phones) ≥ 768px md Medium devices (e.g., tablets) ≥ 992px lg Large devices (e.g., laptops) ≥ 1200px xl Extra-large devices (e.g., desktops) ≥ 1400px xxl Extra-large devices (e.g., big desktops) All of these size specifications are “greater than or equal”, following a mobile first approach. Thus a responsive utility that applies to a medium (md) screen will also apply to large (lg) and extra-large (xl) screens. Responsive utilities are named with the size’s abbreviation to specify what screen size that utility should apply on. For example, the float-left class will cause an element to float to the left on any sized screen (it has no size specification). On the other hand, the float-md-left class will cause the element to float only on medium or larger screens. Similarly, the float-lg-left class would cause the element to float only on large or larger screens. This would allow you to have an image that floats to the side on a bigger screen, but is flowed with the rest of the content when there isn’t enough room. (Don’t use float; use a flexbox instead!) The breakpoint abbreviations are consistent across Bootstrap (and even shared by other frameworks such as Materialize), and usually comes after the name of property to change but before the value to give it. For example, the d-none class gives an element a display:none on all devices, while d-sm-none would apply on small or larger screens. Many (but not all!) Bootstrap classes support responsive breakpoints. The most common class to do this is the container class. Containers are the most basic layout element in Bootstrap, and are required for doing more complex layouts (such as Grids, below). The container class gives the element a fixed width that includes some padding on the sides, so that the content isn’t right up against the edge of the window. If the size of the window shrinks to the point where the padding would disappear, the container responsively changes size so that there remains padding even on the smaller screen! See this Code Pen for an example. If you slowly resize the browser, you’ll see the text “jump” to a smaller width as you pass each responsive breakpoint. .container elements are often direct children of the &lt;body&gt; (e.g., &lt;header&gt;, &lt;main&gt;). However, if you want a background color or image to “full bleed” to the edges of the viewport, you can put the .container inside the another element that is styled with the background, as in the CodePen example. Do not put one .container inside of another! This will add multiple layers of padding that are almost certainly not what you expect. Similarly, because the class name .container is fairly generic, be careful when naming your own classes so they don’t overlap—for example, a flexbox container should probably be called something like .flexbox-container. Bootstrap also provides an alternate container-fluid class that always has the same amount of padding around the content, with the content “reflowing” based on the browser size. In general, every page you style with Bootstrap will have a Container (usually a .container) to hold the content. The Grid After Containers, most common use of the responsive utility classes in CSS frameworks such as Bootstrap is to provide a grid layout, similar to the multi-column layouts created with Flexbox in the previous chapters. The Bootstrap Grid system allows you to specify these kinds of complex, responsive layouts without needing to implement your own Flexbox containers and items. In Bootstrap 5, the grid is implemented using a flexbox—so you can think of it as just another way of semantically defining flexbox elements. You specify that a set of elements should be part of a “grid” by putting them inside a .row element (the row class ensures that the elements are lined up). A .row acts a lot like a “flex-container” (and in fact does have display:flex), where each of its children will be “flex items”. &lt;div class=\"row\"> &lt;!-- a row of items --> &lt;div class=\"col-6\">Item 1&lt;/div> &lt;div class=\"col-4\">Item 2&lt;/div> &lt;div class=\"col\">Item 3&lt;/div> &lt;/div> You specify how wide each item in the .row is by specifying the number of “columns” it spans. Think of the grid as containing 12 “slots”: Each item in the grid is given a class that indicates how many of these slots it takes up (similar to merging cells in a spreadsheet): These classes are named in the format col-#, where the # is how many column slots it should take. For example a .col-4 will take up 4 columns, while a .col-6 will take up 6 columns. A class of just col will take up an equal share of the remaining columns (similar to what happens with the flex-grow property!) Thus the above HTML will produce elements with the following layout: Notice that “Item 1” takes up half (6/12) of the grid, “Item 2” takes up a third (4/12), and “Item 3” takes up the remainder (2/12). You can also make this grid layout responsive by using responsive utility versions of the col-# classes. For example, a .col-md-4 would take up 4 columns only on medium or larger screens, while a .col-lg-6 would take up 6 columns only on large or larger screens. Note that a child of the .row that doesn’t have a column size will effectively act as its own row (on its own line). Finally, note that you can specify multiple responsive utilities on each grid item! For example, you can specify that items should take up 6 columns on small or larger screens (col-sm-6), only but 3 columns on medium or larger screens (col-md-3): &lt;div class=\"row\"> &lt;div class=\"col-sm-6 col-md-3\">Item 1&lt;/div> &lt;div class=\"col-sm-6 col-md-3\">Item 2&lt;/div> &lt;div class=\"col-sm-6 col-md-3\">Item 3&lt;/div> &lt;div class=\"col-sm-6 col-md-3\">Item 4&lt;/div> &lt;/div> (See a CodePen of this code in action!) The ordering of Bootstrap’s CSS means that the col-sm-6 class will get overridden by the col-md-3 class (since md is a more specific size than sm), so you can specify both classes and the correct one will apply—the order of the class names in the element doesn’t matter. Note that the “or larger” part of the responsive breakpoint definition also means that you don’t need to specify a column width for each different breakpoint, only for the smallest level at which the utility should apply (e.g., we don’t need col-lg- since it isn’t different than col-md-). Bootstrap includes a number of utilities that can be used to customize how grids of content are displayed, including all of the features of Flexbox. For more details and options, see the Grid documentation. Components In addition to its basic and responsive utilities, Bootstrap provides a number of CSS classes that let you easily create more complex components or widgets: alerts, cards, navbars, collapsible boxes, image carousels, pop-up modals, and more. Each of these components is discussed in the documentation, and has its own particular element structure and CSS classes you need to use. For example, you can create a card (a styled content container) by creating an element with the card class and card-body child. You can then include other nested elements with classes such as card-img-top, card-title, or card-text to produce further styled effects: &lt;div class=\"card\"> &lt;!-- the card --> &lt;img class=\"card-img-top\" src=\"...\" alt=\"image at top of card image\"> &lt;div class=\"card-body\"> &lt;!-- the \"body\" of the card --> &lt;h4 class=\"card-title\">A Card Title&lt;/h4> &lt;p class=\"card-text\">Some card text that appears below the card title.&lt;/p> &lt;a href=\"#\" class=\"card-link\">Action Link 1&lt;/a> &lt;a href=\"#\" class=\"card-link\">Action Link 2&lt;/a> &lt;/div> &lt;/div> (See this code in CodePen). Many of these components include some form of interactivity: for example, the navbar will “collapse” into a hamburger menu on small devices, while modals add in-page pop-up dialogs. CSS is not capable of adding this level of interactivity—that requires JavaScript. Thus to support these components, you also need to include the Bootstrap JavaScript library: &lt;!-- the Bootstrap JavaScript library --> &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js\">&lt;/script> See the chapter on JavaScript for more details on including JavaScript libraries. Note that not all components or utilities require JavaScript. However, with most Bootstrap components, you don’t actually need to write any JavaScript code. Instead, you just need to provide some particular data- HTML attributes, and the library will take care of everything else. A data attributes is an normal HTML attribute that begins with the text data- (e.g., data-thingamabob or data-my-attribute). The HTML specification explicitly says that attributes that begin with data- are legal but not part of the standard, thus enabling them to be used for storing app-specific information. They effectively act as custom “variables” for elements that do not violate the HTML standard. For example, consider the below code from Bootstap’s documentation for defining a modal and a button to open it: &lt;!-- note that the `id` attribute is set to \"exampleModal\" --> &lt;div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\"> &lt;div class=\"modal-dialog\"> &lt;div class=\"modal-content\"> &lt;div class=\"modal-header\"> &lt;h1 class=\"modal-title fs-5\" id=\"exampleModalLabel\">Modal title&lt;/h1> &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\">&lt;/button> &lt;/div> &lt;div class=\"modal-body\"> ... &lt;/div> &lt;div class=\"modal-footer\"> &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close&lt;/button> &lt;button type=\"button\" class=\"btn btn-primary\">Save changes&lt;/button> &lt;/div> &lt;/div> &lt;/div> &lt;/div> &lt;!-- data-toggle must be set to \"modal\" and data-target must be set to the value of the `id` attribute on the element that starts your modal markup --> &lt;button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#exampleModal\"> Open the Modal &lt;/button> (Try it out in CodePen). There is a lot to unpack in this code, including styling classes and ARIA attributes (e.g., role, aria-labelledby, and aria-hidden). The important part is that the root .modal element is hidden (display:none) when the page first loads. But when you click on the &lt;button&gt;, the included JavaScript library sees that it has a data-toggle=\"modal\" attribute, and determines that clicking the button should show the modal. The JavaScript using the data-target attribute on that button to determine which modal to open (finding the modal with that id), and then shows it. The data-dismiss attribute on the first &lt;button&gt; inside the modal allows it to be closed. The best way to understand these components is to start from the examples in the documentation, and then consider each element and attribute one at a time. Read the documentation! The JavaScript included in these CSS frameworks allows you to easily add interactive features, but they do not mix well with more advanced JavaScript frameworks like React. To work with React, you’d need to switch instead to a library such as react-bootstrap, which uses the Bootstrap CSS stylesheet, but re-implement the JavaScript portions to fit into the React framework. Resources Bootstrap Documentation Materialize Documentation Foundation Documentation Material Components for the Web Documentation normalize.css Documentation This chapter was borrowed to a large extent from a tutorial by David Stearns. "],["javascript.html", "Chapter 10 JavaScript Fundamentals 10.1 Programming with JavaScript 10.2 Running JavaScript 10.3 Writing Scripts 10.4 Variables 10.5 Control Structures 10.6 Functions Resources", " Chapter 10 JavaScript Fundamentals HTML and CSS are markup languages, used to annotate websites to describe their meaning and appearance. But they are not “full” (i.e., Turing Complete) programming languages—they don’t have variables, control structures, or other features required for the computer to execute an algorithm. So to make interactive websites or complex web applications, you need a complete programming language. And the language used by browsers is JavaScript. This chapter introduces the fundamentals of the JavaScript language as used in web development, focusing on variables, data types, and basic control structures. Functions are introduced, but addressed in more detail in the next chapter. Note, this course assumes you already are already familiar with introductory programming in a imperative language such as Java. It focuses on how JavaScript differs from languages such as Java, rather than foundational programming concepts. If you need review on those topics, you can check out a basic programming tutorial or review your notes from a previous programming course. 10.1 Programming with JavaScript JavaScript is a high-level, general-purpose programming language, allowing you to declare instructions for the computer in an almost-human readable way (similar to Java). JavaScript is an imperative language, so you write algorithms as step-by-step instructions (lines of code) using JavaScript’s syntax, and the computer will interpret these instructions in order to execute the algorithm. Browsers are able to download scripts written in JavaScript, executing them line-by-line and using those instructions to manipulate what content is displayed. Indeed, JavaScript is an interpreted language, in that the computer (specifically a JavaScript Interpreter) translates the high-level language into machine language on the fly at runtime. The interpreter will read and execute one line of code at a time, executing that line before it even begins to consider the next. This is in contrast with compiled languages like C or Java that have the computer do the translation in one pass (at compile-time), and then only execute the program after the whole thing is converted to machine language. This on-the-fly translation means that interpreted languages like JavaScript are usually slower than compiled languages, but not enough that we’ll notice (web browsers include highly optimized interpreters). The bigger drawback is that without the compile step, program errors appear at runtime rather than compile time, making them more difficult to catch and fix. As such, JavaScript developers make heavy use of various linting tools (which flag common problems that can lead to runtime errors), as well as automated testing systems to check against a variety of inputs. Many JavaScript editors do this kind of error checking—for example, VS Code provides syntax error checking out of the box, with more detailed linting available through extensions. See this article for more code features that support programming in JavaScript, including IntelliSense and type checking. Although JavaScript was designed for and is most commonly used within web browsers (which contain their own JavaScript Interpreters), it can also be executed on the command line by using Node.js, allowing JavaScript to be a fully general language. Both techniques are described in this chapter. History and Versions The JavaScript language was developed by Brendan Eich (the co-founder of Mozilla) in 1995 while he was working for Netscape. The original prototype of the language was created in 10 days… a fact which may help explain some of the quirks in the language. Despite the names, JavaScript and the Java language have nothing to do with one another (and are in fact totally separate programming languages used in drastically different contexts). JavaScript was named after Java as a marketing ploy to cash in on the popularity of the latter. It is the programming equivalent of the Transmorphers movie. The JavaScript language is officially an implementation of ECMAScript (named for the European Computer Manufacturers Association) specification. Hence versions of JavaScript are labeled with the prefix “ES”. For example, this chapter describes ES5 (JavaScript 5) syntax. Like HTML and CSS, the JavaScript language continues to be developed and refined through new versions. Each new version of JavaScript includes additional syntax shorts, specialized keywords, and additional core functions, but otherwise are compatible with previous code. The main limitation on utilizing new JavaScript features is whether the interpreters found in web browsers are able to support them. This course primarily utilizes syntax and features for ES5, which was introduced in 2009 and today is supported by all modern browsers (i.e., IE 10 or later). Later chapters will describe features of ES6 (also called ES2015), which was introduced in 2015 and works on many browsers (e.g., Microsoft Edge but not IE 11). ES7 was finalized in 2016 but is still not reliably supported. Note that Microsoft no longer supports earlier versions of IE, but a small percentage of desktops still run Windows XP with IE 8. If you must support these browsers, you can often use a “transpiler” like Babel to translate modern JavaScript source code into an earlier version. 10.2 Running JavaScript There are two primary ways of executing code written in JavaScript: In the Browser JavaScript scripts are most commonly executed in a web browser as part of the browser rendering a web page. Since browsers render HTML content (in .html files), JavaScript scripts are included in that HTML by using a &lt;script&gt; tag and specifying the relative path to the a file containing the code (usually a .js file) to execute. When the browser renders the HTML (reading top to bottom) and gets to that tag, it will download and execute the specified script file using the JavaScript interpreter: &lt;!-- execute the script.js file --> &lt;script src=\"path/to/my/script.js\">&lt;/script> Notice that the &lt;script&gt; element is not empty! It is possible to include JavaScript code directly inside the tag, but this is considered bad practice (keep concerns separated!) and should only be used for quick tests. The &lt;script&gt; tag can be included anywhere in an HTML page. Most commonly it is either placed in the &lt;head&gt; in order for the script to be executed before the page content loads, or at the very end of the &lt;body&gt; in order for the script to be executed after the page content loads (and thus allows the JavaScript to immediately interact with the loaded HTML elements). We will (begin by) most commonly be putting &lt;script&gt; tags at the end of the &lt;body&gt;: &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;!-- include here to run before the page appears --> &lt;script src=\"js/script.js\">&lt;/script> &lt;/head> &lt;body> ... content ... &lt;!-- include here to run \"after\" html appears --> &lt;!-- we will usually do this --> &lt;script src=\"js/script.js\">&lt;/script> &lt;/body> &lt;html> Most browsers also support adding a defer attribute to the &lt;script&gt; element that tells the browser to defer downloading and running the script until the page is fully loaded and rendered to the screen. With this attribute, you can put the &lt;script&gt; element in the &lt;head&gt; without any issues. However, this attribute is not supported in IE 9 or earlier; it is thus still best practice to put the &lt;script&gt; element at the end of the body. While JavaScript most commonly is used to manipulate the web page content and is thus pretty obvious to the user, it also can produce “terminal-like” output—including printed text and error messages. This output can be viewed through the JavaScript Console included as a developer tool in the Chrome browser (other browsers include similar tools): Accessing the developer console in Chrome. Important: You should always have the JavaScript Console open when developing JavaScript code, since this is where any error messages will appear! On the Command-line with Node.js It is also possible to execute JavaScript code on the command line using Node.js. Node is a command line runtime environment—that is, a JavaScript interpreter that can be run on the command line. With Node installed on your machine, you can use the node terminal command to start an interactive Node session. This will allow you to type JavaScript code directly in the terminal, and your computer will interpret and execute each line of code: An interactive Node session. You can enter one line of code at a time at the prompt (&gt;). This is a nice way to experiment with the JavaScript language or to quickly run and test some code. You can exit this session by typing the quit() command, or hitting ctrl-z (followed by Enter on Windows). Note that the JavaScript console in the Chrome Developer tools provides the same interactive functionality. It is also possible to run entire scripts (.js files) from the command line by using the Node command and specifying the script file you wish to execute: node my-script.js This allows you author entire programs in JavaScript (e.g., writing the code using VS Code), and then executing them from the command line. This process is more common when doing server-side web development (such as implementing a web server using Node), but we will still use it for practice and testing. 10.3 Writing Scripts Unlike Java or C, JavaScript has no main() method that “starts” the program. Instead, a JavaScript script (a .js file) contains a sequence of statements (instructions) that the interpreter executes in order, one at a time, top to bottom—just as if you had typed them into an interactive session one after another. Each line can declare a variable or function, which will then be available to the next statement to use or call. Thus with a JavaScript program, you should think of the sequence of steps you want to be performed, and write lines of code in that order. In a way, you can think of the entire file as the “body” of a main() method… except that this body will contain further function declarations. For example: /* script.js */ /* This is the ENTIRE contents of the file! */ console.log(\"Hello world!\"); //this is executed first console.log(\"I'm doing JavaScript!\"); //this is executed second The above example code demonstrates the console.log() function, which is JavaScript’s equivalent to Java’s System.out.println()—the output will be shown in the JavaScript console (in the Developer Tools). Thus we talk about “logging out” values in JavaScript, instead of “printing” values in Java. The console.log() function is technically a log() method belonging being called on a global console object. Globals and objects will be discussed in more detail below. Don’t forget the semicolons! As in Java, each statement should end with a semicolon (;) marking the end of that statement. But unlike Java, JavaScript can be forgiving if you forget a semicolon. The JavaScript interpreter tries to be “helpful” and will often assume that statements end at the end of a line if the next line “looks like” a new statement. However, it occasionally screws up in horrible ways—and so best practice as a developer is to always include the semicolons. Strict Mode ES5 includes the ability for JavaScript to be interpreted in strict mode. Strict mode is more “strict” about how the interpreter understands the syntax: it is less likely to assume that certain programmer mistakes were intentional (and so try to run the code anyway). For example, in strict mode the interpreter will produce an Error if you try and use a variable that has not yet been defined, while without strict mode the code will just use an undefined value. Thus working in strict mode can help catch a lot of silly mistakes. You declare that a script or function should be executed in strict mode by putting an interpreter declaration at the top: 'use strict'; This is not a String (or even JavaScript code!), but rather a declaration to the interpreter about how that interpreter should behave. ALWAYS USE STRICT MODE! It will help avoid typo-based bugs, as well as enable your code to run more efficiently. 10.4 Variables Variables in JavaScript are dynamically typed. This means that variables are not declared as a particular type (e.g., int or String), but instead take on the data type (Number, String, etc.) of the value currently assigned to that variable. As we don’t specify the data type, JavaScript variables are declared using the let keyword: let message = 'Hello World'; //a String console.log(typeof message); //=> `string` let shoeSize = 7; //a Number console.log(typeof shoeSize); //=> 'number' The typeof operator will return the data type of a variable. It is not widely used outside of debugging. As in Java, JavaScript variables should be given descriptive names using camelCase. Pro Tip: Even though variables in JavaScript loosely typed, the data type of a value is still important! In order to help keep track of the type of each variable in JavaScript, include the type in the variable name. For example: textString, wordsArray, totalNum, itemStr, etc.. Declared variables have a default value of undefined—a value representing that the variable has no value. This is somewhat similar to null in Java (though JavaScript also as an null value that is not commonly used): //create a variable (not assigned) let hoursSlept; console.log(hoursSlept); //=> undefined Note that the let keyword is in fact new syntax introduced with ES6: older versions of JavaScript used the var keyword instead (and you will see var in most existing examples and tutorials). The difference is that variables declared with let are “block scoped”, meaning they are only available within the block (the {}) in which they are defined. This is the same way variables are scoped in Java. Variables declared with var, on the other hand, are “functionally scoped” so are available anywhere within the function in which they are defined. This means that you could declare a variable within an if block, and that variable would continue to be available outside that block! Thus let allows for cleaner, more efficient code, and with less bugs. let is the one ES6 feature supported by IE 11, meaning it can be used with most current browsers. However, if you do need to support an older browser (e.g., IE 10, Safari 9.3, Android 4.4), you should transpile your code or stick to using var Along with let, JavaScript variables can also be declared using the const keyword to indicate that they are constant (similar to what the final keyword does in Java). A const variable is block scoped, but can only be assigned once: const ISCHOOL_URL = 'https://ischool.uw.edu'; //declare constant ISCHOOL_URL = 'https://example.com'; //TypeError: Assignment to constant variable. Basic Data Types JavaScript supports many of the same basic data types as Java and other languages: Numbers are used to represent numeric data (JavaScript does not distinguish between integers and floats). Numbers support the same mathematical and operators as Java. Common mathematical functions can be accessed through in the built-in Math global (similar to Java’s Math class). let x = 5; typeof x; //'number' let y = x/4; typeof y; //'number' //numbers use floating point division console.log( x/4 ); //1.25 //use the Math.floor() function to do integer division console.log( Math.floor(x/4) ); //1 //other common Math functions available as well console.log( Math.sqrt(x) ); //2.23606797749979 Strings can be written in either single quotes (') or double quotes (\"), but most style guidelines recommend single quotes—just be consistent! Strings can be concatenated as in Java: let name = 'Joel'; let greeting = 'Hello, my name is '+name; //concatenation Strings also support many methods for working with them. As with Java, JavaScript strings are immutable, so most string methods return a new, altered string. let message = 'Hello World'; let shouted = message.toUpperCase(); console.log(shouted); //=> 'HELLO WORLD' Booleans (true and false) in JavaScript work the same way as in Java, can be produced using the same relational operators (e.g., &lt;, &gt;=, !=), and support the same logical operators (e.g., &amp;&amp;, ||, and !): //conjunction (and) boolOne &amp;&amp; boolTwo //disjunction (or) boolOne || boolTwo //negation (not) !boolOne //not See Type Coercion and Control Structures below for more on working with Booleans in JavaScript. Arrays JavaScript also supports arrays, which are ordered, one-dimensional sequences of values. As in Java, JavaScript Arrays are written as literals inside square brackets []. Individual elements can be accessed by (0-based) index using bracket notation. //an array of names let names = ['John', 'Paul', 'George', 'Ringo']; //an array of numbers (can contain \"duplicate\" values) let numbers = [1, 2, 2, 3, 5, 8]; //arrays can contain different types (including other arrays!) let things = ['raindrops', 2.5, true, [3, 4, 3]]; //arrays can be empty (contain no elements) let empty = []; //access using bracket notation console.log( names[1] ); // \"Paul\" console.log( things[3][2] ); // 3 numbers[0] = '340'; //assign new value at index 0 console.log( numbers ); // [340, 2, 2, 3, 5, 8] Note that it is possible to assign a value to any index in the array, even if that index is “out of bounds”. This will grow the array (increase its length) to include that index—intermediate indices will be given values of undefined. The length of the array (accessed via the .length attribute) will always be the index of the “last” element + 1, even if there are fewer defined values within the array. let letters = ['a', 'b', 'c']; console.log(letters.length); // 3 letters[5] = 'f'; //grows the array console.log(letters); // [ 'a', 'b', 'c', , , 'f' ] //blank spaces are undefined console.log(letters.length); // 6 Arrays also support a variety of methods that can be used to easily modify their elements, similar to the ArrayList class in Java: //Make a new array let array = ['i','n','f','o']; //add item to end of the array array.push('340'); console.log(array); //=> ['i','n','f','o','340'] //combine elements into a string let str = array.join('-'); console.log(str); //=> \"i-n-f-o-340\" //get index of an element (first occurrence) let oIndex = array.indexOf('o'); //=> 3 //remove 1 element starting at oIndex array.splice(oIndex, 1); console.log(array); //=> ['i','n','f','340'] Objects The most generic and useful data type in JavaScript is the Object data type. An Object is a lot like an array in that it is in that it is a (one-dimensional) sequence of values that are all stored in a single variable. However, rather than using integers as the index for each element, an Object uses Strings. Thus Objects are unordered sequences of key-value pairs, where the keys (called “properties”) are arbitrary Strings and the values are any data type—each property can be used to look up (reference) the value associated with it. This is a lot like a real-world dictionary or encyclopedia, in which the words (keys) are used to look up the definitions (values). A phone book works the same way (the names are the keys, the phone numbers are the values). A JavaScript Object provides a mapping from properties to values. JavaScript Objects are similar data structures to Java HashMaps, Python dictionaries, R lists, or even an HTML &lt;dl&gt; descriptive list! More generally, these are known as associative arrays (they are arrays that “associate” a key and a value). As with other associative arrays, JavaScript Objects are implemented as hash tables, making data access very fast. Objects are written as literals inside curly braces {}. Property-value pairs are written with a colon (:) between the property name and the value, and each element (pair) in the Object is separated by a comma (,). Note that the property names do not need to be written in quotes if they are a single word (the quotes are implied—properties are always Strings): //an object of ages (explicit Strings for keys) //The `ages` object has a `sarah` property (with a value of 42) let ages = {'sarah':42, 'amit':35, 'zhang':13}; //different properties can have the same values //property names with non-letter characters must be in quotes let meals = {breakfast:'coffee', lunch: 'coffee', 'afternoon tea': 'coffee'} //values can be of different types (including arrays or other objects!) let typeExamples = {number:12, string:'dog', array:[1,2,3]}; //objects can be empty (contains no properties) let empty = {} Important note: Objects are an unordered collection of key-value pairs! Because you reference a value by its property name and not by its position (as you do in an array), the exact ordering of those elements doesn’t matter—the interpreter just goes immediately to the value associated with the property. This almost means that when you log out an Object, the order in which the properties are printed may not match the order in which you specified them in the literal. If you console.log() an object, you will usually see a nicely format version of that object. However, if you try to convert that object to a string (e.g., via concatenation: let output = \"my object: \"+myObject), you will instead be presented with the “string version” of that object: [object Object]. This is not an array, but the String version of an object (similar to the hash you get when you try and print a Java array directly). You can instead use the fact that console.log accepts multiple parameters to output an object with a leading string: let myObject = {a:1, b:2} //convert object to string, won't log nicely console.log(\"My object: \" + myObject); //=> My object: [object Object] //log the object directly console.log(\"My object \", myObject); //=> My object {a: 1, b: 2} Despite the name, JavaScript Objects have nothing to do with Object-Oriented Programing. However, they can be used to represent “things” in the same way as a Java object, with each property acting like an “attribute” (instance variable): //an object representing a Person (spacing is for readability; white-space is ignored) let person = { firstName: 'Alice', lastName: 'Smith', age: 40, pets: ['rover', 'fluffy', 'mittens'], //value is an array favorites: { //value is another object music: 'jazz', food: 'pizza', numbers: [12, 42] //value is an array } } Accessing Objects Similar to arrays, Object values can be access via bracket notation, specifying the property name as the index. If an object does not explicitly have a property value, accessing that key produces undefined (the property’s value is undefined). let favorites = {music: 'jazz', food: 'pizza', numbers: [12, 42]}; //access variable console.log( favorites['music'] ); //'jazz' //assign variable favorites['food'] = 'cake'; //property name is a string console.log( favorites['food'] ); //'cake' //access undefined key console.log( favorites['language'] ); //undefined favorites['language'] = 'javascript'; //assign new key and value //access nested values console.log( favorites['numbers'][0] ); //12 //use a variable as the \"key\" let userInputtedTopic = 'food'; //pretend this value is supplied dynamically console.log(favorites[userInputtedTopic]); //'cake' Additionally, Object values can also be accessed via dot notation, as if the properties were public attributes of a class instance. This is often simpler to write and to read: remember to read the . as an 's! let favorites = {music: 'jazz', food: 'pizza', numbers: [12, 42]}; //access variable console.log( favorites.music ); //'jazz' //assign variable favorites.food = 'cake'; console.log( favorites.food ); //'cake' //access undefined key console.log( favorites.language ); //undefined favorites.language = 'javascript'; //assign new key and value //access nested values console.log( favorites.numbers[0] ); //12 The only advantage to using bracket notation is that you can specify property names as variables or the results of an expression. But overall, the recommendation is to use dot notation unless the property you wish to access is dynamically determined. It is possible to get an array of an object’s keys calling the Object.keys() method and passing in the object you wish to get the keys of. Note that an equivalent function for values is not supported by most browsers; a better approach is to iterate through the keys to identify all the values. let ages = {sarah:42, amit:35, zhang:13}; let keys = Object.keys(ages); // [ 'sarah', 'amit', 'zhang' ] Arrays of Objects As noted above, both arrays and objects can have values of any type—including other arrays or objects! The ability to nest objects inside of objects is incredibly powerful, and allows us to define arbitrarily complex information structurings (schemas). Indeed, most data in computer programs—as well as public information available on the web—is structured as a set of nested maps like this (though possibly with some level of abstraction). One of the most common forms of nesting you’ll see is to have an array of objects where each object has the same properties (but different values). For example: //an arbitrary list of people's names, heights, and weights let people = [ {name: 'Ada', height: 58, 'weight': 115}, {name: 'Bob', height: 59, 'weight': 117}, {name: 'Chris', height: 60, 'weight': 120}, {name: 'Diya', height: 61, 'weight': 123}, {name: 'Emma', height: 62, 'weight': 126} ] This structure can be seen as a list of records (the objects), each of which have a number of different features (the key-value pairs). This list of feature records is in fact a common way of understanding a data table like you would create as an Excel spreadsheet: A data table. Each object (record) acts as a “row” in the table, and each property (feature) acts as a “column”. As long as all of the objects share the same keys, this array of objects is a table! Type Coercion As mentioned above, variables in JavaScript are dynamically typed, and thus have a data type of the value currently assigned to that variable. JavaScript variables are able to “change type” by having a different type of data assignment to them: let myVariable = 'hello'; //value is a String myVariable = 42; //value is now a Number Unlike some other dynamically typed variables, JavaScript will not throw errors if you try to apply operators (such as + or &lt;) to different types. Instead, the interpreter will try to be “helpful” and coerce (convert) a value from one data type into another. While this process is similar to how Java will automatically cast data types into Strings (e.g., \"hello\"+4), JavaScript’s type coercion can produce a few quirks: let x = '40' + 2; console.log(x); //=> '402'; the 2 is coerced to a String let y = '40' - 4; console.log(y); //=> 36; can't subtract strings so '40' is coerced to a Number! JavaScript will also attempt to coerce values when checking for equality with ==: let num = 10 let str = '10' console.log(num == str) //true, the values can be coerced into one another In this case, the interpreter will coerce the Number 10 into the String '10' (since numbers can always be made into Strings), and since those Strings are the same, determines that the variables are equal. In general this type of automatic coercion can lead to subtle bugs. Thus you should instead always use the === operator (and it’s partner !==), which checks both value and type for equality: let num = 10 let str = '10' console.log(num === str) //false, the values have different types JavaScript will do its best to coerce any value when compared. Often this means converting values to Strings, but it will also commonly convert values into booleans to compare them. So for example: //compare an empty String to the number 0 console.log( '' == 0 ); //true; both can be coerced to a `false` value This is because both the empty string '' and 0 are considered “falsey” values (values that can be coerced to false). Other falsy values include undefined, null, and NaN (not a number). All other values will be coerced to true. For more examples of the horror of JavaScript coercion, see this video (about 1:20 in). 10.5 Control Structures JavaScript control structures have a similar syntax to those in Java or C. For example, a JavaScript if statement is written as: if(condition){ //statements } else if(alternativeCondition) { //statements } else { //statements } The condition can be any expression that evaluates to a Boolean value. But since any value can be coerced into Booleans, you can put any value you want inside the if condition. This is actually really useful—since undefined is a falsy value, you can use this coercion to check if a variable has been assigned or not: //check if a `person` variable has a `name` property if(person.name){ console.log('Person does have a name!'); } In the above example, the condition will only coerce to true if person.name is defined (not undefined) and is not empty. If somehow the variable has not been assigned (e.g., the user didn’t fill out the form completely), then the condition will not be true. While using person.name !== undefined is an equivalent expression, it is more idiomatic to utilize the coercion and have plain variable as the conditional expression. Additionally, JavaScript provides a ternary conditional operator that lets you write a simple if statement as a single expression: let x; //declare variable if(condition) { x = 'foo'; } else { x = 'bar'; } //can be condensed into: let x = condition ? 'foo' : 'bar'; This expression is read as “if condition then resolve to 'foo' else resolve to bar”. Each part (the condition, the “if true” result, and the “if false” result) can be any expression, though you should keep them simple to avoid confusion. JavaScript also supports while loop (for indefinite iteration) and for loops (for definite iteration) similar to Java. The only difference is that because JavaScript variables are dynamically typed, the loop control variables are not declared with a type: //an example for loop. The `i` is not declared as an int for(let i=0; i&lt;array.length; i++){ console.log(array[i]); } JavaScript does have a for ... in syntax. However, it doesn’t work as you would expect for arrays (it iterates over “enumerable properties” rather than the specific indices), and so should not be used with arrays. ES6 also introduces a for ... of syntax for iterating over arrays, but this is not supported by all browsers and so is not recommended. Instead, the current best practice is to use the above for loop, or better yet the forEach() method described in the next chapter. If you need to iterate over the keys of an object, use the Object.keys() method to get an array to loop through! 10.6 Functions And of course, JavaScript includes functions (named sequences of statements used to abstract code). JavaScript functions are written using the following syntax: //A function named `makeFullName` that takes two arguments //and returns the \"full name\" made from them function makeFullName(firstName, lastName) { //Function body: perform tasks in here let fullName = firsName + \" \" + lastName; // Return: what you want the function to output return fullName; } // Call the makeFullName function with the values \"Alice\" and \"Kim\" // Assign the result to `myName` let myName = makeFullName(\"Alice\", \"Kim\") // \"Alice Kim\" Functions are defined by using the function keyword (placed before the name of the function) instead of Java’s public static, don’t declare a return type (since the language is dynamically typed), and don’t indicate types for the parameters. Otherwise, JavaScript functions have identical syntax to Java functions. If a function lacks a return value, then that function returns the value undefined. As in other languages, function arguments in JavaScript are implicitly declared local variables. However, in JavaScript all arguments are optional. Any argument that is not passed a specific value will be undefined. Any passed in value that does not have a variable declared for its position will not be assigned to a variable. function sayHello(name) { return \"Hello, \"+name; } //expected: argument is assigned a value sayHello(\"Joel\"); //\"Hello, Joel\" //argument not assigned a value (left undefined) sayHello(); //\"Hello, undefined\" //extra arguments (values) are not assigned to variables, so are ignored sayHello(\"Joel\", \"y'all\"); //\"Hello, Joel\" If a function has an argument, that doesn’t mean it got a value. If a function lacks an argument, that doesn’t mean it wasn’t given a value! In addition to this basic structure, JavaScript functions are frequently used for functional programming, as described in the next chapter. Resources As the language used for web programming, JavaScript may have more freely available online learning resources than any other language! Some of my favorites include: A Re-Introduction to JavaScript a focused tutorial on the primary language features You Don’t Know JS a free textbook covering all aspects of the JavaScript language. Very readable and thorough, with lots of good examples. JavaScript for Cats a gentler introduction for “Scaredy-Cats” MDN JavaScript Reference a complete documentation of JavaScript, including tutorials w3Schools JavaScript Reference a slightly more friendly reference for the language Google’s JavaScript Style Guide "],["functional-programming.html", "Chapter 11 Functional Programming in JS 11.1 Functions ARE Variables 11.2 Object Functions 11.3 Callback Functions 11.4 Functional Looping 11.5 Pure Functions Resources", " Chapter 11 Functional Programming in JS Despite it’s name, the JavaScript language was based more on Scheme than it was on Java. Scheme is a functional programming language, which means it follows a programming paradigm centered on functions rather than on variables, objects, and statements as you’ve done before (known as imperative programming). An alternative to object-oriented programming, functional programming provides a framework for thinking about how to give instructions to a computer. While JavaScript is not a fully functional language, it does support a number of functional programming features that are vital to developing effective and interactive systems. This chapter introduces these functional concepts. 11.1 Functions ARE Variables Normally you’ve considered functions as “named sequences of instructions”, or groupings of lines of code that are given a name. But in a functional programming paradigm, functions are first-class citizens—that is, they are “things” (values) that can be organized and manipulated just like variables. In JavaScript, functions ARE variables: //create a function called `sayHello` function sayHello(name) { console.log(\"Hello, \"+name); } //what kind of thing is `sayHello` ? console.log(typeof sayHello); //=> 'function' Just like let x = 3 defines a variable for a value of type number, or let msg = \"hello\" defines a variable for a value of type string, the above sayHello function is actually a variable for a value of type function! Important: we refer to a function by it’s name without the parentheses! The fact that functions are variables is the core realization to make when programming in a functional style. You need to be able to think about functions as things (nouns), rather than as behaviors (verbs). If you imagine that functions are “recipes”, then you need to think about them as pages from the cookbook (that can be bound together or handed to a friend), rather than just the sequence of actions that they tell you to perform. And because functions are just another type of variable, they can be used anywhere that a “regular” variable can be used. For example, functions are values, so they can be assigned to other variables! //create a function called `sayHello` function sayHello(name) { console.log(\"Hello, \"+name); } //assign the `sayHello` value to a new variable `greet` let greet = sayHello; //call the function assigned to the `greet` variable greet(\"world\"); //logs \"Hello world\" It helps to think of functions as just a special kind of array. Just as arrays have a special syntax [] (bracket notation) that can be used to “get” a value from the list, functions have a special syntax () (parentheses) that can be used to “run” the function. Anonymous Functions Functions are values, just like arrays and objects. And just as arrays and objects can be written as literals which can be anonymously passed into functions, JavaScript supports anonymous functions: var array = [1,2,3]; //named variable (not anonymous) console.log(array); //pass in named var console.log( [4,5,6] ); //pass in anonymous value //named function (normal) function sayHello(person){ console.log(\"Hello, \"+person); } //an anonymous function (with no name!) //(We can't reference this without a name, so writing an anonymous function is //not a valid statement) function(person) { console.log(\"Hello, \"+person); } //anonymous function (value) assigned to variable //equivalent to the version in the previous example let sayHello = function(person) { console.log(\"Hello, \"+person); } You can think of this structure as equivalent to declaring and assigning an array let myVar = [1,2,3]… just in this case instead of taking the anonymous array (right-hand side) and giving it a name, we’re taking an anonymous function and giving it a name! Thus you can define named functions in one of to ways: either by making an explicitly named function or by assigning an anonymous function to a variable: //these produce the same function function foo(bar) {} let foo = function(bar) {} The only difference between these two constructions is one of ordering. When the JavaScript interpreter is initially reading and parsing the script file, it will put variable and function declarations into memory before it executes any of the file. In effect, JavaScript will seem to “move” variable and function declarations to the top of the file! This process is called hoisting (declarations are “hoisted” to the top of the script). Hoisting only works for named function declarations: assigning an anonymous function to a variable will not hoist that function’s definition: In practice, you should always declare and define functions before you use them (put them all at the top of the file!), which will reduce the impact of hoisting and allow you to use either construction. 11.2 Object Functions Moreover, functions are values, so they can be assigned as values of object properties (since object properties are like name-spaced variables): //an object representing a dog let dog = { name: 'Sparky' breed: 'mutt' } //assign an anonymous function to the `bark` property dog.bark = function(){ console.log('woof!'); } //call the function dog.bark(); //logs \"woof!\" Again, this is just like how you can assign an array as an object’s property. With an array value you would use bracket notation to use it’s “special power”; with a function value you use parentheses! This is how we can create an equivalent of “member functions” (or methods) for individual objects: the dog object now has a function bark()! Similar to Java, you can refer to the object on which a function is called using the keyword this. Note that the manner in which the this variable is assigned can lead to some subtle errors when using callback functions (below). For more details, see the chapter on ES6 features. As a brief example: // An object representing a Dog let fido = { name: \"Fido\", bark: function() { console.log(this.name, \"woofs\")} } // An object representing another Dog let spot = { name: \"Spot\", bark: function() { console.log(this.name, \"yips\")} } console.log('***This is Fido barking:***'); fido.bark(); //=> \"Fido woofs\". Note, `this` will refer to the `fido` object. console.log('***This is Spot barking***'); spot.bark(); //=> \"Spot yips\". Note, `this` will refer to the `spot` object. 11.3 Callback Functions Finally, functions are values, so they can be passed as parameters to other functions! //create a function `sayHello` function sayHello(name){ console.log(\"Hello, \"+name); } //a function that takes ANOTHER FUNCTION as an argument //this function will call the argument function, passing it \"world\" function doWithWorld(funcToCall){ //call the given function with an argument of \"world\" funcToCall(\"world\"); } doWithWorld(sayHello); //logs \"Hello world\"; In this case, the doWithWorld function will execute whatever function it is given, passing in a value of \"world\". Important note: when we pass sayHello as an argument, we don’t put any parentheses after it! Putting the parentheses after the function name executes the function, causing it to perform the lines of code it defines. This will cause the expression containing the function to resolve to its returned value, rather than being the function value itself. It’s like passing in the baked cake rather than the recipe page. function greet() { //version with no args for clarity return \"Hello\"; } //log out the function value itself console.log(greet); //logs e.g., [Function: greet], the function console.log(greet()); //logs \"Hello\", which is what `sayHello()` resolves to A function that is passed into another is commonly referred to as a callback function: it is an argument that the other function will “call back to” and execute when needed. function doLater(callback) { console.log(\"I'm waiting a bit...\"); console.log(\"Okay, time to work!\"); callback(); //\"call back\" and execute that function } function doHomework() { // ... }; doLater(doHomework); Functions can take more than one callback function as arguments, which can be a useful way of composing behaviors. function doTogether(firstCallback, secondCallback){ firstCallback(); //execute the first function secondCallback(); //execute the second function console.log('at the same time!'); } function patHead() { console.log('pat your head'); } function rubBelly() { console.log('rub your belly'); } //pass in the callbacks to do them together doTogether(patHead, rubBelly); This idea of passing functions are arguments to other functions is at the heart of functional programming, and is what gives it expressive power: we can define program behavior primarily in terms of the behaviors that are run, and less in terms of the data variables used. Moreover, callback functions are vital for supporting interactivity: many built-in JavaScript functions take in a callback function that specifies what should occur at some specific time (e.g., when the user clicks a button). Often a callback function will be defined just to be passed into a single other function. This makes naming the callback somewhat redundant, and so it is more common to utilize anonymous callback functions: //name anonymous function by assigning to variable let sayHello = function(name){ console.log(\"Hello, \"+name); } function doWithWorld(funcToCall){ funcToCall(\"world\"); } //pass the named function by name doWithWorld(sayHello); //pass in anonymous version of the function doWithWorld(function(name){ console.log(\"Hello, \"+name); }); In a way, we’ve just “copy-and-pasted” the anonymous value (which happens to be a function) into the doWithWorld() call—just as you would do with any other anonymous variable type. Look carefully at the location of the closing brace } and parenthesis ) on the last line. The brace ends the definition of the anonymous function value (the first and only parameter to doWithWorld), and the parenthesis ends the parameter list of the doWithWorld function. You need to include both for the syntax to be valid! And since anonymous functions can be defined within other anonymous functions, it is not unusual to have lots of }) lines in your code. Closures Functions are values, so not only can then be passed as parameters to other functions, they can also be returned as results of other functions! //This function produces ANOTHER FUNCTION //which greets a person with a given greeting function makeGreeterFunc(greeting){ //explicitly store the param as a local variable (for clarity) let localGreeting = greeting; //A new function that uses the `greeting` param //this is just a value! let aGreeterFunc = function(name){ console.log(localGreeting+\" \"+name); } return aGreeterFunc; //return the value (which happens to be a function) } //Use the \"maker\" to create two new functions let sayHello = makeGreeterFunc('Hello'); //says 'Hello' to a name let sayHowdy = makeGreeterFunc('Howdy'); //says 'Howdy' to a name //call the functions that were made sayHello('world'); //\"Hello world\" sayHello('Dave'); //\"Hello Dave\" sayHowdy('world'); //\"Howdy wold\" sayHowdy('partner'); //\"Howdy partner\" In this example, we’ve defined a function makeGreeterFunc that takes in some information (a greeting) as a parameter. It uses that information to create a new function aGreeterFunc—this function will have different behavior depending on the parameter (e.g., it can say “Hello” or “Howdy” or any other greeting given). We then return this new aGreeterFunc so that it can be used later (outside of the “maker” function). When we then call the makeGreeterFunc(), the result (a function) is assigned to a variable (e.g., sayHello). And because that result is a function, we can call it with a parameter! Thus makeGreeterFunc acts a bit like a “factory” for making other functions, which can then be used where needed. The most significant part of this example is the scoping of the greeting variable (and its localGreeting alias). Normally, you would think about localGreeting as being scoped to makeGreeterFunc—once the maker function is finished, then the localGreeting variable should be lost. However, the greeting variable was in scope when the aGreeterFunc was created, and thus remains in scope (available) for that aGreeteFunc even after the maker function has returned! This structure in which a function “remembers” its context (the in-scope variables around it) is called a closure. Even though the localGreeting variable was scoped outside of the aGreeterFunc, it has been enclosed by that function so it continues to be available later. Closures are one of the most powerful yet confusing techniques in JavaScript, and are a highly effective way of saving data in variables (instead of relying on global variables or other poor programming styles). They will also be useful when dealing with some problems introduced by Asynchronous Programming 11.4 Functional Looping Another way that functional programming and callback functions specifically are utilized is to replace loops with function calls. For a number of common looping patterns, this can make the code more expressive—more clearly indicative of what it is doing and thus easier to understand. Functional looping was introduced in ES5. To understand functional looping, first consider the common for loop used to iterate through an array of objects: let array = [{...}, {...}, {...}]; for(let i=0; i&lt;array.length; i++){ let currentItem = array[i]; //convenience variable for current item //do something with current item console.log(currentItem); } While this loop may be familiar and fast, it does require extra work to manage the loop control variable (the i), which can get especially confusing when dealing with nested loops (and nested data structures are very common in JavaScript!) As an alternative, you can consider using the Array type’s forEach() method: let array = [{...}, {...}, {...}]; //function for what to do with each item function printItem(currentItem){ console.log(currentItem;) } //print out each item array.forEach(printItem); The forEach() method goes through each item in the array and executes the given callback function, passing that item as a parameter to the callback. In effect, it lets you specify “what to do with each element” in the array as a separate function, and then “apply” that function to each elements. forEach() is a built-in method for Arrays—similar to push() or indexOf(). For reference, the “implementation” of the forEach() function looks something like: Array.forEach = function(callback) { //define the Array's forEach method for(let i=0; i&lt;this.length; i++) { callback(this[i], i, this); } } In effect, the method does the job of managing the loop and the loop control variable for you, allowing you to just focus on what you want to do for each item. The callback function give to the forEach() will be executed with up to three argument (in order): (1) the current item in the array, (2) the index of the item in the array, and (3) the array itself. This means that your callback can contain up to three arguments, but since all arguments are optional in JavaScript, it can also be used with fewer—you don’t need to include an argument for the index or array if you aren’t utilizing them! While it is possible to make a named callback function for forEach(), it is much more common to use an anonymous callback function: //print each item in the array array.forEach(function(item){ console.log(item); }) This code can almost be read as: “take the array and forEach thing execute the function on that item”. This is similar in usage to the enhanced for loop in Java. Map JavaScript provides a number of other functional loop methods. For example, consider the following “regular” loop: function square(n) { //a function that squares a number return n*n; } let numbers = [1,2,3,4,5]; //an initial array let squares = []; //the transformed array for(let i=0; i&lt;numbers.length; i++){ let transformed = square(numbers[i]); //call our square() function squares.push(transformed); //add transformed to the list } console.log(squares); // [1, 4, 9, 16, 25] This loop represents a mapping operation: it takes an original array (e.g., of numbers 1 to 5) and produces a new array with each of the original elements transformed in a certain way (e.g., squared). This is a common operation to apply: maybe you want to “transform” an array so that all the values are rounded or lowercase, or you want to map an array of words to an array of their lengths, or you want to map an array of values to an array of &lt;li&gt; HTML strings. It is possible to make all these changes using the above code pattern: create a new empty array, then loop through the original array and push the transformed values onto that new array. However, JavaScript also provides a built-in array method called map() that directly performs this kind of mapping operation on an array without needing to use a loop: function square(n) { //a function that squares a number return n*n; } let numbers = [1,2,3,4,5]; //an initial array //map the numbers using the `square` transforming function let squares = numbers.map(square); console.log(squares); // [1, 4, 9, 16, 25] The array’s map() function produces a new array with each of the elements transformed. The map() function takes as an argument a callback function that will do the transformation. The callback function should take as an argument the element to transform, and return a value (the transformed element). Callback functions for map() will be passed the same three arguments as the callback functions for forEach(): the element, the index, and the array. And again, the map() callback function (e.g., square() in the above example) is more commonly written as an anonymous callback function: let numbers = [1,2,3,4,5]; //an initial array let squares = numbers.map(function(item){ return item*item; }); Note: the major difference between the .forEach method and the .map method is that the .map method will return each element. If you need to create a new array, you should use .map. If you simply need to do something for each element in an array, use .forEach. Filter A second common operation is to filter a list of elements, removing elements that we don’t want (or more accurately: only keeping elements that we DO want). For example, consider the following loop: function isEven(n) { //a function that determines if a number is even let remainder = n % 2; //get remainder when dividing by 2 (modulo operator) return remainder == 0; //true if no remainder, false otherwise } let numbers = [2,7,1,8,3]; //an initial array let evens = []; //the filtered array for(let i=0; i&lt;numbers.length; i++){ if(isEven(numbers[i])){ evens.push(numbers[i]); } } console.log(evens); //[2, 8] With this filtering loop, we are keeping the values for which the isEven() function returns true (the function determines “what to let in” not “what to keep out”; a whitelist), which we do by appending the “good” values to a new array. Similar to map(), JavaScript arrays include a built-in method called filter() that will directly perform this filtering: function isEven(n) { //a function that determines if a number is even return (n % 2) == 0; //true if no remainder, false otherwise } let numbers = [2,7,1,8,3]; //an initial array let evens = numbers.filter(isEven); //the filtered array console.log(evens); //[2, 8] The array’s filter() function produces a new array that contains only the elements that do match a specific criteria. The filter() function takes as an argument a callback function that will make this decision. The callback function takes in the same arguments as forEach() and map(), and should return true if the given element should be included in the filtered array (or false if it should not). And again, we usually use anonymous callback functions for filter(): let numbers = [2,7,1,8,3]; //an initial array let evens = numbers.filter(function(n) { return (n%2)==0; }); //one-liner! (Since JavaScript ignores whitespace, we can compact simple callbacks onto a single line. ES6 and Beyond describes an even more compact syntax for such functions). Because map() and filter() are both called on and produce arrays, it is possible chain them together, calling subsequent methods on each returned value: let numbers = [1,2,3,4,5]; //an initial array //get the squares of EVEN numbers only let filtered = numbers.filter(isEven); let squares = filtered.map(square); console.log(squares); //[4, 16, 36] //or in one statement, using results anonymously let squares = numbers.filter(isEven) .map(square); console.log(squares); //[4, 16, 36] This structure can potentially make it easier to understand the code’s intent than using a set of nested loops or conditionals: we are taking numbers and then filtering for the evens and mapping to squares! Reduce The third important operation in functional programming (besides mapping and filtering) is reducing an array. Reducing an array means to aggregate that array’s values together, transforming the array elements into a single value. For example, summing an array is a reducing operation (and in fact, the most common one!): it reduces an array of numbers to a single summed value. You can think of reduce() as a generalization of the sum() function found in many other languages—but rather than just adding (+) the values together, reduce() allows you to specify what operation to perform when aggregating (e.g., multiplication). To understand how a reduce operation works, consider the following basic loop: function add(x, y) { //a function that adds two numbers return x+y; } let numbers = [1,2,3,4,5]; //an initial array let runningTotal = 0; //an accumulated aggregate for(let i=0; i&lt;numbers.length; i++){ runningTotal = add(runningTotal, numbers[i]); } console.log(runningTotal); //15 This loop reduces the array into an “accumulated” sum of all the numbers in the list. Inside the loop, the add() function is called and passed the “current total” and the “new value” to be combined into the aggregate (in that order). The resulting total is then reassigned as the “current total” for the next iteration. The built-in array method reduce() does exactly this work: it takes as an argument a callback function used to combine the current running total with the new value, and returns the aggregated total. Whereas the map() and filter() callback functions each usually took 1 argument (with 2 others optional), the reduce() callback function requires 2 arguments (with 2 others optional): the first will be the “running total” (called the accumulator), and the second will be the “new value” to mix into the aggregate. (While this ordering doesn’t influence the summation example, it is relevant for other operations): function add(x, y) { //a function that adds two numbers return x+y; } let numbers = [1,2,3,4,5]; //an initial array let sum = numbers.reduce(add); console.log(sum); //15 The reduce() function (not the callback, but reduce() itself) has a second optional argument after the callback function representing the initial starting value of the reduction. For example, if we wanted our summation function to start with 10 instead of 0, we’d use: //sum starting from 10 let sum = numbers.reduce(add, 10); Note that the syntax can be a little hard to parse if you use an anonymous callback function: //sum starting from 10 numbers.reduce(function(x, y){ return x+y; }, 10); //the starting value comes AFTER the callback! The accumulator value can be any type you want! For example, you can have the starting value be an empty object {} instead of a number, and have the accumulator use the current value to “update” that object (which is “accumulating” information). To summarize, the map(), filter(), and reduce() operations work as follows: Map, filter, reduce explained with emoji. Not valid JavaScript syntax. All together, the map, filter, and reduce operations form the basic platform for a functional consideration of a program. Indeed, these kinds of operations are very common when discussing data manipulations: for example, the famous MapReduce model involves “mapping” each element through a complex function (on a different computer no less!), and then “reducing” the results into a single answer. 11.5 Pure Functions This section was adapted from a tutorial by Dave Stearns. The concept of first-class functions (functions are values) is central to any functional programming language. However, there is more to the functional programming paradigm than just callback functions. In a fully functional programming language, you construct programs by combining small, reusable, pure functions that take in some inputted data, transform it, and then return that data for future use. Pure functions have the following qualities: They operate only on their inputs, and make no reference to other data (e.g., variables at a higher scope such as globals) They never modify their inputs—instead, they always return new data or a reference to an unmodified input They have no side effects outside of their outputs (e.g., they never modify variables at a higher scope) Because of these previous rules, they always return the same outputs for the same inputs A functional program sends its initial input state through a series of these pure functions, much like a plumbing system sends water through a series of pipes, filters, valves, splitters, heaters, coolers, and pumps. The output of the “final” function in this chain becomes the program’s output. Pure functions are almost always easier to test and reason about. Since they have no side-effects, you can simply test all possible classes of inputs and verify that you get the correct outputs. If all of your pure functions are well-tested, you can then combine them together to create highly-predictable and reliable programs. Functional programs can also be easier to read and reason about because they end up looking highly declarative: it reads as a series of data transformations (e.g., take the data, then filter it, then transform it, then sort it, then print it), with the output of each function becoming the input to the next. Although some functional programming zealots would argue that all programs should be written in a functional style, it’s better to think of functional programming as another tool in your toolbox that is appropriate for some jobs, and not so much for others. Object-oriented programming is often the better choice for long-running, highly-interactive client programs, while functional is a better choice for short-lived programs or systems that handle discrete transactions (like many web applications). It’s also possible to combine the two styles: for example, React components can be either object-oriented or functional, and you often use some functional techniques within object-oriented components. Indeed, the latest versions of Java—a highly object-oriented language—add support for functional programming! If you are interested in doing more serious functional programming in JavaScript, there are a large number of additional libraries that can help support that: Lodash (and it’s more pure variant lodash/fp) Ramda Lazy.js There are also many languages that were designed to be functional from the get-go, but can be compiled down into JavaScript to run on web browsers. These include Clojure (via ClojureScript) and Elm. Resources Functional Programming in JavaScript a fantastic interactive tutorial for learning functional programming in JS Higher Order Functions a chapter from the online textbook Eloquent JavaScript Scope &amp; Closures an online textbook with an extremely detailed explanation of scoping in JavaScript "],["dom.html", "Chapter 12 Document Object Model (DOM) 12.1 The DOM API 12.2 DOM Manipulation 12.3 Listening for Events Resources", " Chapter 12 Document Object Model (DOM) The primary purpose of using JavaScript in a web page is to make that page interactive: the JavaScript language is used to program logical decisions that will effect what is shown on the page. It does this primarily by changing the HTML rendered by the browser. For example, JavaScript can be used to change the text inside a &lt;p&gt;, add addition &lt;li&gt; elements to a list, or to give a &lt;div&gt; a new CSS class attribute. The programmatic representation of the HTML elements currently being shown by the browser is known as the Document Object Model (DOM). In web programming JavaScript code is used to modify the DOM (HTML elements currently being shown by the browser) in response to user input, thereby making the page interactive. This chapter introduces the Document Object Model and how to use JavaScript to manipulate it through user-driven interaction. 12.1 The DOM API As you should recall from Chapter 3, HTML elements can be nested, allowing us to consider a webpage as a “tree” of elements: An example DOM tree (a tree of HTML elements). A tree is a hierarchical data structure, where each element (called a node) contains references to child elements. Following the arboreal metaphor, the “start” of the tree is called the root note, hierarchical sequences of nodes are called branches, and a node that does not have any children is called a leaf. Considering a web page’s content to be a tree of HTML elements is one way to model (represent) the structure of that information. This particular model of a web document (as a tree of object nodes) is called the Document Object Model, or DOM for short. In many ways the DOM is the HTML (though the HTML rendered in the browser, not the .html source code you’ve written)! Thus we can refer to the web page’s content as “the DOM”, and an HTML element as a “DOM element”. Note that even “plain text” content (e.g., what is inside a &lt;p&gt; tag) are considered nodes in the DOM tree—they are “text content” nodes (instead of “element nodes”). Moreover, the DOM also provides an Application Programming Interface (API) which allows computer applications to programmatically (e.g., through JavaScript code) interact with it: accessing and manipulating the tree of elements. As you may recall from previous courses, an API is often a set of functions and variables that can be used give instructions to a program. The DOM API is no different: it is a group of functions you can call and variables (usually Object properties) you can adjust to change the rendered web content. You write code to call these functions in order to make a page interactive. Global Variables You can programmatically access the API in JavaScript by utilizing a set of global variables. Global variables are variables that are “globally” scoped: they are available anywhere in the program (not just within a particular function). An important programming style rule is to minimize the use of global variables. Try to avoid creating too many new globals yourself! Global variables in JavaScript are almost always Objects that have methods as their values. For example, the JavaScript language itself provides a global Math object that has includes a number of function properties (e.g., sqrt(), floor(), etc.). console.log( typeof Math ); //=> 'object' console.log( typeof Math.sqrt ); //=> 'function' console.log( Math.sqrt(25) ); //=> 5 In fact, the console object is another global variable provided by the JavaScript runtime (whether inside the browser or inside Node.js)! The web browser also provides a number of global variables that you can use. For example window is a global object that represents the browser itself. You can use this object to get information about the browser: /* example properties */ let width = window.innerWidth; //viewport width let height = window.innerHeight; //viewport height var url = window.location.href; //url for this page /* example functions */ window.alert(\"Boo!\"); //show a popup alert. Do not use this. window.scrollTo(0, 1000); //scroll to a position window.setTimeout(callback, 1000); //execute callback after an delay window.setInterval(callback, 1000); //execute callback repeatedly after interval While these examples are included for completeness, most window functions are rarely used and should be avoided. Popups with the window.alert() function are inelegant, interrupt the user’s actions, and produce a bad user experience—you should instead use in-window alerting options instead (such as showing a &lt;p class=\"alert\"&gt;). Browser control functions such as scrollTo() are non-standard and can vary drastically across systems and platforms. Proceed with caution when using window functions! 12.2 DOM Manipulation While window represents the Browser, the DOM itself is represented by the document global object—document is the DOM (the current HTML rendered in the browser). You access properties and call methods of this object in order to manipulate the content displayed in the browser! Referencing HTML Elements In order to manipulate the DOM elements in a page, you first need to get a reference to the element you want to change—that is, you need a variable that refers to that element. You can get these variable references by using one of the document “selector” functions: //element with id=\"foo\" let fooElem = document.getElementById('foo'); //elements with class=\"row\" let rowElems = document.getElementsByClassName('row'); //note the plural! //&lt;li> elements let liElems = document.getElementsByTagName('li'); //note the plural! /*easiest to select by reusing CSS selectors! */ let cssSelector = 'header p, .title > p'; //a string of a CSS selector //selects FIRST element that matches css selector let elem = document.querySelector(cssSelector); //matches ALL elements that match css selector let elems = document.querySelectorAll(cssSelector); The document.querySelector() is by far the most flexible and easy to use of these methods: it can easily do the same as all the other methods (just put in an id, class, or element selector). You should always use querySelector(). Note that the methods that return multiple nodes (e.g., querySelectorAll) return a NodeList object. While this is like an array (you can access elements via index through bracket notation and it has a .length property), it is not an array: meaning it doesn’t support methods like forEach() and map() across all browsers. If you need to iterate through a NodeList, you should use a regular for loop. But in practice, you’re much more likely to only work with single elements at a time. Modifying HTML Elements Once you have a reference to an element, you access properties and call methods on that object in order to modify its state in the DOM—which will in turn modify how it currently is displayed on the page. Thus by modifying these objects, you are dynamically changing the web page’s content! Important: setting these properties do not change the .html source code file! Instead, they just change the rendered DOM elements (think: the content stored in the computer’s memory rather than in a file). If you refresh the page, the content will go back to how the .html source code file specifies it should appear—unless that also loads the script that modifies the DOM. What is shown on the page is the HTML with the JavaScript modifications added in. Changing Content You can use JavaScript to access and modify the content of a DOM element (e.g., the stuff between the start and close tags): //get a reference to the FIRST &lt;p> element let elem = document.querySelector('p'); console.log(elem); //to demonstrate let text = elem.textContent; //the text content of the elem elem.textContent = \"This is different content!\"; //change the content let html = elem.innerHTML; //content including HTML elem.innerHTML = \"This is &lt;em>different&lt;/em> content!\"; //interpreted as HTML The textContent property of the element refers to all of the content, but considered as “plain text” this means that it is considered a “safe” property: you can assign strings that contain’s HTML code (e.g., &lt;em&gt;Hello&lt;/em&gt;), but that code will be escaped and not interpreted as HTML (instead the &lt; and &gt; will be written out as if you had used HTML entities). The .innerHTML property, on the other hand, is “not safe”: any HTML included in the String you assign to it will be converted into DOM elements. This makes it not a great property to use unless unless you are absolutely certain the content came from a trusted source. The innerHTML property should be used primarily for including inline elements such as &lt;em&gt; or &lt;strong&gt;. For more complex HTML content, it is cleaner code (separation of concerns!) to explicitly create new elements—see below for details. You can “clear” the content of an element by setting it’s content to be an empty string (''): let alertElem = document.querySelector('.alert'); alertElem.textContent = ''; //no more alert! Changing Attributes You can also change the attributes of individual elements. Each attribute defined in the HTML specification is typically exposed as a property of the element object: //get a reference to the `#picture` element let imgElem = document.querySelector('#picture'); //access the attribute console.log( imgElem.src ); //logs the source of the image //modify the attribute imgElem.src = 'my-picture.png'; You cannot access element.class or element.style attributes directly in this way; see below for specifics on changing the CSS of an element. You can alternatively modify element attributes by using the methods getAttribute() (passing it which attribute to access) and setAttribute() (passing it which attribute to modify and what value to assign to that attribute): let imgElem = document.querySelector('#picture'); imgElement.setAttribute('src', 'my-other-picture.png'); //set the src console.log( imgElem.getAttribute('src') ); //=> 'my-other-picture.png' //the `hasAttribute()` method returns a boolean. let isThick = document.querySelector('svg rect') .hasAttribute('stroke-width'); //chained anonymous variables These methods will let you interact with attributes that are not defined by the HTML spec, such as data- attribute. However, they don’t work with certain element attributes (such as the value attribute of an &lt;input&gt; element). Other elements may have their own special DOM properties: see the DOM Documentation for a list of HTML interfaces. Changing Element CSS It is possible to modify the CSS classes (and even inline styling) of an element. But rather than using the class property like with other attributes, you instead access the classList property. On modern browsers (IE 10 or later), this property supports methods .add() and .remove() for adding and removing classes from the list: //access list of classes let classList = elem.classList; //add a class elem.classList.add('small'); //add a single class elem.classList.add('alert','alert-warning'); //add multiples classes (not on IE) //remove a class elem.classList.remove('small'); //\"toggle\" (add if missing, remove if present) elem.classList.toggle('small'); While IE 10+ does support these methods, it doesn’t support multiple arguments for them (so you can’t add multiple classes in a single method call). If you need to support older browsers (including any version of IE), you can instead modify the .className property as if it were a String: //fallback for IE (all) var classes = elem.className; classes += ' '+ 'sweet sour'; //modify the string (append!) elem.className = classes; //reassign The classList methods work perfectly on Microsoft Edge. It is also possible to access and modify individual CSS properties of elements through the DOM element’s style property. .style references an Object whose keys are the CSS property names (but written in camelCase instead of kabob-case) let h1 = document.querySelector('h1'); h1.style.color = 'green'; h1.style.backgroundColor = 'black'; //not `.background-color` In general, you should modify element CSS by changing the class of the element, rather than specific style properties. Modifying the DOM Tree In addition to modifying the individual DOM elements, it is also possible to access and modify the DOM tree itself! That is, you can create new elements and add them to the tree (read: webpage), remove elements from the tree, or pluck them out of the tree and insert them somewhere else! First, note that each JavaScript DOM element has read-only properties referring to its parent, children, and sibling elements: &lt;main> &lt;section id=\"first-section\"> &lt;p>First paragraph&lt;/p> &lt;p>Second paragraph&lt;/p> &lt;/section> &lt;section id=\"second-section\">&lt;/section> &lt;main> //get reference to the first section let firstSection = document.querySelector('#first-section'); //get reference to the \"parent\" node let main = firstSection.parentElement; console.log(main); //&lt;main>...&lt;/main> //get reference to the child elements (2 paragraphs) let paragraphs = firstSection.children; console.log(paragraphs.length); //2 console.log(paragraphs[0]); //&lt;p>First paragraph&lt;/p> //get reference to the the next sibling let sectionSection = firstSection.nextElementSibling; console.log(secondSection); //&lt;section id=\"second-section\">&lt;/section> Note that these properties only deal with HTML elements—text content nodes are ignored. You can instead use equivalent properties parentNode and childNodes to also consider text content nodes. SVG content doesn’t support parentElement, but does support parentNode. You can also call methods to create and add new HTML DOM elements to the tree. The document.createElement() function is used to create a new HTML element. However this element is not created as a part of the tree (after all, you haven’t specified where it would put into the page)! Thus you need to also use a method such as appendChild to add that new element as a child of another element: //create a new &lt;p> (not yet in the tree) let newP = document.createElement('p'); newP.textContent = \"I'm new!\"; //create Node of textContent only (not an HTML element, just text) let newText = document.createTextNode(\"I'm blank\"); let main = document.querySelector('main'); main.appendChild(newP); //add element INSIDE (at end) main.appendChild(newText); //add the text inside, AFTER the &lt;p> //add anonymous new node BEFORE element. Parameters are: (new, old) main.insertBefore(document.createTextNode(\"First!\"), newP); //replace node. Parameters are: (new, old) main.replaceChild(document.createTextNode('boo'), newText); //remove node main.removeChild(main.querySelector('p')); The appendChild() method is considered a cleaner approach than just modifying the innerHTML property, as it allows you to adjust the DOM tree without erasing what was previously there. A common practice is to use document.createElement() to create a block element, then set the innerHTML of that element to its content (which can include inline elements), and then use appendChild to add the new block element to the tree at the desired location. Accessibility Whenever you learn a new technology, you should ask: how does this affect accessibility? With the JavaScript code modifying the rendered DOM, it is possible that the content of a page will change after it has been read by a screen reader. And while a sighted user will likely be able to see the change visually, a screen reader has no way of knowing that something on the page is different unless you tell it. You can let screen readers know that an element in a page may have its content change in the future by making that element into an ARIA Live Region. Live regions are “watched” by assistive technologies, and whenever the content changes they will speak the new content to the reader as if it were being read for the first time. You make an element into a live region by giving it the aria-live attribute: &lt;div aria-live=\"polite\"> This content can change! &lt;/div> The value assigned to the aria-live attribute is the “politeness level”, which specifies the priority by which the screen reader should read the change. The most common option (that you should almost always use) is \"polite\", which indicates that the changed text will be read only once the user has paused whatever is currently being read. A \"polite\" alert doesn’t interrupt the currently being read text or description, but instead will be injected when there is a break (if the current reading goes on for too long, then the new content will not be spoken). The other option is \"assertive\", which indicates that the new content should be spoken as soon as it changes, possibly interrupting other content. This should only be used for important information (like alerts, warnings, or errors), as it can interrupt the user’s flow in ways that are very disorienting. In short: always be polite! 12.3 Listening for Events In order to make a page interactive (that is, able to change in response to user actions), you need to be able to respond to user events. Whenever a user interacts with a computer, the operating system announces that interaction as an event—the event of a button being clicked, the event of the mouse being moved, the event of a keyboard key being pressed, etc. These events are broadcast to the entire system, allowing any application (including the browser) to “respond” the occurrence of the event, such as by executing a particular JavaScript function. Thus in order to respond to user actions (and the events those actions generate), we need to define a function that will be executed when the event occurs. You will define a function as normal, but the function will not get called by you as a particular step in your script. Instead, the function you specify will be executed by the system when an event occurs, which will be at some indeterminate time in the future. This process is known as event-driven programming. It is also an example of asynchronous programming: in which statements are not executed in a single order one after another (“synchronously”), but may occur “out of order” or even at the same time! (For more about working with asynchronous programming, see Chapter 14). In order for your script to respond to user events, you need to register an event listener. This is a bit like following someone on social media: you specify that you want to “listen” for updates from that person, as well as what you want to do when you “hear” some news from that person. Specifying that you want Slack to notify you when your name is mentioned is another good analogy! The DOM API allows you to register an event listener by call the .addEventListener() on a selected element (e.g., on the element that you want to listen to). This method takes two arguments: a string representing what kind of event you want to listen for, and a callback function to execute when you hear that event: //a (named) callback function function onClickCallback() { console.log(\"You clicked me!\"); } //get a reference to the element we want to \"listen\" to let button = document.querySelector('button'); //register a listener for 'click' events button.addEventListener('click', onClickCallback); When the button is clicked by the user, it will “shout” out a 'click' event (“I was clicked! I was clicked!”). Because you have set up a listener (an alert/notification) for such an occurrence, your script will be able to do something—and that something that it will do is run the specified callback function. It’s like you handed someone a recipe and told them “when I call you, bake this cake!” It is much more common to use an anonymous function as the callback: let button = document.querySelect.select('button'); button.addEventListener('click', function() { console.log(\"You clicked me!\"); }); Note that this listener only applies to that particular button—if you wanted to respond to a different button, you’d need to register a separate listener! Also, as the method name implies, it is possible to add multiple listeners (callbacks) to the same element for the same event: all of them will be executed “at once”. The event callback will be passed in a single argument: an object representing the “event” that occurred. (Since all parameters are optional in JavaScript, and it wasn’t used in the above example, it wasn’t included in the callback definition). This event includes information such as where the event occurred (in x,y coordinates), what DOM element caused the event, and more: elem.addEventListener('click', function(event) { //get who was clicked; let clickedElem = event.target; //target property of the event console.log(clickedElem); }); Also note that sometimes you want to stop the “normal” results of an event from occurring. For example, perhaps you don’t want a button to do it’s normal button thing (such as submitting a form), and instead want to provide your own custom behavior. To support this, you can “interrupt the event” by calling the following methods on the event: submitBtn.addEventListener('click', function(event) { event.preventDefault(); //don't do normal behavior event.stopPropagation(); //don't pass the event to parents //..do custom behavior here return false; //don't do normal behavior OR propagate! (for IE) }) Types of Events There are numerous different events that you can listen for, including: Mouse Events such as 'click'. The event.offsetX and event.offsetY will provide (x,y) coordinates for the clicks location relative to the target element; you can use clientX/Y for coordinates relative to the browser window, or pageX/Y for coordinates relative to the document (regardless of scrolling). See this post for details, and this page for an example. Other mouse events include 'dblclick' (double-click), 'mousedown' (mouse button is pressed down, may be held), 'hover' (mouse hover), 'mouseenter' (mouse moves over element), 'mousemove' (mouse moves over element), and 'mouseleave' (mouse moves of of element). Keyboard Events such as 'keydown'. The event.key property is used to determine which key was pressed, giving a predefined key value you can check: elem.addEventListener('keydown', function(event){ if(event.key === 'ArrowUp'){ console.log(\"Going up!\") } //... }); The event object also has properties to check if any “modifier keys” such as shift, control, or meta (Windows/command) are held when the event occurs. Note that you almost always want to respond to the 'keydown' and 'keyup' events; the 'keypressed' event is sent later and only applies to non-modifier keys. Window Events are event created by the window global, which we are also able to register event listeners on! For example, the 'resize' event can be used to identify when the window has changed size (e.g., if you want to make the content responsive as well as the CSS): window.addEventListener(\"resize\", function() { //... }); (See the documentation for advise on using this callback) Additionally, the window global defines a special event callback that occurs when the web page has finished loading. You can assign your own function to this callback to run code only after the webpage has loaded (e.g., for scripts specified in the &lt;head&gt;): window.onload = function() { //...do stuff once page is ready (e.g., run the rest of your code) } Style guideline: always register event listeners in the JavaScript—do not utilize the HTML attributes such as onclick. This is to help keep concerns separated: the HTML should not need to know anything about the JavaScript that is utilized (since the browser may not even support JavaScript!), but it’s okay for the JavaScript to rely on and modify the HTML. Event-Driven Programming In a typical web program event callback functions can occur repeatedly, over and over again (e.g., every time the user clicks a button). This makes them potentially act a bit like the body of a while loop. However, because these callbacks are functions, any variables defined within them are scoped to that function, and will not be available on subsequent executions. Thus if you want to keep track of some additional information (e.g., how many times the button was clicked), you will need to use a variable declared outside of the function (e.g., a global ). Such variables can be used to represent the state (situation) of the program, which can then be used to determine what behavior to perform when an event occurs, following the below pattern: //pseudocode WHEN an event occurs { check the STATE of the program; DECIDE what to do based on that state; UPDATE the state as necessary for the next event; } For example: let clickCount = 0; //keep track of the \"state\" (global) document.querySelector('button').addEventListener('click', function() { if(clickCount > 10) { //decide what to do console.log(\"I think you've had enough\"); } else { clickCount++; //change state (+1) console.log('You clicked me!'); } }); These “state” variables can be global, or can simply be declared within a containing function as a closure. State variables are often objects, with individual values stored as the properties. This provides a name-spacing feature, and helps to keep the code from being cluttered with many variables. Resources What is the DOM? (CSS-Tricks) Document Object Model reference (MDN) complete DOM reference JavaScript HTML DOM reference (w3c) Introduction to Events (MDN) "],["javascript-libraries.html", "Chapter 13 JavaScript Libraries 13.1 Including a Library 13.2 Example: jQuery Resources", " Chapter 13 JavaScript Libraries Many web programmers encounter the same programming requirements as they develop interactive web sites. For example, many websites will need to wrangle and manipulate objects and arrays, show standard components (such as modal windows or collapsible content), or do similar forms of complex DOM manipulation. Since one of the main principles of software development is reuse, developers will often make the code solving these problems available for others to use in the form of libraries and frameworks. These are publicly release script files that you can download and include in your project, allowing you to more quickly and easily develop complex applications. This is the amazing thing about the open-source community: people solve problems and then make those solutions available to others. Modern web applications make extensive use of external libraries, whether by integrating many different libraries into a single app, or by relying on a particular framework (which may itself be comprised of many different libraries)! This chapter describes how to include and utilize external JavaScript libraries in your web page, and presents the popular jQuery library as an example. For a sense of scale, the npm package manager’s directory lists almost half a million different JavaScript libraries! Note that external scripts are generally referred to as either libraries or frameworks. However, these terms are not entirely interchangeable. A library is a set of behaviors (functions) that you are able to utilize and call within your code. For example, Lodash (described below) is a library that provides utility functions you can use. You call a library’s code at your whim. A framework, on the other hand, provides a set of code into which you insert your own behaviors, either by subclassing provided components or by specifying your own callback functions. The framework calls your code at its whim. Martin Fowler refers to this as an “Inversion of control”. Frameworks often seem to be easier to use (they do more with less work on your part!), but can be hard to customize to achieve your exact goals. Libraries may be harder to use, but can likely be deployed exactly as needed. This chapter focuses mainly on libraries; React (detailed in later chapters) is more of a framework. 13.1 Including a Library Just like you can include multiple CSS files in a page with multiple &lt;link&gt; elements, you can include multiple JavaScript scripts with multiple &lt;script&gt; elements. &lt;script src=\"alpha.js\">&lt;/script> &lt;!-- run this script first --> &lt;script src=\"beta.js\">&lt;/script> &lt;!-- run this script second --> Importantly, script files are executed in the order in which they appear in the DOM. This matters because all scripts included via the &lt;script&gt; element are all run within the same namespace. This means variables and functions declared in one script file are also available in later scripts— it’s almost as if all the script files have been combined into a single file. /* alpha.js */ let message = \"Hello World\"; /* beta.js */ console.log(message); //=> \"Hello World\" //variable was defined in previous script! The order matters: if beta.js were included before alpha.js, then when it is run the message variable won’t have been defined yet, causing an error. Other techniques for managing and organizing large numbers of script files will be discussed in Chapter 15. Like CSS frameworks, JavaScript libraries are thus included in a page by providing a &lt;script&gt; tag that references the JavaScript file that contains that library’s code. For example, you can include the Lodash of helpful data processing functions: &lt;body> ...content &lt;!-- include JavaScript files --> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js\">&lt;/script> &lt;script src=\"js/my-script.js\">&lt;/script> &lt;/body> Like CSS frameworks, JavaScript libraries can be accessed by referencing the file on a CDN, by downloading the source code directly (check for the .js file; you may need to unpack a .zip file), or by installing the library via a package manager like npm. Refer to Chapter 3 for details—just change .css to .js! Like CSS, JavaScript files can be minimized (usually named as .min.js files). Minimizing JavaScript files not only removes whitespace, but also often replaces local variable names with shorter, meaningless ones such as a or x. You always want to load external libraries before your script, so that any variables and functions they define will be available to your code! If you put your script first, then those functions won’t be available yet! Because all JavaScript files share the same namespace, most popular libraries make all of their functions available as properties of a single global variable. For example, Lodash provides a global variable called _ (a single underscore—a “low dash”). You use this variable to call the provided functions: let array = [3,4,3]; let unique = _.uniq(array); //call function of lodash object console.log(unique); //[3,4], the unique elements! Once the library is loaded, the globals it provide can be accessed just like built-in globals window, document, Math, etc. Lodash uses an otherwise silly variable name so that it’s quick and easy to type, and to avoid conflicts with other variables you might create. Lodash provides lots of useful functions that can be called on the global _ object. For example: _.random() to generate a random number within a range _.range() to generate an array of numbers within a range _.includes() to determine if a value is in an array (cross-browser!) _.pick() to produce a new object that has only select properties of another _.merge() to combine the properties of two objects into a single new object Note that exactly what global object is provided (and what functions it has) is different for every different library. You need to look through the documentation (often the README.md file on Github) for instructions and examples on how to call and utilize that library. “Knowing” a library or framework is just about being familiar with what functions you can call from it! Pro-tip: Visual Studio Code will automatically download the type definitions for any library listed as a dependency in the project’s package.json. For example, if you include Lodash as a dependency (by installing it with npm install --save lodash), then just typing the _. will cause VS Code to provide autocomplete options. This makes it a good idea to install JavaScript libraries via npm, even if you plan on loading the library from a CDN instead of from a local file. If you’re using something a linter to check your coding style, you’ll need to let the linter know about any global variables loaded in other scripts so that the linter doesn’t think those variables are undefined. See the documentation for details about how to do this in ESLint. 13.2 Example: jQuery As an extended example of a JavaScript library, the remainder of this chapter describes jQuery—a popular JavaScript library that helps with DOM manipulation. jQuery was designed to provide easier, faster, and more reliable methods for manipulating the DOM in the ways described in the previous chapter. jQuery is one of the most popular libraries used in web development, and is used in around 70% of the most popular websites. jQuery was developed to help fill in gaps in the JavaScript language and to standardize functionality across browsers. It made it so that you could write manipulate the DOM while writing 10% of the code, and produce scripts that would run on both Firefox and Internet Explorer! However, in the 10+ years since it’s release, later versions of the JavaScript language and the DOM API have improved (e.g., by introducing a querySelector() function) so that much of what made jQuery special is now standard and widely supported. Indeed, jQuery’ approach to interactive webpages is now common practice. Nevertheless, jQuery is still commonly used in web systems (Bootstrap’s JavaScript components utilize jQuery), and is popular enough that it you should be familiar with it in the likely chance that you need to engage with a web system build more than 3 years ago. As with other libraries, you include jQuery by referencing it from a &lt;script&gt; tag in your HTML (before your own script!): &lt;script src=\"http://code.jquery.com/jquery-3.2.1.min.js\">&lt;/script> Note that version jQuery 3.x is for current browsers. If you need to support an older version (e.g., IE 6-8), you can use version 1.12. Yes, jQuery supports IE 6! Loading the jQuery library creates a jQuery variable in the global scope, meaning you can access this variable and utilize it in your script. The jQuery variable is actually a function that you can call, called the Selector function. This function is used to select DOM elements by CSS selector, similar to how document.querySelector() works: //selects element with id=\"foo\" (e.g., &lt;p id=\"foo\">) let fooElem = jQuery('#foo'); //selects all &lt;a> elements let allLinksArray = jQuery('a'); However, it is much more common to use a provided alias for the jQuery() function called $(). This “shortcut” lets you select elements with a single character (instead of 6)! //selects element with id=\"foo\" (e.g., &lt;p id=\"foo\">) let fooElem = $('#foo'); //selects all &lt;a> elements let allLinksArray = $('a'); Similar to Lodash’s _, jQuery uses $ because no one in their right might would name a variable that, so the chance of having a namespace conflict is minimal. Like document.querySelector(), the jQuery selector function handles most all selectors you are familiar with from CSS, as well as some additional useful pseudo-classes: $('#my-div') // by id $('div') // by type $('.my-class') // by class $('header, footer') // group selector $('nav a') // descendant selector $('p.red') // scoped selector $('section:first') // first &lt;section> element // (not a css selector!) Maniputing the DOM Once you’ve selected some elements, jQuery provides methods that perform most of the manipulations you would do using DOM properties: var txt = $('#my-div').text(); //get the textContent $('#my-div').text('new info!'); //change the textContent $('#my-div').html('&lt;em>new html!&lt;/em>'); //change the HTML $('svg rect').attr('height'); //get attribute (of all selected) $('svg rect').attr('height',200); //set attribute (of all selected) $('svg rect').attr( {x:50, y:60} ); //set multiple attributes by passing in an object $('section').addClass('container'); //add class (to all selected) $('section').removeClass('old'); //remove class (from all selected) $('body').css('font-size','24px'); //set css property (of all selected) $('body').css( {'font-size':'24px', 'font-family':'Helvetica'} ); //set multiple properties via an object If you compare this to the equivalent operations using the DOM, you’ll notice that (a) jQuery is much more concise. jQuery is also more powerful: for example, you can set multiple attributes with a single call to .attr() by passing in an object containing the attributes you wish to set (the keys are the attribute names). This lets you easily change lots of attributes at once! Importantly, note that all of these methods apply the change to all elements selected by the jQuery selector function. You do not need to use a loop to apply changes to multiple elements; you can just select the elements you wish to modify and change them all at once. This does mean that you may need to be careful about your selector—only select the elements you actually wish to work with! jQuery also provides methods that allow you to manipulate the DOM tree (e.g., to add, move, or remove elements): //create an element (not yet in the DOM) let newP = $('&lt;p class=\"new\">This is a new element&lt;/p>'); //notice the tag! //add content to DOM $('main').append(newP); //add the element INSIDE &lt;main>, at end $('main').append('&lt;em>new&lt;/em>'); //can a create element on the fly! $('main').prepend('&lt;em>new&lt;/em>'); //add new &lt;em> element INSIDE &lt;main>, at beginning $('main').before('&lt;header>'); //insert new &lt;header> BEFORE &lt;main> (older sibling) //notice you can omit the closing tag if no content $('footer').insertAfter('main'); //insert selected (&lt;footer>) AFTER parameter (&lt;main>) //since the &lt;footer> was selected, it will move! $('main').wrap('&lt;div class=\"container\">&lt;/div>'); //surround the &lt;main> with a .container $('footer').remove(); //remove selected &lt;footer> element $('main').empty(); //remove all child elements of &lt;main> The first important thing to note is that you create new elements by provided the HTML content (including the tag &lt;&gt;) to the $() function. This is distinct from document.createElement(), which explicitly does not include the &lt;&gt; angle brackets. If creating an element with no content, you can even just specify the start tag! jQuery also provides much more powerful manipulation methods, allowing you to easily position elements inside, outside, around, and in place of other elements. Although jQuery will allow you to create arbitrarily complex HTML elements to add to the DOM, you should avoid writing large chunks of HTML inside your .js file to append via jQuery (e.g., don’t add an entire DOM tree at once!). This violates the separation of concerns, and makes your code difficult to read, interpret, and modify (because your HTML is now in two places!). If you do need to dynamically insert large amounts of “hard-coded” HTML, you should instead write that content inside the .html file, make it invisible (e.g., display:none), and then use jQuery to move and show the element when needed. Handling Events jQuery also provides convenience methods for registering event listeners: $('#button').click(function(event) { console.log('clicky clicky!'); //who was clicked let element = $(event.target); }); There are equivalent methods for other events: .mousedown() .keypress(), etc. If you want to listen for an event that jQuery doesn’t provide a convenience method for, you can use the .on() function: $('#search-input').on('input', callback); By using a method such as .click(callback) rather than .addEventListener('click', callback) or event .on('click', callback), you avoid potential hard-to-catch bugs that may get introduced from misspelling 'click'—rather than having the browser listen for 'clik' events and then never seeming to respond to your actions, it will instead report an error (.clik() is not a known function!) The event parameter passed into the .click() function’s callback is exactly like the event passed to callbacks of addEventListener() (though jQuery standardizes cross-browser quirks)—thus you can access the source of the event with the event.target property. However, this property refers to a DOM element, not a jQuery selector. DOM elements don’t support the jQuery methods described above—those are only available to “jQuery selection objects”. Thus if you want to work with a DOM element, you need to “select” it again using the $() function, thus providing a jQuery selection that has all the useful jQuery methods. Additionally, jQuery assigns the this variable inside an event callback to the event’s target; this you can equivalently use $(this) to select the element. The previous chapter noted the window.onload even listener, which was used to determine when the DOM had finished loading and so was ready to be manipulated. jQuery provides a similar functionality via the .ready() listener (usually called on the whole document): $(document).ready(function() { //this need not be an anonymous function //program goes here console.log('Hello world!'); //... }); This is a very common pattern: often with jQuery entire programs will be specified inside the .ready() callback, so that the &lt;script&gt; tags can be placed in the &lt;head&gt; and downloaded quickly but still run only when the DOM is available. This pattern is so common in fact, that the jQuery selector function can serve as a shortcut to it: //equivalent to the above $(function() { //program goes here console.log('Hello world!'); //... }); If you pass a function rather than a Selector string to the $() jQuery function, it will be interpreted as specifying a callback function to run when the document is ready! This is something to be aware of if you look at someone else’s code and see it just start with a random $(function). And more! This is only the tip of the iceberg for what jQuery can do. For example, jQuery also provides a number of utility functions that can be called on the jQuery (or $) global: //check if an item is in an array $.inArray(4, [3,4,3] ); jQuery.inArray(4, [3,4,3] ); //equivalent, but maybe easier to read //find an item in an array that matches the filter function //this is like .filter, but works on old browsers (if right jQuery version) $.grep( [3,4,3], function(item) { return item > 3; }); //iterate over arrays or objects -- works for either! $.each( [3,4,3], function(key, value) { console.log('Give me a '+value); }); $.each( {first:'Joel',last:'Ross'}, function(key, value) { console.log(key+' name: '+value); }); This can be useful, though JavaScript native functions or Lodash methods will often be easier and (computationally) faster. But as a final fun example: jQuery also provides functions that allow you to easily produce animated effects! $('#id').fadeIn(1000); //fade in over 1 second $('#id').fadeOut(500); //fade out over 1/2 sec $('#id').slideDown(200); //slide down over 200ms $('#id').slideUp(500); //slide up over 500ms $('#id').toggle(); //toggle whether displayed //custom animation syntax: //$(selector).animate({targetProperties}, speed [, doneCallback]); $(\"#box\").animate({ left: '500px', //make the box fly around! opacity: '0.5', height: '200px', width: '200px' }, 1500); Resources Lodash Documentation jQuery Documentation jQuery Learning Center jQuery Tutorial (w3c) "],["es6.html", "Chapter 14 ES6+ Syntax 14.1 ES6+ Syntax Features 14.2 Modules 14.3 Classes", " Chapter 14 ES6+ Syntax As discussed in Chapter 10, the ECMAScript specification for the JavaScript language has gone through several different versions, each of which added new syntax and features to try and make the language more powerful, expressive, or easier to work with. After the JavaScript language was initially written in 1995 and then iterated on through the late 90s, it mostly stayed consistent (with some small changes) for about a decade—until 2009 with the release of JavaScript v5. The next major version wasn’t released until 2015—although officially called “ECMAScript 2015”, most developers refer to it by the working name “ES6” (e.g., version 6 of the language). ES6 introduced a host of notable and useful syntactic features—including let and const! Since then the language has been updated annually, with each version named after its release year (ES 2016 was released in 2016, ES 2017 released in 2017, etc). This chapter introduces some of the most notable and useful features introduced in ES6 and later versions of JavaScript—particularly those that will be needed when using the React framework (discussed in the following chapters). At this point ES6 is mature enough that it is almost entirely supported by modern browsers, with the notable exception of Internet Explorer. However, the JavaScript interpreter in older browsers (and IE) won’t be able to recognize the new syntax introduced in this version. Instead, you would need to covert that code into equivalent ES5 (or earlier) code, which can be understood. One way to do this is with the Babel compiler, which will “transpile” JavaScript code from one version to another. The next chapter discusses how to perform this kind of transpiling with React (spoiler: it is automatically performed by provided build tools), but it is also possible to install and use the Babel compiler yourself. 14.1 ES6+ Syntax Features Syntactic Sugar causes cancer of the semicolon - Alan Perlis Many of the ES6 features are syntactic shortcuts—they provide syntax for writing functions and operations in a more concise way. These features aren’t necessary for writing JavaScript, but they can make your code easier to write and to read (once you know the syntax), and are considered the “normal” way of writing modern JavaScript. This section discusses a few of the most common syntactic features. Arrow Functions As described in Chapter 11, JavaScript lets you define functions as anonymous values: const sayHello = function(name) { return 'Hello '+name; } As you have seen, the use of anonymous functions is incredibly common in JavaScript, particularly when used as anonymous callbacks. Because this is so common, ES6 introduced a simpler, more concise shortcut syntax for quickly specifying anonymous functions. Though officially called lambda functions, they are more commonly known as arrow functions, because of how they utilize an “arrow” symbol =&gt;: const sayHello = (name) => { return 'Hello '+name; } To turn an anonymous function into an arrow function, you just remove the function keyword from the definition, and place an arrow =&gt; between the parameter list and the block (indicating that the parameter list “goes to” the following block). This saves you a couple of characters when typing! It’s also possible to omit the () around the argument list in an arrow function: //may omit the parentheses around the argument -- but don't do this! const sayHello = name => { return 'Hello '+name; } //requried to include the parentheses if there are no arguments const printHello = () => { console.log('Hello world'); } However, I find this makes the syntax harder to read (when reading the the text, it looks like a variable declaration until you get to the =&gt;). So you should always include the parentheses () on the parameter list as it helps with readability, as well as making it easier to adjust the parameters later—thus meeting the requirements of good code style. Arrow functions can be particularly nice when doing anonyous callback functions (literals): const array = [1,2,3]; //an array to work with //function declaration syntax array.map(function(num) { return num * 2; //multiply each item by 2 }); //arrow function syntax array.map((num) => { return num * 2; //multiply each item by 2 }); Using an arrow function makes it slightly more obvious that the function is taking an input and then producing (=&gt;) an output—letting you focus on the method of interest (such as .map()) rather than the callback. However, it does make it less obvious that the argument to .map() is a function until you are used to identifying the =&gt; arrow. Arrow functions are lexically scoped, meaning that the value of the this keyword is retained even inside of the function. This can be important in some contexts (such as classes), and is one of the reasons to prefer arrow functions when defining callback functions). For very simple functions, arrow functions can be written to be even more compact: if the function body has only a single statement, you can leave the {} off the block, as well omit the return. This is called using a concise body format. The function will return the result of the of the single statement, which will either be an expression or undefined. For example: //function declaration syntax function makeFullName(first, last) { return first + \" \" + last; } //block body arrow function syntax const makeFullName = (first, last) => { return first + \" \" + last; } //concise body arrow function syntax const makeFullName = (first, last) => first + \" \" + last; Note that if the expression of a concise-body arrow function returns undefined (such as from a console.log) statement, then the arrow function will also return undefined. //concise body arrow function syntax const sayHello = (name) => console.log(\"Hello\" + name); //that is identical to use block body syntax. Yes, returning the result of //console.log() is odd const sayHello = (name) => { return console.log(\"Hello\" + name); } Using a concise body synatx could save you a few more characters (and even line breaks!). However, it can also make the function much more difficult to read—particularly when it has more than 1 argument—and harder to identify as a function because the block isn’t obvious. Concise body functions are also harder to modify—they can only have a single statement, so if you want to have the function to more than 1 thing—including using a loop or if statment—you would need to convert it into a block body anyway. (Trying to make that one expression really complex is also poor style). And because you can’t add additional lines, it makes it harder to debug since you can’t add console.log statements or otherwise take debugging steps. For this reason, you should almost never use concise-body arrow function syntax except on the very simplest of callbacks—it is always better to use block body syntax. Overall, arrow functions (specifically block body arrow functions) are clean syntactic shortcut that are the “normal” way of writing anonyous callback functions—you will see them all over examples and professionally written code. “Top-level” functions should be written using the regular function declaration syntax, but callback functions should always be written using block-body arrow functions. Destructuring ES6 also introduced destructing assignments, which allow you to assign each element of an array (or each property of an object) into separate variables all in a single operation. This is called “destructuring” because you are “unpacking” the values of an array into a bunch of different variables. To destructure an array in JavaScript, you write the variables you wish to assign values to inside of square brackets [] on the left-hand side of the assignment—almost like you are assigning to an array! const myArray = [1, 2, 3]; const [x, y, z] = myArray; //assign myArray elements to `x`, `y`, `z` respectively console.log(x); //=> 1; console.log(y); //=> 2; console.log(z); //=> 3; When destructuring an array, values are assigned in order—the value at index 0 goes to the first variable, the value at index 1 goes to the second variable, etc. It’s possible for the “list of variables” and the size of the destructured array to not match. If there are more values in the array than there are variables, then the extra values will not be assigned to variables (they will be ignored). there are more variables than values in the array, then the excess variables will be undefined (because the value from that position in the array is undefined). const bigArray = [1, 2, 3, 4, 5]; const [a, b] = bigArray; //only the first 2 elements will be assigned console.log(a); //=> 1; console.log(b); //=> 2; //other elements are not assigned const smallArray = [1, 2] const [x, y, z] = smallArray; console.log(x); //=> 1; console.log(y); //=> 2; console.log(z); //=> undefined; (because smallArray[2] is undefined!) It is also possible to destructure objects using a similar syntax, except that you put the variables you wish to assign to inside of {} on the left-hand side of the assignment—as if you were assigning to an object! const myObject = {a: 1, b: 2, c: 3}; const {a, b, c} = myObject; console.log(a); //=> 1; myObject.a console.log(b); //=> 2; myObject.b console.log(c); //=> 3; myObject.c Note that when destructuring an object, the variables specified on the left side of the assignment are assigned the value from the matching property in the object. Thus in const {a, b, c} = myObject, the a is assigned myObject.a, the b is assigned myObject.b, etc. The order of the elements on either side of the equation doesn’t matter, because object properties are unordered! const myObject = {a: 1, b: 2, c: 3}; const {c, b, a} = myObject; //\"order\" of variables doesn't matter console.log(a); //=> 1 console.log(b); //=> 2; console.log(c); //=> 3; There is also syntax to assign object properties to different variable names as well, (see the destructuring documentation for details). As with array destructuring, the list of variables and the number of object properties do not need to match. Any unmatched object properties will not be assign to variables, and any variables without matching object properties will not be assigned a value (will remain undefined). Destructuring is a useful syntactic shortcut for doing multiple assignments. In React it is often used to create local variables for easier coding than having to constantly write object.property: //a function that expects an object as an argument function getBMI(personObject) { const {height, weight} = personObject; //destructure to local variables //this avoids needing to refer to `personObject.height` return 703*weight/(height*height); //calculate and return value } const person = {name: 'Ada', height: 64, weight: 135} //an example person const adaBMI = getBMI(person); //pass in the object In fact, this behavior is so common that it also possible to destructure function parameters in the function declaration itself! To do this, you replace the object name in the parameter list with the set of destructured variables (what would go on the left-hand side of the destructuring assignment): //a function with the object argument destructured //notice the `{} in the argument list` function getBMI( {height, weight} ) { //implicitly calls `{height, weight} = personObject` return 703*weight/(height*height); //calculate and return value } const person = {name: 'Ada', height: 64, weight: 135} //an example person const adaBMI = getBMI(person); //pass in the object To be clear: in the second example, the getBMI() function still expects only 1 argument—that single argument is just destructured into two variables when the function is called. This syntax can save a line of code, but it also makes it easier to misread the function and think it takes more arguments than it does (if you miss the {} in the argument list). On the other hand, this syntax does make it clear exactly what properties the expected object will need to have—this function clearly defines its API that the “person object” will need to have a height and a weight (and not just e.g., a name or an age). As with any alternate syntax, there are trade-offs in terms of code style and readability. Nevertheless, this last syntax form is often used in React (where there are many functions that expect a single object, but you need to access their individual properties). Spreading Introduced in ES6 but expanded in ES 2018, the spread operator (an ellipsis ...) lets you reference “the elements of” an existing array or object when declaring a new value. It “expands” the contents of the array or object into the new value. You write it as a unary operator, putting the three dots in front of the value you wish to expand: const originalArray = ['a', 'b', 'c', 'd']; //new array contains \"the elements of\" `originalArray` const newArray = [...originalArray, 'e', 'f']; console.log(newArray) //['a', 'b', 'c', 'd', 'e', 'f'] In this example the newArray contains all the elements of the originalArray, as well as additional elements. Indeed it is particularly useful when you want to make a “copy” of an arrary or object, with or without additional values. //assigning an array to a different variable doesn't create a new array! const myArray = ['a', 'b', 'c', 'd']; const secondArray = myArray; //just a new label for the same value myArray[0] = 'Z'; //changing the original variable changes second variable as well console.log(secondArray[0]) //'Z' //use spread to create an actual copy that is a different array const clonedArray = [...myArray]; myArray[1] = 'Q'; //modify the original variable console.log(clonedArray[1]); //'b'; the clonedArray is different The spread operator can also be used in the creation of new objects; spreading the elements of an object spreads both the property keys and the values: const person = {name: 'Ada', height: 64, weight: 135} const copyOfPerson = {...person}; //clone the object console.log(copyOfPerson); // {name: 'Ada', height: 64, weight: 135} //all off the properties are \"spread\" into the new object const personWithHat = {hat: 'bowler', ...person} console.log(person); //has properties 'name', 'height', 'weight' console.log(personWithHat); //has properties 'hat', 'name', 'height', 'weight' When combined with destructuring, the spread operator can also refer to the “rest of” the elements in an array or objec that have not been assigned to specific variables. In this situation it is often referred to as a rest operator. const dimensions = [10, 20, 30, 40]; //extra values are \"spread\" into destructuring slots const [width, height, ...others] = dimensions console.log(width); //=> 10 console.log(height); //=> 20 console.log(others); //=> [30, 40]; the rest of the values! Finally, the spread operator can also be used to specify that a function can take an inconsistent number of arguments, and to gather all of these values into a single array. You do this by including the spreading operator in the function declaration. The arguments will then be gathered into that single variable—almost the opposite of destructuring! (And yes the fact that the “spread” operator is “gathering” values is confusing). //a function that logs out all of the arguments function printArgs(...argArray){ //all the arguments will be grouped into a single array `args` for(const arg of argArray) { console.log(arg); //can log out all of them, no matter how many! } } printArgs('a', 'b', 'c'); //=> \"a\" \"b\" \"c\" printArgs(1, 2, 3, 4, 5, 6); //=> \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" //a function that adds up all the arguments (no matter how many!) function sum(...numbers) { //numbers is an array, so we can `reduce()` it! const total = numbers.reduce((runningTotal, num) => { return runningTotal + num; //new total }, 0); //start at 0 return total; //or as one line with a concise arrow function (not pretty!) return numbers.reduce((total, n) => total+n); } sum(3 ,4, 3); // => 10 sum(10, 20, 30, 40); // => 100 The spread operator is not frequently used this way with React, but it’s handy to know about! Template Strings In ES6, you can declare Strings that contain embedded expressions, allowing you to “inject” an expression directly into a string (rather than needing to concatenate the String with that expression). These are known as template strings (or template literals). Template strings are written in back ticks (``) rather than quotes, with the injected expressions written inside of a ${} token: const name = 'world'; const greeting = `Hello, ${name}!`; //template string console.log(greeting); //=> \"Hello, world!\" Template strings can also include line breaks, allowing you to make multi-line strings! Note that you can put any expression inside the ${} token; however, it’s best practice to keep the expression as simple as possible (such as by using a local variable) to support readability: const name = 'world'; //greeting with capitalization. Don't do this! const greeting = `Hello, ${name.substr(0,1).toUpperCase() + name.substr(1)}!` console.log(greeting); //=> \"Hello, World!\"; //do this instead! const capitalizedName = name.substr(0,1).toUpperCase() + name.substr(1); const greeting = `Hello, ${capitalizedName}` console.log(greeting); //=> \"Hello, World!\"; One more example: //function expects a name, an animal, and a verb function makeExcuse(name, animal, verb) { const email = `Hello Professor ${name}, Please excuse my missing assignment, as my ${animal} ate it. ${verb} you later, A Student`; return email; } const excuse = makeExcuse('Ross', 'Lemur', 'Smell'); 14.2 Modules So far, you’ve mostly been writing all of your JavaScript code in a single script file (e.g., index.js), even if you have included some other libraries like Bootstrap or JQuery via additional &lt;script&gt; tags. But as applications get larger and more complex, this single script file can quickly become unwieldy with hundreds or thousands of lines of code implementing dozens of features. Such large files become difficult to read and debug (“where was that function defined?”), can introduce problems with the shared global namespace (“did I already declare a user variable?”), and overall mixes code in a way that violates the Separation of Concerns principle. The solution to this problem is to split up your application’s code into separate modules (scripts), each of which is responsible for a separate piece of functionality. And rather than loading each module through a separate &lt;script&gt; tag (potentially leading to ordering and dependency issues while continuing to pollute the global namespace), you can define each module as a self-contained script that explicitly “imports” (loads) the functions and variables it needs from other modules. This allows you to better organize your program as it gets large. While separating code into modules is a common in the Node.js environment, ES6 adds syntax that allows you to treat individual .js files as modules that can communicate with one another. These are known as ES6 Modules. A browser loads modules differently than “regular” scripts; to load some code as a module, you specify a type=\"module\" attribute in the &lt;script&gt; tag for that module: &lt;!-- load scripts that can import from other modules --> &lt;script type=\"module\" src=\"path/to/firstModule.js\">&lt;/script> &lt;script type=\"module\" src=\"path/to/secondModule.js\">&lt;/script> For security reasons, modules are not able to communicate when a web page is accessed via the file:// protocol. In order to use modules, you will need to access the page through a a web server, such as by using a development server like live-server. However, most commonly you will not use modules directly inside of the browser. Instead, modules will be loaded and compiled through an external build tool such as webpack. In these situations, you’ll be using the module loader provided by the Node JavaScript runtime. This loader does introduce a few quirks in syntax, which are noted in the syntax explanation. This section describes ES6 modules, which are used with web applications (being part of the ECMAScript specification). However, Node.js by default uses an alternate module loading system called CommonJS. This uses the built-in method require() to load a module (which returns a single “exported” variable as a result). Values are exported from a module by assigning them to the module.exports global. This course will exclusively utilize ES6 Modules—you should not use require()—but it’s good to be aware of the alternate CommonJS approach when searching for help. Module Syntax As in Java or Python, a JavaScript module is able to “load” external modules or libraries by using the import keyword: //Java example: import the `Random` variable from `java.util` module import java.util.Random; # Python example: import the `randint` variable from `random` module from random import randint //JavaScript: //import the `Random` variable from a `util.js` module import { Random } from './util.js'; //import the `randint` and `randrange` variables from a `random.js` module import { randint, randrange } from './random.js' This is most common version of the ES6 import syntax (called a named import): you write the keyword import, following by a set of braces { } containing a comma-separated sequence of variables you wish to “import” from a particular module. This is followed by the from keyword, followed by a string containing the relative path to the module script to import. Note that in Node-based systems (such as the React build environment) including the extension of the module script is optional (by default, the module loader will look for files ending in .js). Be sure to include the ./ to indicate that you’re loading a file from a particular directory. If you leave that off, the Node module loader will look for a module installed on the load path (e.g., in node_modules/). You do omit the ./ when you load third-party libraries such as jQuery or React: //with jquery installed in `node_modules/` //import the `$` and `jQuery` variables import { $, jQuery } from 'jquery'; //no `./` in front of library name Note that the variables imported from a modules can be of any type—strings, objects, and most commonly functions. Any variable that a module imports need to be declared as available in the module it is coming from—simlar to using the public keyword in Java. To do this, you export the variable (so that it can be “imported” elsewhere) by using the export keyword, placed in front of the variable declaration: /*** my-module.js ***/ //define and export variables for use elsewhere export const question = \"Why'd the chicken cross the road?\"; export const answer = \"To get to the other side\"; export function laugh() { //an exported function console.log(\"hahaha\"); } This is called a named export (in contrast to a default export described below). Once variables have been exported, they can be imported by another script file: /*** index.js ***/ //import all 3 variables from `my-modules.js` //now all 3 variables exist in this module and can be used import { question, answer, laugh } from './my-module.js'; console.log(question); //=> \"Why'd the chicken cross the road?\" console.log(answer); //=> \"To get to the other side\" laugh(); //\"hahaha\" Importantly, only the variables you export are made available to other modules! Anything that does not have that keyword will not be available—it will remain “private” to its own module. The best practice is to only export values that you are sure need to be imported and used by other modules. Above is the basic syntax for using named imports and exports. But there are other syntactical options that can be included when using import and export. For example, you can use the as keyword to “alias” a value either when it is exported (so it is shared with a different name) or when it is imported (so it is loaded and assigned a different name). This is particularly useful when trying to produce a clean API for a module (so you export values with consistent names, even if you don’t use those internally), or when you want to import a variable with a very long name. /*** my-module.js ***/ export function foo() { return 'foo'; } //standard named export //provide an \"alias\" (consumer name) for value when exporting export { bar as yourBar }; //will not be available (a \"private\" function) function baz() { return 'baz'; } /*** index.js ***/ //provide \"alias\" for value when importing! import {foo as myFoo} from './my-module.js'; myFoo(); //=> 'foo' foo(); //error, does not exist (aliased the variable as `myFoo`) import { yourBar } from './my-module.js'; //import value by exported name yourBar() //=> 'bar' import { bar } from './my-module.js'; //error, no value `bar` exported It is possible to import everything that was exported by a module using import * as syntax. You specify an object name that will represent the values exported module (e.g., theModule in the below example), and each exported variable will be a property of that object. This can be useful when you may be adding extra exports to a module during development, but don’t want to keep adjusting the import statement, but it does mean that the rest of the code may be harder to read since you need to unpack the properties from the object. /*** index.js ***/ import * as theModule from './my-module'; //import everything that was exported //loads as a single object with values //as properties theModule.foo(); //=> 'foo' theModule.yourBar(); //=> 'bar' theModule.baz(); //Error (private function so wasn't exported) Finally, each module can also export a single (just one!) default variable, which provides a slight shortcut when importing the variable from that module. You specify the default export by including the default keyword immediately after export: /*** my-module.js ***/ //this function is the \"default\" export export default function sayHello() { return 'Hello world!'; } /*** index.js ***/ import greet from './my-module'; //import the default value //`greet` is alias defined in this module greet(); //=> \"Hello world!\" When importing a default export, you don’t include the {} with the name of the variable, but instead provide a variable name (“alias”) you wish to refer to that exported value by. Note that it is also possible to make anonymous values into default exports: /*** animals.js ***/ export default ['lion', 'tiger', 'bear']; //export anonymous array The default export technique is particularly common in object-oriented frameworks like React, or in large frameworks like Bootstrap with lots of different inddependent modules. Using default exports allows you to make each JavaScript module contain the code for a single function or class; that single function then is made the default export, allowing other modules to import it quickly and easily as e.g., import MyComponent from './MyComponent.js'. That said, in general, I recommend you use named imports in most situations—it’s less syntax to remember and reduces the number of decisions made around whether something is default or not. You need to be aware of default exports because many third-party libraries use them, but for your own work its often best to stick with named imports. 14.3 Classes Classes are no longer commonly used in React and are somewhat discouraged in JavaScript. This section is retained for historical and informational purposes, but can be considered “deprecated” for this course. While JavaScript is primarily a scripting and functional language, it does support a form of Object Oriented Programming like that used in the Java language. That is, we are able to define classes of data and methods that act on that data, and then instantiate those classes into objects that can be manipulated. ES6 introduces a new class syntax so that creating classes in JavaScript even looks like how you make classes in Java! Why Classes? The whole point of using classes in programming—whether Java or JavaScript—is to perform abstraction: we want to be able to encapsulate (“group”) together parts of our code so we can talk about it at a higher level. So rather than needing to think about the program purely in terms of Numbers, Strings, and Arrays, we can think about it in terms of Dogs, Cats or Persons. In particular, classes encapsulate two things: The data (variables) that describe the thing. These are known as attributes, fields or instance variables (variables that belong to a particular instance, or example, of the class). For example, we might talk about a Person object’s name (a String), age (a Number), and Halloween haul (an array of candy). The behaviors (functions) that operate on, utilize, or change that data. These are known as methods (technically instance methods, since they operate on a particular instance of the class). For example, a Person may be able to sayHello(), trickOrTreat(), or eatCandy(). In JavaScript, an Object’s properties can be seen as the attributes of that object. For example: const person = { name: 'Ada', age: 21, costume: 'Cheshire Cat' trickOrTreat: function(newCandy){ this.candy.push(newCandy); } } //tell me about this person! console.log(person.name + \" is a \" + person.costume); This Object represents a thing with name, age and costume attributes (but we haven’t yet indicated that this Object has the classification of “Person”). The value of the trickOrTreat() property is a function (remember: functions are values!), and is an example of how an Object can “have” a function. JavaScript even uses the this keyword to refer to which object that function being called on, just like Java! See below for more on the this keyword and its quirks. A Class (classification) acts as template/recipe/blueprint for individual objects. It defines what data (attributes) and behaviors (methods) they have. An object is an “instance of” (example of) a class: we instantiate an object from a class. This lets you easily create multiple objects, each of which can track and modify its own data. ES6 classes provide a syntax by which these “templates” can be defined. React’s preferred styling no longer relies heavily on class syntax, but it’s still a good idea to be familiar with it to help with your understanding and in case you need to do more complex work. Review: Classes in Java First, consider the following simple class defined in Java (which should be review from earlier programming courses): //class declaration public class Person { //attributes (private) private String firstName; private int age; //a Constructor method //this is called when the class is instantiated (with `new`) //and has the job of initializing the attributes public Person(String newName, int newAge){ //assign parameters to the attributes this.firstName = newName; this.age = newAge; } //return this Person's name public String getName() { return this.firstName; //return own attribute } //grow a year public void haveBirthday() { this.age++; //increase this person's age (accessing own attribute) } //a method that takes in a Person type as a parameter public void sayHello(Person otherPerson) { //call method on parameter object for printing System.out.println(\"Hello, \" + otherPerson.getName()); //access own attribute for printing System.out.println(\"I am \" + this.age + \" years old\"); } } You can of course utilize this class (instantiate it and call its methods) as follows: public static void main(String[] args) { //instantiate two new People objects Person aliceObj = new Person(\"Alice\", 21); Person bobObj = new Person(\"Bob\", 42); //call method on Alice (changing her fields) aliceObj.haveBirthday(); //call the method ON Alice, and PASS Bob as a param to it aliceObj.sayHello(bobObj); } A few things to note about this syntax: You declare (announce) that you’re defining a class by using the class keyword. Java attributes are declared at the top of the class block (but assigned in the constructor). Classes have constructor methods that are used to instantiate the attributes. Class methods are declared inside the class declaration (inside the block, indenting one step). Class methods can access (use) the object’s attribute variables by referring to them as this.attributeName. You instantiate objects of the class’s type by using the new keyword and then calling a method with the name of the class (e.g., new Person()). That method is the constructor, so is passed the constructor’s parameters. You call methods on objects by using dot notation (e.g., object.methodName()). Instantiated objects are just variables, and so can be passed into other methods. ES6 Class Syntax Here is how you would create the exact same class in JavaScript using ES6 syntax: //class declaration class Person { //a Constructor method //this is called when the class is instantiated (with `new`) //and has the job of initializing the attributes constructor(newName, newAge) { //assign parameters to the attributes this.firstName = newName; this.age = newAge; } //return this Person's name getName() { return this.firstName; //return own attribute } //grow a year haveBirthday() { this.age++; //increase this person's age (accessing own attribute) } //a method that takes in a Person type as a parameter sayHello(otherPerson) { //call method on parameter object for printing console.log(\"Hello, \" + otherPerson.getName()); //access own attribute for printing console.log(\"I am \" + this.age + \" years old\"); } } And here is how you would use this class: //instantiate two new People objects const aliceObj = new Person(\"Alice\", 21); const bobObj = new Person(\"Bob\", 42); //call method on Alice (changing her attributes) aliceObj.haveBirthday(); //call the method ON Alice, and PASS Bob as a param to it aliceObj.sayHello(bobObj); As you can see, this syntax is very, very similar to Java! Just like with JavaScript functions, most of the changes have involved getting rid of type declarations. In fact, you can write a class in Java and then just delete a few words to make it an ES6 class. Things to notice: Just like in Java, JavaScript classes are declared using the class keyword (this is what was introduced in ES6). Always name classes in PascalCase (starting with an Upper case letter)! JavaScript classes do not declare attributes ahead of time (at the top of the class). Unlike Java, JavaScript variables always “exist”, they’re just undefined until assigned, so you don’t need to explicitly declare them. In JavaScript, nothing is private; you effectively have public access to all attributes and functions. JavaScript classes always have only one constructor (if any), and the function is simply called constructor(). That’s even clearer than Java, where you only know it’s a constructor because it lacks a return type. Just like in Java, JavaScript class methods are declared inside the class declaration (inside the block, indenting one step). But note that you don’t need to use the word function to indicate that a method is a function; just provide the name &amp; parameters. This is because the only things in the class are functions, so declaring it as such would be redundant. Just like in Java, JavaScript class methods can access (use) the object’s attribute variables by referring to them as this.attributeName. Just like in Java, you instantiate objects of the class’s type by using the new keyword and then calling a method with the name of the class (e.g., new Person()). That method is the constructor(), so is passed the constructor’s parameters. Just like in Java, you call methods on objects by using dot notation (e.g., object.methodName()). Just like in Java, instantiated objects are just variables, and so can be passed into other methods. So really, it’s just like Java—except that for the differences in how you declare functions and the fact that we use the word constructor to name the constructor methods. The other difference is that while in Java we usually define each class inside it’s own file, in JavaScript you often create multiple classes in a single file, at the same global “level” as you declared other, non-class functions: //script.js 'use strict'; //declare a class class Dog { bark() { /*...*/ } } //declare another class class Cat { meow() { /*...*/ } } //declare a (non-class) function function petAnimal(animal) { /*...*/ } //at the \"main\" level, instantiate the classes and call the functions const fido = new Dog(); petAnimal(fido); //pass this Dog object to the function Although the above syntax looks like Java, it’s important to remember that JavaScript class instances are still just normal Objects like any other. For example, you can add new properties and functions to that object, or overwrite the value of any property. Although it looks like a Java class, it doesn’t really behave like one. Inheritance The ES6 class syntax also allows you to specify class inheritance, by which one class can extend another. Inheritance allows you to specify that one class is a more specialized version of another: that is, a version of that class with “extra abilities” (such as additional methods). As in Java, you use the extends keyword to indicate that one class should inherit from another: //The \"parent/super\" class class Dog { constructor(name) { this.name = name; } sit() { console.log('The dog '+this.name+' sits. Good boy.'); } bark() { console.log('\"Woof!\"'); } } //The \"child/sub\" class (inherits abilities from Dog) class Husky extends Dog { constructor(name, distance) { super(name); //call parent constructor this.distance = distance; } //a new method (\"special ability\") throwFootball() { console.log('Husky '+this.name+' throws '+this.dist+' yards'); } //override (replace) parent's method bark() { super.bark(); //call parent method console.log(\"(Go huskies!)\"); } } //usage const dog = new Husky(\"Harry\", 60); //make a Husky dog.sit(); //call inherited method dog.throwFootball(); //call own method dog.bark(); //call own (overridden) method In this case, the class Husky is a specialized version of the class Dog: it is a Dog that has a few special abilities (e.g., it can throw a football). We refer to the base, less specialized class (Dog) as the parent or super class, and the derived, more specialized class (Husky) as the child or sub-class. The sub-class Husky class inherits the methods defined in its parent: even though the Husky class didn’t define a sit() method, it still has that method define because the parent has that method defined! By extending an existing class, you get can get a lot of methods for free! The Husky class is also able to override its parents methods, defining it’s own specialized version (e.g., bark()). This is useful for adding customization, or for providing specific implementations of callbacks that may be utilized by a framework—a pattern that you’ll see in React. Note that despite this discussion, JavaScript is not actually an object-oriented language. JavaScript instead uses a prototype system for defining types of Objects, which allows what is called prototypical inheritance. The ES6 class keyword doesn’t change that: instead, it is simply a “shortcut syntax” for specifying Object prototypes in the same way that has been supported since the first version of JavaScript. The class keyword makes it easy to define something that looks and acts like an OOP class, but JavaScript isn’t object-oriented! See this (detailed) explanation for further discussion. Working with this In JavaScript, functions are called on Objects by using dot notation (e.g., myObject.myFunction()). Inside a function, you can refer to the Object that the function was called on by using the this keyword. this is a local variable that is implicitly assigned the Object as a value. const doggy = { name: \"Fido\", bark: function() { console.log(this.name, \"woofs\"); //`this` is object the function was called on } } doggy.bark(); //=> \"Fido woofs\" Here the this is assigned the object doggy, what .bark() was called on. But because functions are values and so can be assigned to multiple variables (given multiple labels), the object that a function is called on may not necessarily be the object that it was first assigned to as a property. this refers to object the function is called on at execution time, not at the time of definition: //An object representing a Dog const doggy = { name: \"Fido\", bark: function() { console.log(this.name + \" woofs\"); } } // An object representing another Dog const doggo = { name: \"Spot\", bark: function() { console.log(this.name + \" yips\")} } //This is Fido barking doggy.bark( /*this = doggy*/ ); //=> \"Fido woofs\" //This is Spot barking doggo.bark( /*this = doggo*/ ); //=> \"Spot yips\" //This is Fido using Spot's bark! doggy.bark = doggo.bark; //assign the function value to `doggy` doggy.bark( /*this = doggy*/) //=> \"Fido yips\" Notice how the this variable is implicitly assigned a value of whatever object it was called on—even the function is assigned to a new object later! But because the this variable refers to the object the function is called on, problems can arise for anonymous callback functions that are not called on any object in particular: class Person { constructor(name){ this.name = name; } //basic constructor //greet each person in the given array greetAll(peopleArray) { //loop through each Person using a callback peopleArray.forEach(function(person) { console.log(\"Hi\"+person.name+\", I'm \"+this.name); }); } } In this example, the greetAll() function will produce an error: TypeError: Cannot read property 'name' of undefined. That is because the this is being called from within an anonymous callback function (the function(person){...})—and that callback isn’t being called on any particular object (notice the lack of dot notation). Since the anonymous callback isn’t being executed on an object, this is assigned a value of undefined (and you can’t access undefined.name). The solution to this problem is to use arrow functions. An arrow function has the special feature that it shares the same lexical this as its surrounded code: that is, the this will not be reassigned to a (non-existent) object when used within an arrow function: class Person { constructor(name){ this.name = name; } greetAll(peopleArray) { peopleArray.forEach((person) => { //arrow function (subtle difference) console.log(\"Hi\"+person.name+\", I'm \"+this.name); //works correctly! }); } } This property makes arrow functions invaluable when specifying callback functions, particularly once classes and objects are involved. Always use arrow functions for anonymous callbacks! Alternatively, it is possible to “permanently” associate a particular this value with a function, no matter what object that function is called on. This is called binding the this, and is done by calling the .bind() method on the function and passing in the value you want to be assigned to this. The .bind() method will return a new function that has the value bound to it; often you will then take this new function and “re-assign” it to the old function variable: //re-assign function myFunction = myFunction.bind(thisValue); This is a common pattern in React (and has some minuscule performance benefits), but for this class you should stick with arrow functions for cleanliness and readability. This chapter has described a few of the more common and potentially useful ES6 features. However, remember that most of these are just “syntactic shortcuts” for behaviors and functionality you can already achieve using ES5-style JavaScript. Thus you don’t need to use these features in your code—though they can be helpful, and they will often show up in how we use libraries such as React. "],["react.html", "Chapter 15 Introduction to React 15.1 Getting Set Up: React and Vite 15.2 JSX 15.3 React Components 15.4 Properties (props) Resources", " Chapter 15 Introduction to React This chapter introduces the React JavaScript library. React is “a JavaScript library for building user interfaces” developed by Facebook (though it is released as open-source software). At its core, React allows you to dynamically generate and interact with the DOM, similar to what you might do with jQuery. However, React was created to make it much easier to define and manipulate lots of different parts of the DOM, and to do so quickly (in terms of computer speed). It does this by enabling you to declare a web app in terms of different components (think: “things” or “parts” of a web page) that can be independently managed—this lets you design and implement web apps at a higher level of abstraction. Moreover, components are usually associated with some set of data, and React will automatically “re-render” (show) the updated component when the data changes—and to do so in a computationally efficient manner. React is currently the most popular “framework” for building large-scale web applications (its chief competitors being Angular and Vue.js, though there are scores of similar frameworks that are also used. Check out TodoMVC for an example of the same application in each!). This means that React is generally very well documented; there are hundreds of tutorials, videos, and examples for building React applications (of which this chapter will be yet another). Some general resources are included at the end of the chapter, but in general we recommend you start with the official documentation, particularly the set of main concepts. Note that this book more or less follows the approach used by Facebooks’s Intro to React Tutorial. React has gone through a number of different major versions in its short life. What’s more: the “style” in which React is written has also evolved over time as new features are added to both the React library and the JavaScript language. This book introduces and emphasizes an approach that prioritizes clarity of concepts and readability of code, rather than conciseness of syntax or use of advanced options, while also attempting to reflect the current practices in React development. React is developed and maintained by Facebook (Meta). Facebook as a company has a long history of violating the Fair Housing Act, leaking or selling personal private data, allowing the spread of misinformation, enabling genocide and in general choosing profits over safety. You may be understandably concerned about whether learning and using React implicitly supports and thus condones this company and its behavior. Whenever you adopt any software tool or library, it is worth investigating who created it (and why) and how that may impact your own willingness to use it as a dependency. 15.1 Getting Set Up: React and Vite React is a JavaScript library similar to those discussed in previous chapters—you load the library and then can call upon its methods. However, React makes use of a significant amount of advanced and custom JavaScript syntax called JSX (described below), as well as extensive use of ES6 Modules. Thus in practice, developing React apps requires using a number of different development tools—just getting setup and started is one of the major hurdles in learning React! Most React apps are structured using a production framework. Such frameworks collect and scaffold the different dependency libraries and build tools needed to start a React project. There are numerous such frameworks, each of which has its own opinions and restrictions on how React apps should be structured. For this course you’ll use Vite as a build tool framework. Vite (pronounced “veet”) provides a quick a simple build environment that allows you to easily write “pure” React without needing to also learn additional framwork quirks. Once you have a foundational understanding of React, you can easily explore and learn additional frameworks and tools. Facebook previously provided an official scaffolding tool called Create React App, though that system has been abandoned (see e.g., this developer comment for some context). Older versions of this textbook and course used Create React App, so you may still see some old references to it! Vite is a command line application that generates scaffolding (“starter code”) for a React application, as well as provides built-in scripts to run, test, and deploy your code. You can use Vite to create a new React app by running the program, specifying name of the folder where you want the app to be created, and that Vite should scaffold a React application (Vite supports multiple different web frameworks). For example, the below command will create a new folder called my-app that contains all of the code and tools necessary to create and run a React app: # Create a new React app project in a new `my-app` directory # Hit 'y' when prompted!! npm create vite@latest my-app -- --template react # Change into new project directory to run further commands cd my-app # Install the build dependencies Vite has scaffolded npm install The npm create &lt;package&gt; command is actually a shortcut for running npx create-&lt;package&gt;—you could equivalently write npx create-vite@latest, though the create command is more conventional. You do not need to install the vite (or create-vite) packages globally. If you specify the current directory (.) as the target folder name (where “my-app” is in the above example), Vite will create a new react app in the current folder! This is useful when you want to create a React app inside an existing cloned GitHub repository. The --template react argument specifies to use the React “starter” template. Vite supports multiple community-defined templates. The extra -- before that argument helps npm know which named argument is being passed in. Running the Development Server After you create a React app, you can use Vite to start up a development webserver by running the dev script: # Make sure you are in the project directory cd path/to/project # Run the development server script npm run dev This will start up the webserver. You’ll need to open up a browser to view the served content, by default at http://localhost:5173/. This development webserver will automatically perform the following whenever you change the source code: It will transpile React code into pure JavaScript that can be run in the web browser (see JSX below). It will manage and reference different JavaScript modules and dependencies, including external node modules. It will display errors and warnings in your browser window—most errors will show up in the developer console, while fatal errors (e.g., syntax errors that crash the whole app) will be shown as an error web page. Note that the Chrome React Developer Tools will provide further error and debugging options. It will automatically reload the page whenever you change the source code! (Though it is often good to manually refresh things when testing, just to make sure). In order to stop the server, hit ctrl-c on the command line. Project Structure A newly created React app using the Vite react template will contain a number of different files, including the following: The index.html file is the home page for your application. If you look at this file, you can see that it contains almost no HTML content—just the &lt;head&gt;, the &lt;body&gt; and a single &lt;div id=\"root\"&gt;. That is because your entire app will be defined using React JavaScrip code; this content will then be injected into that #root element. _All of the content of the page will be defined as JavaScript components—you’ll be creating the entire page in JavaScript files. Thus in practice, you rarely modify the index.html file (beyond changing the metadata such as the &lt;title&gt; and favicon). The index.html file also loads a script /src/main.jsx. The .jsx extension represents JSX code (see below); Vite projects conventionally call this file main.jsx instead of index.js. All JavaScript files are found in the src/ folder The index.html file can also include &lt;link&gt; elements in the &lt;head&gt; in order to laod CSS. However, it is much preferred to instead import load any CSS content through JavaScript code (though Vite will work with either approach). All CSS files are placed in the src/ folder. The src/ folder contains the source code for your React app. The app is started by the main.jsx script, but this script imports and uses other JavaScript modules (such as the provided App.jsx script, which defines the “App” module). In general, you’ll code React apps by implementing components in one or more modules (e.g., App.jsx, AboutPage.jsx), which will then be imported and used by the main.jsx file. See the Components section below for details. When starting a new React app, I recommend deleting all of the content of main.jsx and App.jsx in order to start fresh. The src/index.css and src/App.css are both CSS files used to style the entire page and the individual “App” component respectively. You do not necessarily need both files; I recommend keeping just a single index.css file as you get staretd. Notice that the CSS files are imported from inside the JavaScript files (with e.g., import './index.css' in the src/main.jsx file). This is because the Vite build system knows how to load CSS files, so you can “include” them through the JavaScript rather than needing to link them in the HTML. If you want to load an external stylesheet, such as Bootstrap or Font-Awesome, you can still do that by modifying the public/index.html file—but it’s better to install them as modules and import them through the JavaScript. See the documentation for Adding Bootstrap for an example. Remember that all CSS is global—rules specified in any .css file will apply to the entire app (i.e., the App.css rules will also apply to components other than those in App.js). The CSS is broken into multiple files to try and keep rules organized. You can instead put all your CSS rules into a single file, using naming schema or other techniques to keep them organized. If you are interested in ways to keep the CSS from being applied globally, look into using CSS in JS. The src/assets folder can be used to store media assets that are imported directly; I recommend deleting this and storing assets in the public folder instead. See the Vite assets guide for details. The public/ folder is where you put assets that you want to be available to your page but aren’t loaded and compiled through the JavaScript (i.e., they’re not “source code”). For example, this is where you would put an img/ folder to hold pictures to show. The public/ folder be treated as the “root” of the webpage; a file found at public/img/picture.jpg would be referenced in your DOM as img/picture.jpg—using a path relative to the public/ folder. See the Vite assets guide for details. You can alternatively put assets into the src/assets folder, and then import them into the JavaScript (treating those images as “source code”). I don’t recommend this when starting out; it’s simpler to put images into the public folder and delete the src/assets folder. The two config files eslint.config.json and vite.config.js includes configuration information for eslint (for styling checks) and Vite respectively. You don’t need to modify either of these, but do not delete them! Overall, you’ll mostly be working with the .jsx and .css files in the src/ folder as you develop a React app. 15.2 JSX At its core, React is simply a DOM creation and rendering library—it allows you to declare new DOM elements (e.g., make a new &lt;h1&gt;) and then add that element to the webpage. This is similar to the process you might do with the DOM or the jQuery library: //Create and render a new `&lt;h1>` element using DOM methods const element = document.createElement('hi'); //create element element.id = 'hello'; //specify attributes element.classList.add('my-class'); element.textContent = 'Hello World!'; //specify content document.getElementById('root').appendChild(element); The React library provides a set of functions that do similar work: //Import required functions from the React libraries import React from 'react'; import ReactDOM from 'react-dom/client'; //Create a new `&lt;h1>` element using React methods. This function takes //arguments indicating what the element should be const msgElem = React.createElement( //html tag 'h1', //object of attributes { id: 'hello', className: 'myClass' }, //content 'Hello World!' ); //Create a \"React root\" out of the `#root` elemment const root = ReactDOM.createRoot(document.getElementById('root')); //render the React element at that root root.render(element) React’s React.createElement() lets you create an element (a “React element”, not a pure DOM element—they are different!) by specifying the element type/tag, the content, and an object that maps from attribute names to values—all as a single statement. The ReactDOM.createRoot() function creates a context in which a React element can then be rendered (shown on the screen)—usually placing that in the div#root on the page. The root’s render() method will then take a particular React element and insert it as the child content of the React root element . Note that root.render() function replaces the content of the root DOM element—it’s a “replace” not an “append” operation. Notice that the class attribute is specified with the className property. This is because class is a reserved keyword in JavaScript (it declares a class). The createRoot() function was introduced with React v18 (March 2022). Previous versions of React used the ReactDOM.render() function directly instead of explicitly creating a root context. Using ReactDOM.render() will cause your app to function as if using React v17, preventing some advanced features from working. The React.createElement() function is wordy and awkward to type, particularly if you’ll be defining a lot of DOM elements (and in React, you define the entire application in JavaScript!). Thus React lets you create and define elements using JSX. JSX is a syntax extension to JavaScript: it provide a new way of writing the language—in particular, the ability to write bare HTML tags (finally!): //Create a new `&lt;h1>` element using JSX syntax const element = &lt;h1 id=\"hello\" className=\"myClass\">Hello World&lt;/h1>; //Create a \"React root\" out of the `#root` elemment //then render the React element at that root const root = ReactDOM.createRoot(document.getElementById('root')); root.render(element) The value assigned to the element variable is not a String (it has no quotes around it). Instead it is a syntactical shortcut for calling the React.createElement() function—the HTML-like syntax can be automatically translated into the actual JavaScript for the method call, allowing you to write the simpler version. Notice that there is still a semicolon (;) at the end of the first line. You’re not actually writing HTML, but defining a JavaScript value using syntax that mostly looks like HTML! JSX can be used to define nested elements; you are not limited to a single element: //JSX can define nested elements const header = ( &lt;header className=\"banner\"> &lt;h1>Hello world!&lt;/h1> &lt;/header> ); It’s very common to put elements on their own lines, intended as if you were writing HTML directly. If you do so, you’ll need to surround the entire JSX expression in parentheses () to tell the interpreter that the line break shouldn’t be read as implying a semicolon! Note that similar to XML, JSX syntax requires that all elements be closed; thus you need to use a closing slash at the end of empty elements: //JSX elements must be closed const picture = &lt;img src=\"my_picture.png\" alt=\"a picture\" /> Since JSX is not actually valid JavaScript (you can’t normally include bare HTML), you need to “translate” it into real JavaScript so that the browser can understand and execute it. This process is called transpiling, and is usually performed using a compiler program called Babel. Babel is yet another piece of the toolchain used to create React applications; however, all the details about transpiling with Babel are automatically handled by the Create React App scaffolding. “Transpile with Babel” is one of the steps performed by Webpack, which is included and run from the scripts provided by Create React App (whew!). Yes, chaining tools together like this is how modern web development works. In short: you write JSX code, and when you run your app with Create React App it will be turned into regular old JavaScript code that your browser can actually understand. Inline Expressions JSX allows you to include JavaScript expressions (such as variables you want to reference) directly inside of the HTML-like syntax. You do this by putting the expression inside of curly braces ({}): const message = \"Hello world!\"; const element = &lt;h1>{message}&lt;/h1>; When the element is rendered, the expression and the surrounding braces will be replaced by the value of the expression. So the above JSX would be rendered as the HTML: &lt;h1&gt;Hello World&lt;/h1&gt;. You can put any arbitrary expression inside of the {}—that is, any JavaScript code that resolves to a single value (think: anything that you could assign to a variable). This can include math operations, function calls, ternary expressions, or even an anonymous function values (see the next chapter for examples): //Including an inline expression in JSX. The expressions can be mixed directly //into the HTML const element = &lt;p>A leap year has {(365 + 1) * 24 * 60} minutes!&lt;/p>; You can use inline expressions most anywhere in JSX, including as the value of an attribute. You can even declare element attributes as an object and then use the spread operator (...) to specify them as an inline expression. //Define a JavaScript variable const imgUrl = 'path/to/my_picture.png'; //Assign that variable to an element attribute const pic = &lt;img src={imgUrl} alt=\"A picture\" />; //Define an object of element attributes const attributes = { src: 'path/to/other_picture.png', alt: 'Another picture' }; //A DOM element that includes those attributes, among others. //The spread operator applies the property names as attributes of the element. const otherPic = &lt;img {...attributes} className=\"my-class\" />; Notice that when specifying a JavaScript expression as the value of an attribute (as with the src attribute of an &lt;img&gt;), you do not include quotes around the {}. The value of the inline expression is already a string, and it is that string that you’re assigning to the attribute. Inline expressions aren’t “copy-pasted” into the HTML-style of JSX; rather the values of those expressions are assigned to the object properties represented by the HTML-style attributes. Importantly, the elements defined with JSX are also valid JavaScript expressions! Thus you can use inline expressions to include one element inside of another. //Define variable content to display. One is a string, one is a React element. const greetingString = \"Good morning!\"; const iconElem = &lt;img src=\"sun.png\" alt=\"A wide awake sun\" />; //Conditionally change values based on an `isEvening` value (defined elsewhere) if(isEvening) { greetingString = \"Good evening!\"; iconElem = &lt;img src=\"moon.png\" alt=\"A dozing moon\" />; } //Include the variables inline in another React element //Notice how the `icon` element is included as a child of the `&lt;header>` const header = ( &lt;header> &lt;h1>{greetingString}&lt;/h1> {iconElem} &lt;/header> ); If you include an array of React elements in an inline expression, those those elements will be interpreted as all being children of the parent element (siblings of each other): //An array of React elements. Could also produce via a loop or function const listItems = [&lt;li>lions&lt;/li>, &lt;li>tigers&lt;/li>, &lt;li>bears&lt;/li>]; //Include the array as an inline expression; each `&lt;li>` element will be //included as a child of the `&lt;ul>` const list = ( &lt;ul> {listItems} &lt;/ul> ); The above sample would produce the HTML: &lt;ul> &lt;li>lions&lt;/li> &lt;li>tigers&lt;/li> &lt;li>bears&lt;/li> &lt;/ul> This is particularly useful when using a variable number of elements, or generating elements directly from data (see the Props and Composition section below). As a final note: you cannot include HTML comments (&lt;!-- --&gt;) inside of JSX, as this isn’t actually an element type. You also can’t use inline JavaScript comments (//), because even multi-line JSX is still a single expression (that’s why the &lt;header&gt; example above is written in parentheses). Thus in order to include a comment in JSX, you can use a JavaScript block comment (/* */) inside of an inline expression: const main = ( &lt;main> { /* A comment: the main part of the page goes here... */ } &lt;/main> ) 15.3 React Components When creating React applications, you use JSX to define the HTML content of your webpage directly in the JavaScript. However, writing all of the HTML out as one giant JSX expression doesn’t provide much advantage over just putting that content in .html files in the first place. Instead, the React library encourages and enables you to describe your web page in terms of components, instead of just HTML elements. In this context, a Component is a “piece” of a web page. For example, in a social media application, each “status post” on a timeline might be a different Component, the “like” button may be its own Component, the “what are you thinking about?” form would be a Component, the page navigation would be a Component, and so forth. Thus you can almost think of a Component as a semantic abstraction of a &lt;div&gt; element—a “chunk” of the page. But like with &lt;div&gt;s, a Component can be seen as made of of other Components—you might have a “Timeline” Component that is made up of many “StatusPost” Components, and each StatusPost Component may include a “ReactionButton” Component. Thinking about a page in terms of Components instead of HTML elements can make it much easier to design and reason about your page. You don’t need to worry about the code syntax or the specific elements to use, you can just think of your page in terms of its overall layout and content—what needs to be on the page, and how that content is organized—the same way you might mock up a web page in a graphic design program. See the documentation article Thinking in React for an example of how to design a page in terms of Components. React enables you to implement your page in terms of explicit Components by providing a way for you to define your own XML elements! Thus you can define a &lt;Timeline&gt; element, which has multiple &lt;StatusPost&gt; elements as children. Components will be able to be included directly in your JSX, made up of and mixed in with standard HTML elements. An example page broken up into components. Example from http://coenraets.org/blog/2014/12/sample-mobile-application-with-react-and-cordova/ &lt;App> &lt;HomePage> &lt;Header /> &lt;SearchBar /> &lt;EmployeeList> &lt;EmployeeListItem person=\"James King\" /> &lt;EmployeeListItem person=\"Julie Taylor\" /> &lt;EmployeeListItem person=\"Eugene Lee\" /> &lt;/EmployList> &lt;/HomePage> &lt;EmployeePage> &lt;Header /> ... &lt;/EmployeePage> &lt;/App> React components are most commonly defined using function components: JavaScript functions that return the DOM elements (the JSX) that will be rendered on the screen to show that Component: //Define a Component representing information about a user function UserInfoCard(props) { //This is an everyday function; you can include any code you want here //including variables, if statements, loops, etc const name = \"Ethel\"; const descriptor = \"Aardvark\"; //Return a React element (JSX) that is how the Component will appear return ( &lt;div> &lt;h1>{name}&lt;/h1> &lt;p>Hello, my name is {name} and I am a {descriptor}&lt;/p> &lt;/div> ) } //Create a new value (a React element) //This syntax in effect \"calls\" the function const infoElement = &lt;UserInfoCard />; //Show the element in the web page (inside #root) const root = ReactDOM.createRoot(document.getElementById('root')); root.render(infoElement); This function defines a new Component (think: a new HTML element!) called UserInfoCard. Things to note about defining this component: A Component function must be named starting with a Capital letter (and usually in CamelCase). This is to distinguish a custom component from a “normal” React element. If you see a function with a Capitalized name, know that it’s actually a defining a Component! It’s also possible for function components to be defined as anonymous arrow functions assigned to const variables: const Example = (props) => { return &lt;div>...&lt;/div> } This provides some benefits in terms of scoping (because of the arrow function), but otherwise makes Components even harder to read—its not as readily obviously that this is a function and a Component. You should stick to defining component functions using the function keyword (and not arrow functions) for readability, but be aware of the alternate approach which is used in some libraries and examples. Component functions take in a single argument representing the props (discussed below). As such by convention it is always named props (with an s!). While it’s possible to omit this argument if it isn’t used (as you can with all JavaScript functions), best practice is to always include it. A component function is a regular function like any other that you’ve written. That means that it can and often does do more than just return a single value! You can include additional code statements (variable declarations, if statements, loops, etc) in order to calculate the values you’d like to include in inline expressions in the returned JSX. Style requirement: perform any complex logic—including functional looping such as with map() or filter()—outside of the return statement. Keep the return statement as simple as possible so it remains readable—and more importantly debuggable (so you can use things like console.log statements to check intermediate values before they are returned). NEVER include an inline callback function so that you have a return statement inside of a return statement! A Component function can only return a single React element (you can’t return more than one value at a time from a JavaScript function). However, that single React element can have as many children as you wish. It’s very common to “wrap” all of the content you want a component to include in a single &lt;div&gt; to return, as in the above example. If you don’t want to add an extra div for some reason, it’s also possible to “wrap” content in a Fragment, which can be declared using a shortcut syntax that looks like an element with no name: function FragmentExample(props) { return ( &lt;> &lt;p>First paragraph&lt;/p> &lt;p>Second paragraph&lt;/p> &lt;/> ) } Once it has been defined, a Component can then be created in JSX using XML-style syntax, just like any other element (i.e., as &lt;UserInfoCard /&gt;). In effect, this “calls” the function component in order to create it—you never call the function directly. You can use the created Component like any other React element, such as including it as a child of other HTML (e.g., nest it inside of a &lt;div&gt;). A Component thus encapsulates a chunk of HTML, and you can almost think of it as a “shortcut” for including that HTML. Never call a component function as a function with MyComponent()! Always render as an element with &lt;MyComponent/&gt;. Because Components are instantiated as React elements, that means that you can use them anywhere you would use a normal HTML element—including in the returned value of another component! This is called composing components—you are specifying that one component is “composed” (made up of) others: //A component representing a message function HelloMessage(props) { return &lt;p>Hello World!&lt;/p>; } //A component representing another message function GoodbyeMessage(props) { return &lt;h1>See ya later!&lt;/h1>; } //A component that is composed of (renders) other components! function MessageList(props) { return ( &lt;div> &lt;h1>Messages for you&lt;/h1> &lt;HelloMessage /> {/* include a HelloMessage component */} &lt;GoodbyeMessage /> {/* include a GoodbyeMessage component */} &lt;/div> ); } //Render an instance of the \"top-level\" (\"outer\") component const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;MessageList />); In the above example, the MessageList Component is composed of (renders) instances of the HelloMessage and GoodbyeMessage Components; when the MessageList is displayed, the interpreter will create the two other components, rendering each in turn. In the end, all of the content displayed will be standard HTML elements—they’ve just been organized into Components. Components are usually instantiated as empty elements, though it is possible to have them include child elements. Notice that you can and do mix standard HTML elements and Components together; Components are just providing a useful abstraction for organizing content, logic, and data! In practice, React applications are made up of many different Components—dozens or even hundreds depending on the size of the app! The “top-most” component is commonly called App (since it represents the whole “app”), with the App’s returned value instantiating further components, each of which represents a different part of the page. The App component will represent the entirety of the website—all of your app’s content will be defined in React components (which will be rendered as children of the &lt;App&gt;). But since the React components will be inserted inside of the &lt;div id=\"root\"&gt; element that is already in the index.html file, you do not ever include &lt;body&gt; or &lt;head&gt; elements in your React components—those elements are already defined in the HTML file itself, so don’t get created by React! See Props and Composition below for examples of common ways that React components are composed. Strict Mode If you look at the starter code generated by Vite, you will see a common pattern of “wrapping” a rendered &lt;App&gt; component in a &lt;React.StrictMode&gt; component: import React from 'react'; import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render( &lt;React.StrictMode> &lt;App /> &lt;/React.StrictMode> ); The StrictMode component is provided by React (it’s a property of the React object imported in the first line of the above example). Kind of like the use strict declaration for JavaScript, this component enables a number of additional error checking that React can perform— though most of the issues it identifies are due to using out-of-date practices or errors with features not covered in this course. It can be useful, though it will cause duplicated output of some console.log() statements and is not strictly necessary. Component Organization React applications will often have dozen of components, quickly growing more complex than the basic starting examples in the previous section. If you tried to define all of these components in a single index.js file, your code would quickly become unmanageable. Thus individual components are usually defined inside of separate modules (files), and then imported by the modules that need them—other components or the root index.js file. Recall that in order to make a variable or function (e.g., a Component) available to other modules, you will need to export that component from its own module, and then import that value elsewhere: /* in Messages.js file */ //Export the defined components (as named exports) export function HelloMessage() { /* ... */ } export function GoodByeMessage() { /* ... */ } /* in App.js file */ //Import components needed from other modules import { HelloMessage, GoodbyeMessage } from `./Messages.js`; //named imports! //Can also export as a _default_ export; common if the file has only one component export default function App() { return ( &lt;div> {/* Use the imported components */} &lt;HelloMessage /> &lt;GoodbyeMessage /> &lt;/div> ) } /* in index.js file */ //Import components needed from other modules import App from `./App.js`; //default import! //Render the imported component const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;App />); This structure allows you to have each component (or set of related components) in a different file, helping to organize your code. This “export-import” structure implies a one-directional hierarchy: the Message components don’t know about the App component that will render them (they are self-contained). You should not have two files that import from each other! The index.js file will usually just import a single component; that file stays very short and sweet. Put all of your component definitions in other files. It is common to use the file system to further organize your component modules, such as grouping them into different folders, as in the below example: src/ |-- components/ |-- App.js |-- navigation/ |-- NavBar.js |-- utils/ |-- Alerts.js |-- Buttons.js index.js Note that a module such as Alerts.js might define a number of different “Alert” components to use; these could be imported into the NavBar.js or App.js modules as needed. The App.js component would be imported by the index.js file, which would contain the call to root.render(). However, it is not necessary to put each different component in a separate module; think about what kind of file organize will make it easy to find your code and help others to understand how your app is structured! Deprecated Alternative: Class Components In order versions and styles of React, it was alternatively possible to define components as classes (using ES6 Class syntax) that acts as a template or blueprint for that content. In particular, you define a class that inherits from the React.Component class—this inheritance means that the class you define IS A React Component! //Define a class component representing information about a user class UserInfo extends React.Component { //Components MUST override the `render()` function, which must return a //DOM element render() { //This is an everyday function; you can include any code you want here const name = \"Ethel\"; const descriptor = \"Aardvark\"; //Return a React element (JSX) that is how the component will appear return ( &lt;div> &lt;h1>{name}&lt;/h1> &lt;p>Hello, my name is {name} and I am a {descriptor}&lt;/p> &lt;/div> ) } } //instantiate the class as a new value (a React element) const infoElement = &lt;UserInfo />; //Show the element in the web page (inside #root) const root = ReactDOM.createRoot(document.getElementById('root')); root.render(infoElement); This “class component” example is identical to the previous function component example—it takes the “body” of the function component and moves that into a (required) render() method. Note that the React.Component class is often imported as a named import, so that you can refer to it directly: import {Component} from 'react'; class MyComponent extends Component { render() { //... } } Current best practices in React are to only use function components and to not use class components; class components provide no extra functionality, and can introduce some additional complexities (particularly for handling their state). However it is good to be aware of the option in case you run across it, and thinking about components as “classes” can be useful for understanding how they are defined and used. Additionally, older versions of React included a function React.createClass() that took in an object whose properties were functions that would act as class methods (see here for details). Although this function has been removed, it’s worth being aware of in case you come across older examples of React code that you need to interpret or adapt. 15.4 Properties (props) One of the main goals of using a library such as React is to support data-driven views—that is, the content that is rendered on the page can be based on some underlying data, providing a visual representation of that data. And if that underlying data changes, React can automatically and efficiently “re-render” the view, making the page dynamic. You can specify the underlying data that a React component will be representing by specifying properties (usually just called props) for that component. Props are the “input parameters” to a component—they are the details you pass to it so that it knows what and how to render its content. You pass a prop to a component when you instantiate it by specifying them as XML attributes (using name=value syntax)—the props are the “attributes” of the component! //Passing a prop called `message` with value \"Hello property\" const messageA = &lt;MessageItem message=\"Hello property!\" />; //Passing a prop using an inline expression const secret = \"Shave and a haircut\"; const messageB = &lt;MessageItem message={secret} />; //A component can accept multiple props //This component takes in a `userName` prop as well as a `descriptor` prop const userInfo = &lt;UserInfo userName=\"Ethel\" descriptor=\"Aardvark\" />; Prop names must be valid JavaScript identifiers, and so should be written in camelCase (like variable names). Components are usually defined so that they expect a certain set of props—similar to how a function is defined to expect a certain set of arguments. It is possible to pass “extra” props to the Component (by specifying additional XML attributes), but if the component doesn’t expect those props it won’t do anything with them. Similarly, failing to pass an expected prop will likely result in errors—just like if you didn’t pass a function an expected argument! For function components, the props are received as a single argument to the function (usually called props). This argument is a regular JavaScript object whose keys are the props’ “names”: //Define a component representing information about a user function UserInfo(props) { console.log(props) //you can see this is an object! //access the individual props from inside the argument object const userName = props.userName; const descriptor = props.descriptor; //can use props for logic or processing const userNameUpper = props.userName.toUpperCase(); return ( &lt;div> &lt;h1>{userNameUpper}&lt;/h1> &lt;p>Hello, my name is {userName} and I am a {descriptor}&lt;/p> &lt;/div> ) } const userInfo = &lt;UserInfo userName=\"Ethel\" descriptor=\"Aardvark\" />; Again, all props are stored in the argument object—you have to access them through that value. To avoid having to type props.___ all the time, it’s common to use object destructuring to assign all of the props to variables in a single line: function UserInfo(props) { //assign the prop object properties to variables const {userName, descriptor} = props; return &lt;h1>{userName}&lt;/h1>; } It’s also possible to specify the object destructuring in the argument declaration! //The props object passed in will be destructured into two argument variables function UserInfo({userName, descriptor}) { return &lt;h1>{userName}&lt;/h1>; } This can help make it clear in the source code what props a component expects, though can make the code somewhat more difficult to parse (since there are so many parentheses and curly braces). However, to keep the idea of the props clear, all examples in this book will use a single, non-destructured props object. Importantly, props can be any kind of value! This includes basic types such as Numbers or Strings, data structures such as Arrays or Objects, or even functions or other component instances! //Props can be of any data type! //Pass an array as a prop! const array = [1,2,3,4,5]; const suitcase = &lt;Suitcase luggageCombo={array} />; //Pass a function as a prop (like a callback)! function sayHello() { console.log('Hello world!'); } const greeting = &lt;Greeting callback={sayHello} />; //Pass another Component as a prop (not common)! const card = &lt;HolidayCard message=\"Greetings world!\" /> const gift = &lt;Gift toMsg=\"Ethel\", fromMsg={card} /> Indeed, passing callback functions as props to other components is a major step in designing interactive React applications. See the next chapter for more details and examples. Props and Composition Recall that React components are usually composed, with one component’s returned value including instances of other components (as in the MessageList example above). Since props are specified when a component instance is created, this means that a “parent” component will need to specify the props for its children (“passing the props”). Commonly, the props for the child components will be derived from the props of the parent component: //Defines a component representing a message in a list function MessageItem(props) { return &lt;li>{props.message}&lt;/li> } //A component that renders a trio of messages function MessageListTrio(props) { const messages = props.messages; //assign prop to a local variable for convenience return ( &lt;div> &lt;h1>Messages for you&lt;/h1> &lt;ul> {/* instantiate child components, passing data from own props */} &lt;MessageItem message={messages[0]} /> &lt;MessageItem message={messages[1]} /> &lt;MessageItem message={messages[2]} /> &lt;/ul> &lt;/div> ); } //Define and pass a prop to the parent comment when rendering it const messagesArray = [\"Hello world\", \"No borders\", \"Go huskies!\"]; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;MessageListTrio messages={messagesArray}); This creates a one-directional data flow—the data values are passed into the parent, which then passes data down to the children (not vice versa). The component organization in the previous example is particularly common in React. In order to effectively render a list (array) of data, you should define a Component that declares how to render a single element of that list (e.g., MessageItem). This allows you to focus on only a single problem, developing a re-usable solution. Then you define another component that represents how to render a whole list of elements (e.g., MessageList). This component will render a child item component for each element—it just needs to set up the list, without worrying about what each item looks like! The data set can be passed into the parent (List) component as a prop, and each individual element from that data set will be passed into an instance of the child (Item) component. In effect, the List component is tasked with taking the data set (an array of data values) and producing a set Item components (an array of Components). This kind of transformation is a mapping operation (each data value is mapped to a Component), and so can be done effecttively with the map() method: //Map an array of message strings to an array of components const msgItems = props.messages.map((msgString) => { const component = &lt;MessageItem message={msgString} />; //pass prop down! return component; //add this new component to resulting array }) And because including an array of Components as an inline expression in JSX will render those elements as siblings, it’s easy to render this list from within the parent: function MessageList(props) { //the data: an array of strings [\"\", \"\"] const messageStringArray = props.messages; //the renderable content: an array of elements [&lt;>, &lt;>] const msgElemArray = messageStringArray.map((msgString) => { const component = &lt;MessageItem message={msgString} />; //pass prop down! return component; //add this new component to resulting array }) return ( &lt;div> &lt;h1>Messages for you&lt;/h1> &lt;ul> {/* render the array of MessageList components */} {msgElemArray} &lt;/ul> &lt;/div> ); } //Define and pass a prop to the parent comment when rendering it const messagesArray = [\"Hello world\", \"No borders\", \"Go huskies!\"]; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;MessageList messages={messagesArray}); Note that the above example will issue a warning in the developer console. This is because React requires you to specify an additional prop called key for each element in an array of components. The key should be a unique string for each element in the list, and acts as an identifier for that element (think: what you might give it as an id attribute). React will use the key to keep track of those elements, so if they change over time (i.e., elements are added or removed from the array) React will be able to more efficiently modify the DOM. If unspecified, the key will default to the element’s index in the array, but this is considered unstable (since it will change as items are added or removed). Thus a better approach is to determine a unique value based on the data—which means that data items will need to be uniquely identifiable. The below improved version of the code changes each message from a basic String to an Object that has content and id properties, allowing each data value to be uniquely identified. Note that the MessageItem component need not be changed; it still renders an &lt;li&gt; showing the given message prop! const MESSAGE_DATA = [ {content: \"Hello world\", id: 1} {content: \"No borders\", id: 2} {content: \"Go huskies!\", id: 3} ]; function MessageList(props) { //the data: an array of objects [{}, {}] const messageObjArray = props.messages; //the renderable content: an array of elements [&lt;>, &lt;>] const msgElemArray = messageObjArray.map((msgObject) => { //return a new MessageItem for each message object //attributes are listed on their own lines for readability return &lt;MessageItem message={msgObject.content} key={msgObject.id.toString()} {/* pass in a key prop! */} />; }) //end of .map() return ( &lt;div> &lt;h1>Messages for you&lt;/h1> &lt;ul> {msgElemArray} &lt;/ul> &lt;/div> ); //end of return } //Define and pass a prop to the parent comment when rendering it const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;MessageList messages={MESSAGE_DATA}); This pattern enables you to effectively define your web page’s content in terms of individual components that can be composed together, allowing you to quickly render large amounts of data (without needing spend a lot of time thinking about loops!). Resources As mentioned above, there are a large number of different resources for learning React. Below are links to key parts of the official documentation. Thinking in React Facebook’s React Tutorial React Documentation JSX Documentation Components and Props React API References "],["interactive-react.html", "Chapter 16 Interactive React 16.1 Handling Events in React 16.2 State and Hooks 16.3 Specific Interactions Resources", " Chapter 16 Interactive React This chapter discussed how websites built using the React library can be made interactive, with Components that render different content in response to user actions. Specifically, it details how to idiomatically handle events, store dynamic information in a Component’s state using hooks, as well as perform some specific common interactions (such as using forms and downloading data) 16.1 Handling Events in React You can handle user interaction in React in the same way you would using the DOM or jQuery: you register an event listener and specify a callback function to execute when that event occurs. In React, you register event listeners by specifying a React-specific attribute on an element. The attribute is generally named with the word on followed by the name of the event you want to respond to in camelCase format. For example, onClick registers a listener for click events, onMouseOver for mouseover events, and so on. You can see the full list of supported event handling attributes in the documentation for synthetic events. The attribute should be assigned a value that is a reference to a callback function (specified as an inline expression). //A component representing a button that logs a message when clicked function MyButton() { //A function to call when clicked. The name is conventional, but arbitrary. //The callback will be passed the DOM event (just like with DOM callbacks) const handleClick = function(event) { console.log(\"clicky clicky\"); } //make a button with an `onClick` attribute! //this \"registers\" the listener and sets the callback return &lt;button onClick={handleClick}>Click me!&lt;/button>; } This component renders a &lt;button&gt; in the DOM with a registered click event. Clicking on that DOM element will cause the handleClick function to be executed. For readability, the above example specifies the callback function as a separate function (defined inside of the component—so yes, a function created inside of a function)! Note that it is more common to define nested callbacks using arrow functions: const handleClick = (event) => { console.log('clicky clicky'); } You can also specify a callback function inline in the JSX, though this can quickly get messy and hard to read with complex event handling, so is not recommended. function MyButton() { return &lt;button onClick={(evt) => console.log(\"clicky clicky\")}/> } Importantly, you can only register events on React elements (HTML elements like &lt;button&gt;, that are named with lowercase letters), not on Components. If you tried to specify a &lt;MyButton onClick={callback}&gt;, you would be passing a prop that just happened to be called onClick, but otherwise has no special meaning! Although functionally similar, React event handling attributes are NOT the same as HTML event handles—React’s onClick is different from HTML’s onclick. The React attributes are specialized to work within the React event system. In the end, they’re similar to a JSX-based syntactic shortcut for using addEventListener(), so we aren’t actually mixing concerns more! 16.2 State and Hooks The previous section describes how to respond to user-generated events, but in order for the page to be interactive you need to be able to manipulate its rendered content when that event occurs. For example, you could click on a button and show how many times it was pressed, select a table column to sort the data by that feature, or select a component in order to show an entirely different “page” of content (see Chapter 19). To achieve these effects, a component will need to keep track of its state or situation—the number on the counter, how the table is sorted, or which “page” is being shown. In React, a component’s state represents internal, dynamic information about how that Component should be rendered. The state contains data that changes over time (and only such information—if the value won’t change for that instance of a component, it shouldn’t be part of the state!). Moreover, whenever the state is changed, a React component will automatically “rerender”—the component will be “rerun” and the new, updated DOM elements returned will be displayed on the screen (replacing the previously rendered version). In short: changing the state will “refresh” the component! State can be specified for a function component by using a state hook. Hooks are functions provided by React that let you “hook into” the framework’s rendering and displaying processes. The state hook in particular lets you hook into the state of a component, specifying what values should be “tracked” and should cause the component to rerender. Hooks were introduced with React v16.8 (October 2018), and thus are the “new” current way of handling state. For details on older techniques (which require using class components), see State in Class Components. Fun fact: hooks are basically an example of mixins, which are an object-oriented technique for including/injecting data or behavior in a class without needing to inherit that behavior from a parent class. The state hook is a function provided by React called useState(). This function will need to be imported from the React library (note that it is a named export so should be imported as such): //import the state hook function import React, { useState } from 'react'; The useState() function is then called within the component function (usually at the top of the function so that the resulting variables will be available to use): function CountingButton() { //Define a `count` state variable, initially 0 const [count, setCount] = useState(0); //an event handling callback const handleClick = (event) => { setCount(count+1); //update the state to be a new value } return ( { /* a button with the event handler that displays the state variable */} &lt;button onClick={handleClick}>You clicked me {count} times&lt;/button> ); } Calling the useState() function creates a “state variable”—a value that will be tracked and stored between calls to render/rerender the component. You can almost think of a state variable as like an “instance variable” for the function (and indeed, state is stored in object instance variables). The useState() function is passed the initial starting value for the state variable. In above example, the count state variable will be initialized as 0. The useState() function returns an array of two values: the first is the current value of the state (e.g., what it was initialized as), and the second is a function used to modify that particular state variable (a “setter” or mutator). By convention, you use array destructuring to assign these two values to two separate variables in a single operation. Thus the above line calling useState() can be read as a shorthand for: const hookArray = useState(0); //the function returns an array of 2 values const count = hookArray[0]; //assign the 1st elem (a value) to `count` const setCount = hookArray[1]; //assign the 2nd elem (a function) to `setCount` Importantly, there is nothing magical about the names of the variables that the useState() result is assigned to. It could just as well have been written: const [countVariable, functionToUpdateCount] = useState(0) Because the function is a “setter” it’s usually named as such (setVARIABLE), but this is not required. It’s just a function; you can name it whatever you want. Because the current state value is assigned to a regular variable (e.g., count in the above example), you can use it anywhere you would use a variable—such as in an inline expression to display the value. Note that if the value isn’t actually used in the rendered DOM in any way (directly or indirectly), it probably shouldn’t be part of the state! Updating State It’s not possible to change the value of a state variable directly (e.g,. you can’t do count = count +1)—that’s why the variable is declared as const! Instead, you need to use the “set state” function that was created (e.g., setCount() in the above example). This function will take as an argument the new value to assign to the state variable (overwriting the previous value). When the set state function is called, not only will it change the value of the state variable, but it will also “rerender” the component—it will cause the component function to be called again, returning a new set of DOM elements to be shown on the screen. These DOM elements will replace the previously rendered version of the component; React merges these changes into the page’s DOM in a highly efficiency manner, changing only the elements that have actually updated—this is what makes React so effective for large scale systems. This is one of the trickier parts to remember in React: when you call a set state function, it will cause your component function to “re-run”—which means that any logic will execute for a second time (though now the “current” value of the state variable will be updated, rather than the initial value passed into useState). Never call a set state function directly from inside of your component function; only in callbacks (such as for event handling). Calling setCount() directly would cause an infinite recursive loop. Component functions must remain “pure” with no side effects. Moreover, set state functions are asynchronous. Calling the function only sends a “request” to update the state; it doesn’t happen immediately. This is because React will “batch” multiple requests to update the state of components (and so to rerender them) together—that way if your app needs to make lots of small changes at the same time, React only needs to regenerate the DOM once, providing a significant performance boost. //An Component with a callback that doesn't handle asynchronous state changes function CounterWithError(props) { const [count, setCount] = useState(3) //initial value of 3 const handleClick = (event) => { setCount(4); //change `count` to 4 console.log(count); //will output \"3\"; state has not changed yet! } } In this example, because setCount() is asynchronous, you can’t immediately access the updated state variable after calling the function. You instead need to wait for the component to “rerender”—when the component’s DOM is regenerated, it will use the updated value. If you want to see that value, log it out right before you return the DOM (not inside of the click event handler). It is possible to have multiple state variables, each declared with a different call to useState(): //Example from React documentation function ExampleWithManyStates() { //Declare multiple state variables! const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]); } While it’s possible for a single state variable to contain complex values (objects and arrays, as in the todos variable above), it’s often cleaner to use multiple different state variables—that way React needs to change as little data as possible when you wish to update a variable. Importantly, you need to pass a new value into the set state function in order for it to actually update the state and rerender the component. Just changing a value inside of an existing object won’t work: function TodoListWithError() { //a state value that is an array of objects const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]); const handleClick = (event) => { todos[0].text = \"Fix bugs\"; //modify the object but don't make a new one setTodos(todos) //This won't work! } } In the above example, changing a property of the todos array-of-objects doesn’t actually change the value. This when you call setTodos(todos), React thinks that nothing has updated (it doesn’t do a deep inspection of the object) so doesn’t update anything. Instead, you’ll need to create a new copy of the array or object, and then pass that new value into the set state function: function TodoList() { //a state value that is an array of objects const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]); const handleClick = (event) => { //create a copy of the array using the `map()` function const todosCopy = todos.map((todoObject, index) => { if(index == 0) { //transform objects if needed todoObject.text = \"Fix bugs\" } return todoObject; //return object to go into new array }) setTodos(todosCopy) //This works! } } This is because React wants to encourage data to remain immutable (you don’t change it, you just make a altered copy) and for functions to avoid side effects (where they change something outside of themselves) in order to help maintain consistency of your data. The .map() function is usually the easiest way to copy an array, though other techniques exist as well. If you wish to copy an object, you can do this easily using the spread operator to create a new object using the properties of the first: //an original object const original = {a: 1, b: 2}; //Create a copy, taking the property of `original` and assigning them into //a fresh object const copy = { ...original } //using the spread operator console.log(copy) //{a: 1, b: 2} console.log(copy == original) //false, different objects (The Object.assign() function) is also used to do a similar operation, but the spread operator is easier to read) State vs. Props Importantly, a Component’s state is different from its props. Although state and props make look similar, they have very different roles. Many developers get the two confused—to the point that React has an FAQ entry about the difference! The key difference between props and state is: props are for information that doesn’t change from the Component’s perspective, including “initial” data. state is for information that will change, usually due to user interaction. Props are the “inputs” into a component, the values that someone else tells the Component it should. That is why the are passed in as arguments! Props are immutable—from the component’s perspective; they cannot be changed once set (though a parent could create a different version of the component with different props). State is “internal” to the Component, and is (only) for values that change over time. If the value doesn’t change over the life of the Component (e.g., in response to a user event), it shouldn’t be part of the state! To quote from the documentation: State is reserved only for interactivity, that is, data that changes over time. For example, a SortableTable component might be used to render a list of data. But as the data in the list would come from elsewhere (e.g., the overall App) and wouldn’t be changed by the table, it would be passed in as a prop. However, the order in which that data is displayed might change—thus you could save an orderBy value in the state, and then use that to organize what elements are returned by the component function. The data itself doesn’t change, but how it is rendered does! It is possible to use the props to initialize a state variable (since props are the “initial values” for the Component), though the props would not be changed later: //A component representing a count function Counter(props) { const [count, setCount] = useState(props.startAt) } let counter = &lt;Counter startAt={5} /> In this case the state variable keeps track of the count, though the prop specifies an initial number. The count variable will change in the future, but the props.startAt value will not. It’s important that you only use state to track values that will change over the life of the Component. If you’re not sure if a value should be part of the state, consider the following: Is the value passed in from a parent via props? If so, it probably isn’t state. Does the value remain unchanged over time? If so, it definitely isn’t state. Can you compute it based on any other state or props in your component? If so, it definitely isn’t state. The last of these rules is important. In general, you should keep the state as minimal as possible—meaning you want to have as little data as possible in the state. This is to help avoid duplicating information (which can get out of sync), as well as to speed up how React will “re-render” Components when the state changes. One of the most difficult parts of architecting a React application is figuring out what information should be stored in the props or state (and in which components). We suggest you practice using simple examples, and think carefully about it as you build more robust applications. Lifting Up State In React, a component state is purely internal to that component—neither the component’s parent element nor its children have access to (or are even aware of) that state. State represents only information about that particular component (and that particular instance of the component). Sometimes a child component (i.e., a component instantiated as part of the returned DOM) needs some data that is stored in the state—for example, a BlogPost component might need a data value that is stored in the Blog’s comments state variable. Components can make information available to their children by passing that data to them as a prop: function Blog(props) { const [posts, setPosts] = useState([...]) //initialize the state return ( &lt;div> &lt;h2>Most Recent Post&lt;/h2> {/* pass in values from state as a prop */} &lt;BlogPost postText={posts[0]} /> &lt;/div> ) } In this example, the BlogPost would be passed the individual “post text” data as a normal prop, without being aware that the data was actually stored in the Blog’s state. When that data changes (e.g., when a new post is added), the component function will be called again and the BlogPost component will be re-instantiated with a new value for its prop—again, without any knowledge that there was a change. From the perspective of the BlogPost, there has only ever been a single postText value (the BlogPost with a different text is actually a different BlogPost object!). While passing state data to a child (as a prop) is easy, communicating state data to a parent or sibling is more complicated. For example, you may want to have a SearchForm component that is able to search for data, but want to then have a sibling ResultsList component that is able to display the rendered results: &lt;App> &lt;SearchForm /> {/* has the data */} &lt;ResultsList /> {/* needs the data */} &lt;/App> When confronted with this problem, the best practice in React is to lift the state up to the the closest common ancestor. This means that instead of having the data be stored in the state of one of the children, you instead store the data in the state of the parent. The parent can then pass that information down to the children (as props) for them to use. This way the data always flows “down” the tree. “Lift up” the state to the closest common ancestor to share data between sibling elements But with the state stored in the parent, the children elements (e.g., the SearchForm) may still need a way to interact with that parent and tell it to change its state. To do this, you can have the parent define a function that changes its state, and then pass the child that callback function as a prop. The child will then be able to execute that callback prop, thereby telling the parent to do something (such as update its state!) It’s like the parents write down their instructions, and then hand them to the child to do later! In the following example, the parent component (VotingApp) stores state data about how many times each button has been pressed, passing a callback function (countClick) to its child Components (CandidateButton). The CandidateButton will then execute that callback when it is clicked. Executing this function causes the VotingApp to update its state and re-render the buttons, which show updated text based on the props given to them (namely: who is winning!). function VotingApp(props) { //initialize the state counts, one for each color //using a single state value so that there is only one \"update\" function const [counts, setCounts] = useState({red: 0, blue: 0}) //a function to update the state //expects a \"color\" for which button was clicked const handleCount = function(color) { console.log(color + \" got a vote!\"); const newCounts = { ...counts } //make a duplicate of the object newCounts[color]++; //update the local copy setCounts(newCounts) //update the state with the changed copy } //render based on current state let winner = \"tie\"; if(counts.red > counts.blue) winner = \"red\" else if(counts.blue > counts.red) winner = \"blue\" return ( &lt;div> &lt;p>Current winner is: {winner}&lt;/p> {/* Pass the callback to each button as a prop */} &lt;CandidateButton color=\"red\" winner={winner} callback={handleCount} /> &lt;CandidateButton color=\"blue\" winner={winner} callback={handleCount} /> &lt;/div> ); } function CandidateButton(props) { const handleClick = () => { //On click, execute the given callback function (passing in own name) props.callback(props.color) } //render based on current props let label = \"I am not winning\"; if(props.winner === props.color) label = \"I am winning!\" return ( &lt;button className={props.color} onClick={handleClick}> {label} &lt;/button> ); } As with many React systems, there are a lot of moving parts that fit together. To understand how this example works, try “tracing” the code that occurs when the CountingApp is first rendered, and then what happens when a button is clicked. Remember that calling setCounts() causes the component to be re-rendered (the function is re-run)! Finally, notice in particular that the CandidateButton class knows nothing about its parent or indeed any information about how it is used (or even if there are other CandidateButton instances). Instead, it simply renders itself based on its props, and executes whatever callback function it was given whenever it is clicked (without carrying about what that function does). Having lots of “simple” components like this is the best way to design React apps. In summary, in order to make an interactive React application, perform the following steps: Start with a “static” (non-interactive) version, with appropriate Components Identify variables that will change so need to be stored in the state Define state variables in the “lowest” common ancestor for Components that need it Pass state information to child Components as props Pass callback functions as props to child Components so they can modify the state. 16.3 Specific Interactions This section provides some details on specific types of interactions commonly used in React apps but require further details and explanation. Working with Forms One of the most common reasons to track state in a React app is when developing forms that the user can fill out to submit information. Forms are a common structure to use when getting user input—whether it’s a “search form” for browsing a data set, or a “login form” for allowing a user access to personalized data. In normal HTML, form elements such as &lt;input&gt; keep track of their own “state”. For example, whatever the user has typed into a text input will be stored in that input’s value property: //Select the &lt;input type=\"text\"> element let textInput = document.querySelector('input[type=\"text\"]'); //Event that occurs whenever the input is changed textInput.addEventListener('change', (event) => { let input = event.target; console.log(input.value); //access that elements \"state\" }); You will often want React to be able to respond to user data entered into a form—either because you want to send an AJAX request based on that data, or because you want to perform form validation and confirm that the user has entered appropriate input (e.g., that the password is at least 6 characters long). But storing the user input in the &lt;input&gt; element’s state can cause problem for React: React components won’t know that they should “rerender” when that changes, and updating a React component might cause the entire DOM tree to re-render (producing a new &lt;input&gt; element with a different value state). Thus the recommended practice for working with forms in React is to use controlled Components. In this case, you define a component that will track the state of what the user has typed into the &lt;input&gt;, and then will render an &lt;input&gt; with an appropriate value property. Rather than letting the &lt;input&gt; control its own state, the React component controls the state and then dictates to the &lt;input&gt; element what value it should be showing. It’s like React is snatching the data from the &lt;input&gt; and then claiming credit for it. function MyInput(props) { const [inputValue, setInputValue] = useState('')//initialize as empty string //respond to input changes const handleChange = (event) => { //get the value that the &lt;input> now has let newValue = event.target.value //update the state to use that new value, rendering the component setInputValue(newValue); } return ( &lt;div> {/* The input will be rendered with the React-controlled value */} &lt;input type=\"text\" onChange={handleChange} value={inputValue} /> &lt;p>You typed: {inputValue}&lt;/p> &lt;/div> ); } The above is an example of a basic controlled Component. When the user enters a different value into the &lt;input&gt; element, the handleChange() callback is executed. This grabs that updated value and saves it in the component’s inputValue state variable. Updating that state variable also causes the component to re-render, which recreates a brand new version of the &lt;input&gt; element, but now with the React-controlled value for its value attribute. This way whatever value the user has entered will always be part of a React Component’s state, and so can be manipulated and interacted with in the same manner. And of course, a controlled form might render multiple &lt;input&gt; elements, tracking the values of each one in a separate variable in the state. This also allows the inputs to easily interact with each other, such if you want to confirm that a password was entered correctly twice. Robust form validation is actually quite tricky in React (especially when compared to other frameworks such as Angular). Using an external library such as Formik can help with developing forms and handling all the edge cases. Fetching Data via AJAX One of the most common use of lifecycle callback functions is when accessing data asynchronously, such as when fetching data via an AJAX request (such a described in Chapter 14). This section provides details about how to asynchronously load data within the React framework. First, remember that React code is transpiled using Webpack. As such, some APIs—including fetch() are not “built-in” to React like they are with a modern browser. As discussed in Chapter 14, in order to support these “other” browsers, you will need to load a polyfill. You can do that with React by installing the whatwg-fetch library, and then importing that polyfill in your React code: # On command line, install the polyfill npm install whatwg-fetch //In your JavaScript, import the polyfill (loading it \"globally\") //This will make the `fetch()` function available import 'whatwg-fetch'; Remember that fetch() downloads data asynchronously. Thus if you want to download some data to display, it may take a while to arrive. You don’t want React to have to “wait” for the data (since React is designed to be fast). Thus the best practice is to send the fetch() request for data, and then when the data has been downloaded, call the a set state function to update the component with the downloaded data. (The component can initialize its state as an “empty array” of data). Fetching data from the internet is considered a side effect in React. Function components are supposed to do one thing (as well-designed “pure” functions): they return the DOM that will be rendered on the screen. But downloading data modifies something outside of that framework, in that it modifies network status/information and even the status of the remote server! Thus calling fetch() from directly inside the component function would be considered bad programming style, and can cause problems and bugs when the component is rendered. For example, if the fetched data returns too quickly or too slowly, you may try and set the state variable of (and thus rerender) a component that isn’t yet attached to the DOM, causing React to crash. And if the state does update and reruns the component, that would cause it to download the data yet again, potentially causing an infinite loop! In order to perform side effect operations in React, you need to use another kind of hook called an effect hook, provided by the React function useEffect(). An effect hook lets you hook into the lifecycle of a component, specifying some code (a function) that should be run after the component finishes rendering. Any code that will produce a side effect (such as downloading data, manipulating the DOM outside of React rendering, or setting up subscriptions to a data source) should be run through an effect hook. That’s why they’re called effect hooks: because they define a side effect to the component rendering. An example of using the event hook to download data is below, followed by an explanation of the syntax. //import the hooks used import React, { useState, useEffect } from 'react'; function MyComponent() { //store the data in a state variable, initialized as an empty array const [data, setData] = useState([]); //specify the effect hook function useEffect(() => { fetch(dataUri) //send AJAX request .then((res) => res.json()) .then((data) => { let processedData = data.filter(...).map(...) //do desired processing setData(processedData) //change the state and re-render }) }, []) //empty array is the second argument to the `useEffect()` function. //It says to only run this effect on first render //Map the data values into DOM elements //Note that this works even before data is loaded (when the array is empty!) let dataItems = data.map((item) => { return &lt;li key={item.id}>{item.value}&lt;/li>; //return DOM version of datum }) //render the data items (e.g., as a list) return &lt;ul>{dataItems}&lt;/ul>; } } Calling the useEffect() function specifies a callback function that will be run after the component renders. Things to notice about how this function is used: As with the state hook, the effect hook function useEffect must be imported (as a named import). The useEffect() function takes as an argument the callback function to run after the component renders. This is usually specified as an arrow function, though you could of course give it a named function. Note that the callback takes no arguments. Inside the useEffect() callback goes the normal fetch() call. Notice that the downloaded data is then assigned to the component’s state variable by calling the set state function (named setData() in this example). While technically it means the component is rendering twice (once without data, then once with), React can batch these requests together so that if the data downloads fast enough, the user will not notice. This is also a good reason to conditionally include DOM elements like spinners when rendering data. By default, the effect callback will be executed after each time the component renders. That means that if the component needed to re-render (because a prop changed for example), then the data would be downloaded a second time! To avoid this, you can pass the useEffect() function an optional second argument. This argument should be an array of values that the effect “depends on”—the effect will only be re-run if one of these variables changes between renders: //an effect that only re-runs if the `count` variable changes useEffect(() => { //... }, [count]) By passing an empty array as a second argument, you tell the effect that it should only re-run if one of those (non-existent) variables updates—and since there are no variables listed, it will never run a second time! The useEffect() function does not need to return any values. In fact, the only value it can return is a “cleanup” callback function, which React will run whenever the component is removed from the DOM: useEffect(() => { //... return function cleanup() { //function name is arbitrary console.log(\"component has been removed!\") } }) This is only necessary for side effects that require cleanup, such as subscribing to a data source or handling some user authentication behaviors. It is not needed for basic fetch() calls. There are a number of other hooks available in React as well. Check the documentation for details. Note that in general, you should only look into a hook if you’re hitting an architectural problem (e.g., you have a lot of repeated code)—otherwise stick with the basic structure of props and state! Resources Handling Events Using the State Hook props vs state (blog) FAQ: Component State Lifting State Up React Forms Thinking in React Hooks "],["client-side-routing.html", "Chapter 17 Client-Side Routing 17.1 Single-Page Applications 17.2 React-Router Resources", " Chapter 17 Client-Side Routing This chapter discusses how to use React to effectively develop Single Page Applications (SPA)—web applications that are located on a single web page (HTML file), but DOM manipulation (and often AJAX requests) to produce the appearance of multiple “web pages”. This structure is facilitated by the use of the client-side routing library react-router, which allows you to render different Components based on the browser’s URL, allowing each View (“page”) to be treated as a unique resource. 17.1 Single-Page Applications As you’ve seen in previous chapters, the React framework lets you dynamically render different Views (Components) based on different conditions such as the state of the app. For example, you can have a blogging app that could have a blogPostId state variable, and then use that variable to determine which blog post to display. Often these Views act as entirely separate pages—you either show one View or an another. As such, you’d often like each View to be treated as an individual resource and so to have its own URI, thus allowing each View to be referenced individually. For example, each blog post could have it’s own URI, allowing a user to type in a particular URL to see a specific post (and letting that user share the post with others). In order to achieve this effect, you can use client-side routing. With client-side routing, determining which View to display based on the URL (how to “route”, or map that URL to the correct resource) is performed on the client-side by JavaScript code. This is distinct from server-side routing, in that the server isn’t deciding which resource to show (i.e., which .html file to respond to a request with), but rather responds with a single HTML file whose JavaScript dynamically determines what resource to show (i.e., which React component to render) based on the URI that request was sent to! In this context, “routing” involves taking the resource identifier (the URI) and determining what representation of that resource should be displayed—what View to show. A “route” is thus a URI, which will refer to a particular View of the resource. Client-side routing allows you to have unique URLs for each View, but will also make the app work faster—instead of needing to download an entire brand new page from the server, you only need to download the requisite extra data (e.g., using an AJAX request), with much of the other content (the HTML, CSS, etc) already being in place. Moreover, this will all your app to easily share both state data and particular components (e.g., headers, navigation, etc). Google Drive is a good example of a Single-Page Application. Notice how if you navigate to a new folder, the URL changes (so you can link to individual folders), but only a single “pane” of the page changes. Because React applications are component-based, you can perform client-side routing in React by using conditional rendering to only render components if the current route is correct. This follows a structure similar to: function App(props) { //pick a component based on the URL let componentToRender = null; if(currentUrl === '/home'){ //pseudocode comparison with URL componentToRender = &lt;HomePage />; } else if(currentUrl === '/about'){ componentToRender = &lt;AboutPage />; } //render that component return componentToRender; } That is, if the current URL matches a particular route, then the Component will be rendered. 17.2 React-Router Third-party libraries such as React Router provide Components that include this “matching” functionality, allowing you to easily develop single-page applications. This chapter details how to use version 7 of React Router, released in November 2021. This version is significantly different from the previous versions (particularly v5). Be careful when looking up examples and resources that they’re utilizing the same version as you! For details about earlier versions of the React Router, see the documentation for those versions. Importantly, this chapter teaches how to use React Router as a library, not as a Framework. As with other libraries, you begin using React Router by installing the react-router library: npm install react-router You will then need to import any Components you wish to use into the .js files containing your React code. For example: //import BrowserRouter, Routes, Route, and Link from react-router import { BrowserRouter, Routes, Route, Link} from 'react-router' These Components are described in the following sections. Routing The &lt;BrowserRouter&gt; Component (which is often imported with an alias of &lt;Router&gt;—though there is also a &lt;Router&gt; component!) is the “base” Component used by React Router. This Component does all the work of keeping the React app’s UI (e.g., which Components are rendered) in sync with the browser’s URL. The BrowserRouter “listens” for changes to the URL, and then passes information about the current route (called the path) to its child components. This allows each child to always know what route is currently shown in the URL, without needing to access the URL directly. With React Router, a “route” is defined by the path portion of a URI (see Chapter 2). This is the part that comes after the protocol and domain (e.g., after the https://mydomain.com/). Thus the /home route would refer to the URI https://mydomain.com/home, while the /about route would refer to the URI https://mydomain.com/about. BrowserRouter utilizes the HTML5 history API to interact with the brower’s URL and history (what allows you to go “back” and “forward” between URLs). This API is supported by modern browsers, but older browsers (i.e., IE 9) would need to use &lt;HashRouter&gt; as an drop-in alternate. HashRouter uses the fragment identifier portion of the URI to track what “page” the app should be showing, causing URL’s to include an extra hash # symbol in them (e.g., https://mydomain.com/#/about). Your app will only ever have a single &lt;BrowserRouter&gt; component in it–usually at the “top level” of your application (so it would contain &lt;App&gt; as a child). Thus the &lt;BrowserRouter&gt; is usually rendered in the index.html file: //index.js import { BrowserRouter } from 'react-router-dom' import App from './components/App.js' //render the App *inside* of the BrowserRouter const root = ReactDOM.createRoot(document.getElementById('root')); root.render( &lt;BrowserRouter> &lt;App /> &lt;/BrowserRouter> ); Inside the &lt;BrowserRouter&gt; (usually inside of the &lt;App&gt;), you will define the routes for your application—the collection of supported paths and which View to show at each. You can specify route-based views using the &lt;Route&gt; Component. This component will render its element only when the current URL matches a specified path. In effect, the Route Component handles checking if the current URL matches the specified path, and if so renders its element. If the URL doesn’t match the route, then the element is not rendered. Both the path and the element are passed into the &lt;Route&gt; as props: function App(props) { return ( &lt;Routes> {/* the collection of routes to match */} {/* if currentUrlPath === \"home\" */} &lt;Route path=\"home\" element={&lt;HomePage />} /> {/* if currentUrlPath === \"about\" */} &lt;Route path=\"about\" element={&lt;AboutPage />} /> &lt;/Routes> ); } Points to notice about this example: The path prop is used to indicate the route that you wish to match—in particular, matching to the path part of the URL (after the domain). You do not include http or domain.com in the path. The “root” segment \"/\" is used to match to a URL without a path (e.g., what to show at http://domain.com). Using a wildcard * in the path will match to “anything”, and is good for rendering “Page Not Found” elements. The path can include multiple segments (e.g., assignments/react); however multiple segments usually correspond to nested routes, described below. The Component (View) to render is passed in as the element prop. You instantiate the component using &lt;Component/&gt; syntax, and then that is passed as the inline expression (inside the {}). Yes, it makes the syntax look awkward. You can of course pass additional props to the rendered component as normal: &lt;Route path=\"profile\" element={&lt;ProfilePage user={userData} />} /> While it is possible to pass nested elements as the element property, that can quickly become a readability nightmare. Better practice is to define a single “wrapper” Component to be rendered at the Route. All &lt;Route&gt; elements are made children of a single element called &lt;Routes&gt; (note the s makes it plural!). The &lt;Routes&gt; element represents the “collection” of Routes that the Router needs choose between when deciding what Component to render (if any). You can think of it as acting like a switch statement. In practice, you will have a single &lt;Routes&gt; element in your page, usually in a top-level component such as &lt;App&gt;. Note that a &lt;Routes&gt; can only have &lt;Route&gt; elements as children, and a &lt;Route&gt; element can only be the child of a &lt;Routes&gt;. They go together, and nothing else (no other &lt;div&gt;, etc. elements) can come between them. Though see Nesting Routes before for details on integrating different DOM layouts with your routing. Nesting Routes In the above example, the Route’s path prop corresponds to a single segment of the URI path. Many React apps will want to differentiate the rendered content based on multiple segments. For example: the /user/profile path might show a &lt;UserProfile&gt; component, while the user/favorites path might show a &lt;FavoriteItems&gt; component (with the list of items the user has marked). Yet both of these paths might also want to show content shared by all Views that are part /user paths (but different from other non-user-specific paths, such as the /items path). React Router supports this behavior by nesting routes—having one &lt;Route&gt; element be the child of another. For example: // An example of nested routes &lt;Routes> &lt;Route path=\"user\" element={&lt;UserLayout />} > &lt;Route path=\"profile\" element={&lt;UserProfile />} /> &lt;Route path=\"favorites\" element={&lt;FavoriteItems />} /> &lt;/Route> &lt;Route path=\"items\" element={ &lt;ItemList />} /> &lt;/Routes> When the &lt;Routes&gt; element goes to match a URL and determine which element to render, it will start with with the first segment of the path, rendering that element. For example, if the path starts with /user, then the Router will render the &lt;UserLayout&gt; element. But it will then continue checking further segments of the path: so if the path is /user/profile, then the Router will render the &lt;UserLayout&gt; (for the /user part), but then render the &lt;UserProfile&gt; (for the /profile part) inside of the &lt;UserLayout&gt; at an indicated location. Thus you could view the above Routes as defining the following paths: /user/profile renders &lt;UserLayout&gt;&lt;UserProfile/&gt;&lt;/UserLayout&gt; /user/favorites renders &lt;UserLayout&gt;&lt;UserFavorites/&gt;&lt;/UserLayout&gt; /user renders &lt;UserLayout&gt;&lt;/UserLayout&gt; (no child) /items renders &lt;ItemList /&gt; (You can think of each “nested child” step as a / in the path) You specify where in the parent element the child element will render using an &lt;Outlet&gt; Component. This component will be replaced by the element of whichever child route matches the URL segment: function UserLayout(props) { render ( &lt;div className=\"user-layout\"> &lt;h1>User Page&lt;/h1> {/* will be replaced with &lt;UserProfile>, &lt;UserFavorites>, or null */} &lt;Outlet /> &lt;/div> ) } Thus you can think of the &lt;Outlet /&gt; as the “place the child component will go”. Nested routes are primarily used to create shared layouts, as in the example above. The &lt;UserLayout&gt; component can contain structure elements (like divs) that will be shared across routes that begin with the same segment, but not other routes. Not all apps require nesting routes! If your entire app has a single layout, you don’t need to create a separate Component for that; you can just render it as part of your &lt;App&gt; and use the &lt;Routes&gt; to specify the dynamic content. Similarly, remember that Routes are only for conditionally rendering a Component based on the URI. If you want to conditionally show content (e.g., depending on whether the user is logged in, or based on what item has been selected), you use conditional rendering based on the state—don’t use a Route! If you wish to show a “default” child Component when there is no further segment, you can give the child Route the index prop: &lt;Routes> &lt;Route path=\"user\" element={&lt;UserLayout />} > {/* show the UserHome at ``/user` */} &lt;Route index element={&lt;UserHome />} /> &lt;Route path=\"profile\" element={&lt;UserProfile />} /> &lt;Route path=\"favorites\" element={&lt;FavoriteItems />} /> &lt;/Route> &lt;/Routes> Notice that the index prop (which takes no other values!) in effect “replaces” the path segment for that child. It is often useful to specify the routes as a const variable (e.g., routes) that is an object containing paths and which component to render for that path. You can use the useRoutes() hook to then render this object instead of specifying a &lt;Routes&gt; element. This is only recommended for particularly large applications. You can use the useMatch() hook to get access to the current path; this can be useful for specifying e.g., relative image paths. URL Parameters It is also possible to include variables in the matched route using what are called URL Parameters. As you may recall from reading a RESTful API, URI endpoints are often specified with “variables” written using :param syntax (a colon : followed by the parameter name). For example, the URI https://api.github.com/users/:username from the Github API refers to a particular user—you can replace :username with any value you want: https://api.github.com/users/joelwross refers to the joelwross user (so username = 'joelwross'), while https://api.github.com/users/mkfreeman refers to the mkfreeman user (so username = 'mkfreeman'). React Router supports a similar syntax when specifying Route paths. For example: &lt;Route path='posts/:postId' element={&lt;BlogPost />} /> will match a path that starts with posts/ and is followed by any other path segment (e.g., post/hello, post/2022-10-31, etc). The :postId (because it starts with the leading :) will be treated as a parameter which will be assigned whatever value is part of the URI in that spot—so post/hello would have 'hello' as the postId, and post/2017-10-31 would have '2017-10-31' as the postId. You can access the values assigned to the URL parameters by using the useParams hook provided by react-router. This hook returns an object whose keys are the parameter names and whose values are the param values: import { useParams } from 'react-router-dom'; function BlogPost(props) { //access the URL params as an object //it's also common to use object destructuring here const urlParams = useParams(); return ( {/* postId was the URL parameter from the above example! */} &lt;h1>You are looking at blog post {urlParams.postId}&lt;/h1> ) } In the above BlogPost component, the urlParams value will be an object containing different values depending on the route: If the element is rendered by &lt;Route path=\"posts/:postId\" element={&lt;BlogPost /&gt;} /&gt;, then visiting posts/hello will cause urlParams to be the object {postId: \"hello\"} visiting posts/2022-10-31 will cause urlParams to be the object: {postId: \"2022-10-13\"} If the element is rendered by &lt;Route path=\"posts/:date/:title\" element={&lt;BlogPost /&gt;} /&gt;, then visiting posts/2022-10-31/Hello will cause urlParams to be the object {date: \"2022-10-31\", title: \"Hello\"} (note the multiple values for the multiple parameters!) If you want to work with query parameters (e.g., the ?key1=value1&amp;key2=value2 part of the URL), you can use the useSearchParams() hook. This works similar to the useState() hook, except that the value will be stored in the URL query parameter rather than in the Component’s state. Note that query parameters should only be used for values such as search queries that don’t correspond to a consistent resource. Linking While specifying &lt;Route&gt; elements will allow you to show different “pages” at different URLs, in order for a Single Page Application to function you need to be able to navigate between routes without causing the page to reload. Thus you can’t just use normal &lt;a&gt; elements to link between “pages”—browsers interpret clicking on &lt;a&gt; elements as a command to send a new HTTP request, and you instead just want to change the URL and re-render the App. Instead, React Router provides a &lt;Link&gt; element that you can use to create a hyperlink to another route within the application. This component takes a to prop that you use to specify the route that it links to: &lt;Link to=\"about\">Click to visit the About Page&lt;/Link> The component will render as an &lt;a&gt; element with a special onClick handler that keeps the browser from loading a new page. Thus you can specify any content that you would put in the &lt;a&gt; (such as the hyperlink text) as child content of the &lt;Link&gt;. Importantly: a &lt;Link&gt; is a replacement for an &lt;a&gt; element—do not try to put one inside of the other! A to property that is relative path (so doesn’t have a starting /) will resolve relative to its parent route. Thus you can use .. to refer to the parent route as you would with any other relative path. React Router also provides a &lt;NavLink&gt; Component. This works exactly like the &lt;Link&gt; component, except if the to route matches the current route, then the element will have the active CSS class added to it. This is used for example to have a navigation section “highlight” the link to the page you’re currently on, helping the user understand where they are on the page. It’s also possible to specify a callback function if you wish to use a custom name for the “active” class; see the documentation for an example (watch out of the ternary operator). Redirecting In addition to &lt;Link&gt; elements that allow the user to navigate by clicking an element, React Router also provides functionality to programmatically navigate through routes. The primary tool for this is the useNavigate() hook. This hook, when called, will provide a function (conventionally named navigate) that can be called to redirect the App—to change the URL without reloading the page (and thus cause the Routes to re-render): import { useNavigate } from 'react-router-dom'; //A simple form component function Form(props){ const navigate = useNavigate(); //access navigate function //event handler for the form const handleSubmit = function(event) { event.preventDefault(); //do form submission work here navigate(\"/home\") //navigate to the `/home` route } return ( &lt;form onSubmit={handleSubmit}> ... &lt;/form> ) } The navigate() function takes an an argument the same stying you would use as the to prop for a &lt;Link&gt; element. You should only use the navigate() function when non-navigation actions (such as form submissions) need to cause redirections. If the user is clicking on an element to navigate, just embed that element in a &lt;Link&gt;—that will keep your page accessible. Additionally, only call navigate() from inside of an event handler; don’t use it in the body of a Compnent function—use a &lt;Navigate&gt; element. Alternatively, you can cause the route to change by rendering a Navigate element. This element accepts a to prop just like a &lt;Link&gt;, and when rendered will redirect the user as if the link were clicked without the user doing anything. To be clear: you need to render the &lt;Navigate&gt; element—to return it from a Component as the DOM to render. So instead of a component returning e.g., &lt;div&gt;, you would have it return a &lt;Navigate&gt;. Thus you would use this element with conditional rendering, using an if statement to determine whether you want to return/show regular DOM content or instead return a &lt;Navigate&gt; to redirect. DO NOT render a &lt;Navigate&gt; as the child of displayed content (e.g., inside a &lt;div&gt;), as this can cause issues with the redirect taking multiple “DOM update cycles” to process, interfering with your application’s processing. Instead, determine whether you should redirect and if so return just the &lt;Navigate&gt; element (e.g., with a “break early” sentinel condition). &lt;Navigate&gt; elements are particular useful when creating “protected routes”—routes that are only accessible under certain conditions (such as if the user is logged in). To do this, you have the Route’s element include an if statement to determine whether it should display content, or if it instead should show the &lt;Navigate&gt; and this redirect: function ProtectedPage(props) { //...determine if user is logged in (eg., via AJAX) if(!userIsLoggedIn) { //if no user, send to sign in return &lt;Navigate to=\"/signin\">; } //otherwise show content return ( &lt;div>protected content!&lt;/div> ) } A nice strategy is to combine the above logic with a nested route, allowing you to re-use authentication logic across your app: function RequireAuth(props) { //...determine if user is logged in (eg., via AJAX) if(!userIsLoggedIn) { //if no user, send to sign in return &lt;Navigate to=\"/signin\">; } else { //otherwise, show the child route content return &lt;Outlet /> } } function App(props) { return ( &lt;Routes> {/* protected routes */} &lt;Route element={&lt;RequireAuth />}> &lt;Route path=\"profile\" element={&lt;ProfilePage />} /> &lt;Route path=\"secret\" element={&lt;SecretPage />} /> &lt;/Route> {/* public routes */} &lt;Route path=\"signin\" element={&lt;SignInPage />} /> &lt;/Routes> ) } The Route rendering the &lt;RequireAuth&gt; has no defined path, defaulting to \"\" (thus not providing a segment to consider). So if its child route are matched, that component will render, and either use the &lt;Navigate&gt; to redirect to a public route, or to show the child route element in place of the &lt;Outlet&gt;. This structure lets you keep your protected routes organized, while keeping all of your “user is logged in” logic in a single location. React Router and Hosting React Router’s client-side routing introduce a few additional considerations when the you wish to deploy your app on a non-development server, such as Github Pages (e.g., what happens when you deploy a Vite project). First, consider what happens when you type a route (e.g., https://domain.com/about to access the /about route) into the browser’s URL bar in order to navigate to it. This creates an HTTP Request for the resource at the URI with an /about path. When that request is received by the web server, that server will perform server-side routing and attempt to access the resource at that location (e.g., it will look for an /about/index.html page). But this isn’t what you want to happen—because there is no content at that resource (no /about/index.html), the server will return a 404 error. Instead, you want the server to take the request for the /about resource and instead return your root /index.html page, but with the appropriate JavaScript code which will allow the client-side routing to change the browser’s URL bar and show the content at the /about route. In effect, you want the server to be able to return your root index.html page no matter what route is specified in the HTTP Request! It is perfectly possible to have a web server do this (to not perform server-side routing and instead always return /index.html no matter what resource is requested); indeed, this is what the Create React App development server does. However GitHub Pages doesn’t have this functionality: if you send an HTTP request for a resource that doesn’t exist (e.g., /about), you will receive a 404 error. There are a few ways to work around this: You can use a &lt;HashRouter&gt; instead of a &lt;BrowserRouter&gt; The &lt;HashRouter&gt; uses the fragment identifier portion of the URI to record and track which route the user is viewing: the HTTP request is thus sent to https://domain.com/index.html#/about to get the /about route—and since index.html is the default resource, this can be abbreviated to https://domain.com/#/about, which is almost as good. In this way you are always requesting the appropriate resource (/index.html), but can still perform client-side routing. The trade-off is that your URLs will have extraneous # symbols in them (which also makes utilizing inner-page navigation with the fragment more difficult), and going to domain.com/about will still cause a 404 error. It’s recommend that you avoid this element if possible. Another approach is to replace your server’s 404 page with something that goes to your index.html (using server-side routing)—so instead of the user being shown the 404, they are shown your index.html which is about to do the client-side routing! spa-github-pages provides some boilerplate for doing this with GitHub Pages, but it is a “hacky” approach and so is also not recommended. The best and correct approach is to use a web hosting system that better supports the server-side routing needed for single-page applications. For example, Firebase Hosting allows you to specify a rewrite rule that will cause the server to return your index.html no matter which route the HTTP Request specifies. Create React App provides instructions on deploying to Firebase Hosting, including a simple wizard configuration that allows you to configure your site as a single-page application. Resources React Router Documentation - includes tutorials and examples React Router API - complete list of Components and hooks "],["ajax.html", "Chapter 18 AJAX Requests 18.1 AJAX 18.2 Fetching Data 18.3 Asynchronous Programming Resources", " Chapter 18 AJAX Requests JavaScript allows you to dynamically define the content of a web page, generating the DOM at runtime rather than in .html source files. One of the primary reasons we would want to dynamically produce a DOM is if the web page’s content is based on some data that may change over time: for example, the kind of data that is available through a Web API. By using JavaScript to render the DOM, you can quickly produce large amounts of HTML needed to display large data sets, sure that you have up-to-date data each time the page loads, and even automatically refresh the page content without requiring the user to reload! This chapter describes how to use JavaScript to dynamically send HTTP Requests to download data (without reloading the page!), as well as how to perform the asynchronous programming needed when working with web requests and other time-consuming operations. Note that this lecture assumes that you have a basic familiarity with RESTful Web APIS, including how to read and access their endpoints. For a review of some of the terminology used in APIS and RESTful requests, see the INFO 201 course reader. 18.1 AJAX As discussed in Chapter 2, you download data from the Internet by sending an HTTP Request and then processing the response. In everyday usage, HTTP Requests are normally sent by the browser when the user enters a URL or clicks on a link. By default, if you wanted to download new data, you’d need to have the browser send a new request, loading a new page (or reloading the current page) in order to show that result. To make modern dynamic web pages that display new data without needing to refresh the browser, we use a technique to send HTTP Requests from JavaScript code rather than from the browser. This allows us to “by-pass” the browser and get new data (and change the webpage) without reloading it! This technique is referred to as AJAX (Asynchronous JavaScript And XML)—we write code that sends an “request with AJAX” or an “AJAX request”. Fun fact: The technology used to send AJAX requests was originally developed by Microsoft in the late 90s to support their fledgling web version of the Outlook email/calendar app. The JavaScript functions used to send these requests were included in Internet Explorer as a non-standard feature—an example of a browser adding new functionality that it thinks will be useful but that doesn’t work on other platforms. However, AJAX quickly gained popularity (particularly when Google showed off what you could do with it via Gmail and Google Maps), and has since become a standard that is now supported by all browsers. This is how standards come into existence! XML and JSON AJAX is called “AJAX” because it was originally designed to request data in XML format. XML (EXtensible Markup Language) is a markup language (like HTML) that is used to encode meaning in content in a format that is both human and computer readable. The syntax for XML is exactly the same as HTML: in fact, HTML can be seen as a “subset” of the language. You can think of XML as “HTML, but you get to make up your own element names!” &lt;!-- Some XML encoding information about a person --> &lt;person> &lt;firstName>Alice&lt;/firstName> &lt;lastName>Smith&lt;/lastName> &lt;favorites> &lt;music>jazz&lt;/music> &lt;food>pizza&lt;/food> &lt;numbers> &lt;item>12&lt;/item> &lt;item>42&lt;/item> &lt;/numbers> &lt;/favorites> &lt;/person> The XML language does not define any particular tags the way HTML does; instead it is up to individual applications to determine what tags it will recognize and interpret (and what tags it would see as gibberish)—what is referred to as a XML Schema. At the time AJAX was first developed, XML was the most common way of encoding generic data for transmission. And because XML is a tree of elements just like the DOM, similar methods could be used to navigate and extract information from the tree. However, XML is a very verbose language: it requires a lot of characters to encode information (meaning that the amount of data being transferred is larger), and traversing an element tree requires a lot of code. As such, JavaScript developers (led by Douglas Crockford) developed an alternative language called JSON (JavaScript Object Notation) that is more compact than XML and can be directly parsed into JavaScript objects and arrays: { \"firstName\": \"Alice\", \"lastName\": \"Smith\", \"favorites\": { \"music\": \"jazz\", \"food\": \"pizza\", \"numbers\": [12, 42] } } JSON format uses a syntax that is almost identical to that for defining Object literals in JavaScript, with a few key differences: JSON always defines an Object {} at the “top level”. JSON object keys (which must be strings) must be written in double-quotes. JSON values can only be strings, numbers, booleans (true or false), arrays ([]), or other objects. You cannot include a function in JSON. JSON objects and arrays can’t have trailing commas or other extraneous symbols—no comments! The JavaScript language provides a global object JSON (like the global Math object) that can be used to convert from encoded strings of JSON content (e.g., the above code block as a single string variable '{\"firstName\":\"Alice\"}') to JavaScript objects, and vice versa: //convert from Object to encoded String let personObj = {firstName:\"Alice\", lastName:\"Smith\", id:12} //JavaScript object let personString = JSON.stringify(personObj); //turn object into JSON string console.log(personString); //=> '{\"firstName\":\"Alice\",\"lastName\":\"Smith\",\"id\":12}' console.log(typeof personString); //=> 'string' //convert from encoded String to Object let favoritesString = '{\"music\":\"jazz\", \"numbers\":[12,42]}'; //a string, not an object! let favoritesObj = JSON.parse(favoritesString); //turn JSON string into object console.log(favoritesObj); //=> { music: 'jazz', numbers: [ 12, 42 ] } console.log(typeof favoritesObj); //=> 'object' Note that if your JSON string is not properly formatted (e.g., you’re missing a quote), the JSON.parse() function will throw a SyntaxError. The exact error in the JSON string can be hard to find; online tools can help show the problem. JSON has replaced XML as the encoding of choice for working with AJAX requests—however, the technique is still referred as “AJAX” (“AJAJ” isn’t as easy to say!) 18.2 Fetching Data AJAX support is built into browsers through the included XMLHttpRequest global variable (the “xml http thing”). This object provides functions that allow you to send an HTTP request to the server, but the object’s API is really complex to use: An example XMLHTTPRequest //create a new XMLHttpRequest object let request = new XMLHttpRequest(); //configure it to do an HTTP GET request for some URL request.open('GET', 'https://domain.com/data', true); //add a listener for the \"load\" event (when the data has been downloaded) request.addEventListener('load', function() { if (request.status >= 200 &amp;&amp; request.status &lt; 400) { //check response status let data = JSON.parse(request.responseText); console.log(data); //do something with the data } }); //listen for \"error\" events if there was a network error request.addEventListener('error', function() { //handle error... }) //finally, send the request to the server! request.send(); Instead of needing to understand all that code, developers tended to use functions from external libraries such as jQuery’s $.getJSON() or $.ajax(): $.getJSON('https://domain.com/data', function(data) { //`data` is the already-parsed JSON data console.log(data); //do something with the data }); But this requires including the jQuery library in your page, and since the need for jQuery is rapidly going away, other options are now built in to modern browsers. In particular, we will utilize the fetch() API to easily send AJAX requests for data! fetch() is an recent standard, so that it is not supported by older browsers (e.g., Internet Explorer. However, we can still use fetch() with these browsers by including a polyfill—an external library that replicates an existing API in platforms that don’t support it! The fetch() polyfill will provide a fetch() function to browsers that don’t provide it (leaving other browsers unchanged) that uses the existing XMLHttpRequest without you needing to interact with that object. It’s easiest to just load the polyfill from a CDN: &lt;!-- put this BEFORE your own script! --> &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.3/fetch.min.js\">&lt;/script> The fetch() function makes it easy to send a request: simply call it and pass in the URL of the data you wish to download: fetch('https://domain.com/data'); In some browsers, you will not be able to send an AJAX request when the web page is loading via the file:// protocol (e.g., by double-clicking on the .html file). This is a security feature to keep you from accidentally running an HTML file that contains malicious JavaScript that will download a virus onto your computer. Instead, you should run a local web server such as live-server for testing AJAX requests. Remember to always use a relative path when specifying what file or API you wish to fetch. Moreover, paths are always relative to the .html file that the user is currently viewing, not to the .js file that contains the fetch() call. So be careful if your JavaScript is in a different folder; the path needs to be relative to the HTML (which should be in the root of your project). 18.3 Asynchronous Programming However, the fetch() function does NOT directly return the data you want to download! Downloading data off the internet can take a long time: the network connection may be slow and the amount of data to download may be quite large (metadata for the latest 100 tweets from Twitter involves almost 500k of JSON content). Because fetching data may take time, AJAX requests are made asynchronously (that’s the “A” in AJAX)—the download will occur at the same time that the rest of the code is being executed. Thus the download and the remaining script will not be synchronized; they will be “asynchronous”. console.log('About to send request'); //statement 1 //send request for data to the url fetch(url); //statement 2 console.log('Sent request'); //statement 3 //The data is actually received sometime later, //when the JS interpreter is down here! In the above example, the JS interpreter will execute statement 1, then statement 2 (the fetch() call). It will then precede immediately to statement 3 (the second console.log), without waiting for the request to finish! The download will continue to occur in the background, and will finish at some point later in the program—though we don’t know exactly when. It is best to think of fetch() as a function that will just “start to download data”, not one that actually downloads data! Because fetch() is an asynchronous function (it’s code is run asynchronously), it returns what is called a Promise. A Promise is object that holds a value which may not be available yet—you can think of a Promise as like a placeholder where the result of the asynchronous function call will eventually be stored (it is a “promise” to eventually have some data, though that promise may be kept or broken!). Promises are the modern way of handling asynchronous functions, but as part of the ES6 standard they are not yet available to all browsers (specifically: Internet Explorer). So you’ll need to include another polyfill to support IE. This is also available from a CDN. Promises have three possible states: pending (the data is downloading), fulfilled (the data has finished downloading), or rejected (the data failed to download and the promise was “broken”). We are able to specify callback functions (similar to event listeners) that occur when a pending Promise is either successfully fulfilled or has been rejected. The “on success” callback function is specified by calling the .then() function on the Promise object, and passing the “on success callback” as a parameter: function onSuccessCallback(response) { //what to do when we get the response console.log(response); } //When fulfilled, execute the callback function (which will be passed the response) let promise = fetch(url); promise.then(onSuccessCallback); //It is much more common to use anonymous variables/callbacks: fetch(url).then(function(response) { console.log(response); }); The “on success” callback will be passed a single parameter: the data value that the Promise was made for (e.g., the data that will eventually be downloaded from fetch()). So when the callback is executed, you will have access to the data! For example, when the fetch() Promise is fulfilled, it will pass an object representing the response to the HTTP Request: let promise = fetch(url); promise.then(function(response){ console.log( response.url ); //a string of where the request was sent console.log( response.status ); //the HTTP status code (e.g., 200, 404) }); This response object does have a body property that represents the “body” (data content) of the HTTP response. However, that body stored as a “stream” of 0s and 1s, not as a JavaScript object (or even a string you can JSON.parse())! In order to get the body into a format you can use, you will need to “encode” it into a JavaScript object by calling the .json() method on it. There is also an equivalent .text() method to encode a response body into plain text. Chaining Promises But there’s a catch: the “encoding” process performed by the .json() might take some time (particularly for a large amount of data). So instead of blocking (pausing) the rest of your program while that encoding occurs, the .json() method returns another Promise as a placeholder for when the encoded body is available! So you will then need to specify a .then() callback for that Promise as well. However, a Promise’s .then() function has a neat property that makes this easy to do. Calling the .then() function on a Promise returns a new Promise as a placeholder for any data produced by the .then() function. This promised data will be whatever value is returned by the “on success” callback function. This allows you to in effect “chain” .then() calls together, each of which can perform some kind of transformation on the data: function makeQuestion(dataString) { //a function to make a string a question return dataString + '???'; } //image a hypothetical asynchronous function `getAsyncString` //it returns a Promise (placeholder) for a string load from a given source let originalPromise = getAsyncString(myDataSource); //when the original promise is fulfilled, call `makeQuestion` on it //`questionPromise` will be a placeholder for that transformed data let questionPromise = originalPromise.then(makeQuestion); //when the `questionPromise` is fulfilled, call an anonymous callback on it //the callback will be passed the transformed (\"question\") data questionPromise.then(function(data){ console.log(data); //data will be a question! }) More commonly, we use anonymous variables for subsequent promises, allowing you to chain them together in a way that almost reads like English! getAsyncString() .then(makeQuestion) .then(function(data){ console.log(data); }); But wait there’s more! .then() also has a special feature where if the “on success” callback function returns a Promise (rather than another kind of value), then the “outer” promise will take on the state of that new returned Promise. This means that you can just return a Promise from inside a .then() callback, and that Promise will be the subject of the subsequent .then() call: let outerPromise = getAsyncString(myFirstSource).then(function(firstData){ //do something with `firstData` let newPromise = getAsyncString(mySecondSource); //a second async call! return newPromise; //return the promise. }); //`outerPromise` now takes on the state and data of `newPromise` outerPromise.then(function(secondData){ //do something with `secondData`, the data downloaded from `mySecondSource` }); Going back to fetch() to bring it all together: since the .json() encoding function returns a Promise, you can simply return that Promise from the .then() callback in order to make it available to subsequent .then() calls! fetch(url) //start the download .then(function(response) { //when done downloading let dataPromise = response.json(); //start encoding into an object return dataPromise; //hand this Promise up }) .then(function(data) { //when done encoding //do something with the data!! console.log(data); //will now be encoded as a JavaScript object! }); This code example will allow you to download data and encode it into a plain old JavaScript object that you can work with. Handling Errors When downloading data from the internet, it is always possible that the HTTP request may fail. The request may be sent to the wrong URL, the client computer may be having connection problems, or the receiving server may be having problems. In order to deal with inevitable errors, Promises provide a .catch() method that is used to specify a callback that should occur if the Promise is rejected (an error occurs). This callback function will be passed an Error object that contains details about the error. fetch(url) .then(function(response) { //when done downloading return response.json(); //second promise is anonymous }) .then(function(data) { //when done encoding //do something with the data!! console.log(data); //will now be encoded as a JavaScript object! }) .catch(function(err) { //do something with the error console.error(err); //e.g., show in the console }); Importantly, the .catch() method will “catch” errors from all previous Promises in a .then() chain! This means that the above .catch() will show both errors in the downloading (.fetch()), and errors in the body encoding (.json()). You will almost always want to show the error to the user in some way, such as by creating an alert element in the DOM. The .catch() function also returns a Promise, so you can continue to chain .then() calls after it. These later callbacks will only be executed if no previous Promise has been rejected (that is, there haven’t been any errors yet). Important: a Promise will only be rejected if there is an actual “Error” in sending the request. If the server replies with a 401 error (e.g., you didn’t have permission to access the resource) or just the message “invalid API key”, that won’t be handled by .catch(). From JavaScript’s perspective, the request went through perfectly—it’s not fetch’s fault that the data you asked for wasn’t what you actually wanted! You can use the response.status and response.ok properties to check the status of the HTTP response. As such, you will want to make sure to handle things like bad responses or unexpected response bodies, both in testing your application (to make sure the request is sent to the correct URL) and when handling any user input. Other Data Formats The above usage of fetch() works well for data formatted in JSON (which is the most common format for web-accessible data). However, you may wish to dynamically load data that is presented in a different format, such as plain text or as comma-separated values (CSV). There are a few ways to support this: For downloading plain text formatted data, you can use the fetch() method as above, but instead of calling .json() on the response to encode it as a JavaScript object, you can call the .text() method to encode it as a basic string: fetch(url) //start the download .then(function(response) { //when done downloading let dataPromise = response.text(); //start encoding into a String return dataPromise; //hand this Promise up }) .then(function(text) { //when done encoding //do something with the text data!! console.log(text); //will now be encoded as a JavaScript string! }); Encoding as text will support any plaintext formated data—whether from a .txt file, a .csv file, or even a .json or .js file! In fact, if you encode JSON data as plain text using the .text() method, you could then explicitly parse that into a JavaScript Object by using the built-in JSON.parse() function described above! While the .text() method will you encode data into a JavaScript String, that String will often have a particular format that needs to be parsed (interpreted) in order to make the data useful. For example, a String in CSV format is not very useful on its own; you would need to parse it into an array of objects (where each object represents a row) to analyze the data. It is possible (but complex) to do this parsing using built-in String functions (assuming your CSV data matches official standards), but in general it’s easier and more effective to use an external library to do this parsing. One of the best libraries for doing this work is d3.dsv(), a component of the d3 visualization library. d3.fetch() provides convenience wrapper functions for fetch() that also perform effective data parsing. In order to use d3.fetch(), you will need to load it as an external library: &lt;script src=\"https://d3js.org/d3-dsv.v1.min.js\">&lt;/script> &lt;script src=\"https://d3js.org/d3-fetch.v1.min.js\">&lt;/script> (More details coming soon…) Resources An Introduction to AJAX for Front-End Developers (tuts+) An Introduction to fetch() (Google) JavaScript Promises: an Introduction (Google) "],["firebase.html", "Chapter 19 Firebase 19.1 Setting up Firebase 19.2 Realtime Database 19.3 User Authentication 19.4 Firebase Storage Resources", " Chapter 19 Firebase This chapter discusses how to integrate and use the Firebase web service in a client-side application (using React). Firebase is a web service that provides tools and infrastructure for use in creating web and mobile apps that store data online in the cloud (a “web backend solution”). In effect, Firebase acts as a server that can host information for you, so that you can just build client-side applications without needing to program a web server. Firebase is owned and maintained by Google, but will still work perfectly fine with Facebook’s React framework. In particular, this chapter will discuss the following features of Firebase: The Firebase service also provide a number of “database” systems. This chapter describes how to use the realtime database, which provides a simple NoSql-style database: you can think of it as a single giant JSON object in the Cloud. Firebase provides methods that can be used to refer to this object and its properties, make changes to the object. Most importantly, it provides the ability to “listen” for changes made by others so that the page can automatically update based on actions taken by other users. In effect you can create a data binding between clients and the server, so that if you update data on one machine, that change automatically appears on another. Firebase also offers additional database structures. Firestore is another NoSQL (document-based) database, but focused more on one-time data fetch queries rather than the continuous data binding provided by the realtime database. This chapter focuses on the Realtime Database as an easier-to-learn system and to practice data binding. Firebase Storage is used for storing larger data elements (anything that can’t be defined in JSON), such as images or videos, and is described at the end of the chapter. The Firebase service also offers a client-side based system for performing user authentication, or allowing users to “sign in” to your application and have particular information associated with them. It’s possible to have users sign up with an email and password, or even using an external service (e.g., “sign in with Google”). Firebase also provides a way to manage all those extra interactions associated with accounts, like being able to reset passwords or confirm email addresses. And this is all performed securely from the client-side, without the need to set up an additional server to perform OAuth work. These features mean that Firebase can be a go-to back-end for producing a client-side app that involves persisted data (like user accounts). And its free service tier is well-suited for any development app. This chapter details how to use version 9+ of the Firebase library, released in August 2021—and in particular its modular API (which allows for smaller and more efficient bundles when using webpack and React). Note that while this version is conceptually the same as previous versions, the module syntax for calling and importing functions is different. See the upgrade guide for details. Be careful when looking up examples and resources that they’re use the same version as you! Note that Firebase also provides Firebase Hosting for hosting and serving web applications. This is particularly useful for hosting single-page-applications, such as those built with React Router. Hosting does not require any modifications to your source code, so is not discussed here. 19.1 Setting up Firebase Because Firebase is a cloud service, you will need to set it up externally in order to use it in your web application. Firebase setup and configuration is handled on Firebase’s website at https://firebase.google.com/, and in particular in the Firebase Web Console where you can manage individual projects. When developing a Firebase app, keep the Web Console open all the time so you can check on database, user list, etc! Creating a Project In order to use Firebase in your web app, you will need to sign up for the service. Visit https://firebase.google.com/ and click the “Get Started” button to do so. You will need to sign in with a Google account (e.g., a UW account if you’ve set up Google integration). Signing up will direct you to the Firebase Web Console. In the Web Console, you can manage all of your “projects”—one per application you’ve created (think: per repository). Each project will track its own database of information, its own set of users, etc. You can create a project by clicking the “Add Project” button. On the next screen, you’ll need to give the app a unique name. Naming the project after your app is a good idea. This name is used internally by the Firebase syste; it won’t necessarily be visible to your users, though if you use Firebase Hosting then the project name will be part of the default URL for the application. Recommendation: do not enable Google Analytics for your projects! Once you’ve created the project, you will be taken to the Web Console for that project. This is a web page where you will be able to manage the configuration of the project, the users who have signed up, and any data in the database. In particular, note the navigation menu on the left-hand side: you will use this to access different parts of your project (Realtime Database to manage the database, and Authentication to manage users)—expand the “Build” dropdown to navigate. Firebase navigation menu Including Firebase in React In order to use Firebase in a web app (including a React app), you will need to add the Firebase library to your web page, as well as some specify some configuration data to connect to the correct Firebase project. From the project’s Web Console page, click the button (it look like a &lt;/&gt; in the above image) to add Firebase to a web app. This will take you to a new page where you’ll need to put in a nickname for the app and then present some JavaScript code for loading the Firebase library (make sure that “Use npm” is selected—you don’t want to include a &lt;script&gt; element!). In a React app you you will integrate Firebase directly into your source code by modifying the index.js file: First, install and Firebase library using npm: # Note: do this in your app's repo (the folder with the `package.json` file) npm install firebase Then, copy the provided import statement, firebaseConfig variable, and initializeApp() function call into your index.js file. This will specify which Firebase project your web app should connect to whenver you call functions to access Firebase. Note that you will need to paste this code before the call ReactDOM.render(). The index.js file will often contain such configuration data that is relevant to the app rather than to a specific component. Adding Collaborators to a Project Referencing the Firebase Web Console is vital for everyone who is working with the Firebase backend on a project. If you’re working with a group of developers, you will want to make sure that all team members have access to this console. You can add additional team members to a Firebase project by selecting “Users and permissions” from the “Project Overview” gear icon: Users and permissions navigation From there you can click on “Add Member” to add new members to the project. 19.2 Realtime Database The Firebase web service provides a realtime database for storing and accessing data in the cloud. You can think of this database as being a single giant JSON object in the Cloud that can be simultaneously accessed and modified by multiple clients—and since each client reads the same database, changes made by one user will be seen by others as real-time updates. For example, you might have a database that is structured like: { \"people\" : { \"amit\" : { \"age\" : 35, \"petName\" : \"Spot\" }, \"sarah\" : { \"age\" : 42, \"petName\" : \"Rover\" }, \"zhang\" : { \"age\" : 13, \"petName\" : \"Fluffy\" } } } This database object has a people key that refers to an object, which itself contains keys that refer to individual “person” objects (each of which has an age and petName property). In the Firebase Web Console (under the “Database” tab in the navigation menu), this data structure would be presented as: A Firebase database with sample people data Note that in the Firebase Web Console you can edit this database directly: viewing, adding, editing, and deleting elements in the JSON. This is useful for debugging—both to check that your code is editing the database accurately, and to clean up any mistakes. Although the JSON database can have many levels of nested objects, best practice is to try and keep the structure as “flat” as possible and avoid nesting too much data. This avoids you needing to download the nested “details” for a value if you only need to know e.g., the key names. See Structure Your Data for more details and examples. Setting Up the Database In order to enable the realtime database for your project, navigate to the console page for the database and click the “Create Database” button. Make sure you’re creating the Realtime Database, not the Firestore Database! After selecting your local region, you’ll be prompted to set up the Security Rules. Choose to start in test mode to get started immediately; see the below section for more about security rules. Security Rules Because the Firebase database is just a giant JSON object in the cloud and is usable from a client-side system, technically anyone can access it. Each element of the JSON object is accessible via AJAX requests (which are sent via firebase functions). In order to restrict what clients can access this information (read or write to values in the JSON), Firebase lets you define security rules that specify what users can access which elements. For example, you can make it so that only authenticated users can add new entries the database, or that only specific users can update specific entries (e.g., the comments they wrote on a blog). By default, no one can access or modify the data (in locked mode). If you choose to start your project in test mode, then anyone will be able to access or modify the entire database for a limited amount of time. In order to modify or configure the security rules, navigate to the “Rules” tab of the Realtime Database’s page in the Firebase Web Console. You can modify the rules by editing the presented JSON data; remember to hit “Publish” after you’re done editing. Firebase Security Rules are defined in JSON using a particular (and somewhat awkard) scheme. Basically, inside the \"rules\" property you specify a JSON tree that mirrors the structure of your database. But instead of having a value for the keys in your database, you specify an object with \".read\" and \".write\" properties. The values of these properties are boolean expressions that state whether or not the current user is able to read (access) or write (modify) that value. For more on writing rules, such as how to handle user authorization (only certain users can read/write access) or data validation (making sure all data is written of a certain type), see the official documentation. Data References To start working with your database, you will need to get a reference to that value in the database. You begin by getting a reference to the database itself, using the getDatabase() function provided by Firebase’s database module firebase/database: //import the function from the realtime database module import { getDatabase } from 'firebase/database'; //get a reference to the database service const db = getDatabase(); Importantly, the db value in the example is not a copy of the data or even the database itself! It’s instead just a reference pointer to where that database lives—you can think of it more like a “URL” for the database. The getDatabase() function is a simple singleton accessor that runs in constant time; it’s best practice to call it scoped in whatever functional scope you need to refer to the database. You do not need topass it around as a prop, nor should you try to make a “top level” or global db variable. Just call the function again if you need to access the database from a separate scope. In order to modify any particular values in the database, you will need to get a reference to that value. This is done by using the ref() function, passing in the database reference and the “path” (a string) to the data value in the database’s JSON: import { getDatabase, ref } from 'firebase/database'; //get a reference to the database service const db = getDatabase(); //get reference to the \"people\"\" property in the database const peopleRef = ref(db, \"people\") //get reference to the \"sarah\" property inside the \"people\" property in the database //similar to `database.people.sarah` using dot notation const sarahRef = ref(db, \"people/sarah\"); Again, these reference are not the data! They are just reference pointers to where the data lives—like the “URL” for that data value. The “path” to nested values in the database are written in a URI-style “path notation”, where each nested key is indicated by a slash / (rather than the . in dot notation as you’d normally use with JSON format). Thus \"people/sarah\" refers to the sarah key inside of the people key inside of the database; \"people/sarah/pet\" refers to the pet key inside the sarah key inside the people key—the spot in the database with the value \"Rover\" in the above example. Since this path is just a string, you can use string concatenation to construct the path to a particular value you wish to reference (e.g., if you only want to work with the value for a particular person): //variable name to access const personName = \"Ada\"; //access the \"Ada\" property inside of the \"people\" property inside the database const personOfInterestRef = ref(db, \"people/\"+personName); Alternatively, you can use the child() function to get a reference to a specific “child” element in the database: import { ref, child } from 'firebase/database'; //equivalent to the above example //get reference to the \"people\" property in the database const peopleRef = ref(db, \"people\") //get reference to the \"sarah\" property inside of the \"people\" reference'd value const sarahRef = child(peopleRef, \"sarah\") In general, you want to work with a small a subset the data as possible. Thus it’s better to get a reference to \"person/sarah\" if you’re only going to read or write to that value, rather than get a reference to the whole \"people\" and then just read/write the sarah key in that. Writing Data You can modify values in the database by using the set() function. This function takes two arguments: a database reference, and then the new value you want to assign to that location in the database: //alias the `set` function as `firebaseSet` import { ref, set as firebaseSet } from 'firebase/database' //get a reference to where sarah's age is stored in the database const sarahAgeRef = ref(db, \"people/sarah/age\"); //change Sarah's age to 43 (happy birthday!) const newValueForSarahAge = 43; //assign the new value in the database firebaseSet(sarahRef, newValueForSarahAge); This will change the value in the database at \"people/sarah/age\" to 43. Note that in this example, I use the as keyword to alias the set function when importing it, instead calling it firebaseSet. This is for clarity, as “set” is an overly generic name for a function. Note that as with normal JSON objects, you can also “set” values for database entries that didn’t previously exist—you do not have to “declare” a value in the database ahead of time //a reference to the people entry in the database const peopleRef = ref(db, \"people\") //a reference to a location with no currently defined value const adaRef = ref(peopleRef, \"ada\"); //set an object to that location in the database firebaseSet(adaRef, {age: \"206\", pet: \"Charlie\"}) Firebase also provides an equivalent method update(), which will “merge” in changes to the existing value at a reference. This allows you to update() the a reference pass in an object with some properties to be modified, while existing properties are be retained (rather than having the entire value at that reference be replaced). Finally, note that the set() method returns a Promise. Thus you can use .then() (or await) to execute statements after the database has updated, and you can thus catch any errors that may occur when attempting to update a value. This is especially useful for debugging, but also is good for providing user feedback. const sarahPetRef = ref(db, \"people/sarah/pet\"); //change Sarah's pet firebaseSet(sarahPetRef, \"Sparky\") .then(() => console.log(\"data saved successfully!\")) .catch(err => console.log(err)); //log any errors for debugging Listening for Data Changes Because Firebase’s database is intended for realtime access (that may change over time), you read data from it and establish data binding by registering an event listener to listen for changes to that database. In effect, any modifications to the data causes a “database change event” which triggers your listener, allowing you to acccess the new updated data. You register a database change listener by using the onValue() function. This function takes as arguments a database reference (which value you want to listen for changes to) and a callback function that will be executed in response to the event (similar to the DOM’s addEventListener() function): import { ref, onValue } from \"firebase/database\" //get a reference to a particular value location in the database const amitRef = ref(db, 'people/amit'); //register a listener for changes to that value location onValue(amitRef, (snapshot) => { const amitValue = snapshot.val(); console.log(amitValue); //=> e.g., { age: 35, petName: \"Spot\" } //can do something else with amitValue (e.g., assign to a state variable) }); The callback function will be passed as a parameter the latest snapshot of the data value at the listening location. This is a wrapper around the database’s JSON tree (allowing you to navigate it e.g., with child()). Most commonly, you will want to convert the snapshot into an actual JavaScript object by calling the .val() method on it. The listener will trigger whenever any child node of the targeted refence location changes. Thus even if just people/amit/pet is updated, the above listener will trigger. Importantly, because this listener involves network access and can trigger throughout the life of your application, in a React app you will need to register the listener inside an effect hook. The effect hook’s “cleanup function” will also need to remove the listener—otherwise you will have a memory leak and can get errors if your component gets removed (e.g., by changing routes). The onValue() function returns a new function that can be used to “unregister” the listener: function MyComponent(props) { //effect hook useEffect(() => { const db = getDatabase(); const amitRef = ref(db, \"people/amit\"); //returns a function that will \"unregister\" (turn off) the listener const unregisterFunction = onValue(amitRef, (snapshot) => { const amitValue = snapshot.val(); //...set state variable, etc... }) //cleanup function for when component is removed function cleanup() { unregisterFunction(); //call the unregister function } return cleanup; //effect hook callback returns the cleanup function }) } Note that it is possble to read a single value once (without needing to register a listener) by using the get() method. This method returns a promise that will contain the read snapshot (once it is downloaded). However, the Realtime Database is intended and optimized for data binding and notifications. Thus you should pretty much always be using onValue() to read data from the database. If you find yourself wanting to just read a single value once, you’re not thinking about the realtime database correctly! Firebase Arrays When working with and storing data in the cloud, we often want to organize that data into lists using arrays. However, Firebase does not directly support support arrays: the JSON object in the sky only contains objects, not arrays! This is because Firebase needs to support concurrent access: multiple people need to be able to access the data at the same time. But since arrays are accessed by index, this can cause problems if two people try to modify the array at the same time. The problem is that with an array, an index number doesn’t always refer to the same element! For example, if you have an array ['a', 'b' 'c'], then index 1 may initially refer to the 'b'. However, if you add an element onto the beginning of the array, then suddenly that 1 index refers to the 'a'. And so if a user was trying to modify the 'b' before their machine was aware of the change, they may end up editing the wrong value when they ask to change the value at index 1! This bug is an example of a race condition, which can occur when two processes are modifying data concurrently (at the same time). To avoid this problem, Firebase treats all data structures as Objects, so that each value in the JSON tree has a unique key. That way each client will always be modifying the value they expect. However, Firebase does offer a way that you can treat Objects as arrays, in the form of a push()(https://firebase.google.com/docs/reference/js/firebase.database.Reference#push) function that will add a value to an object with an auto-generated key. import { getDatabase, ref, push as firebasePush } from 'firebase/database'; const db = getDatabase; const tasksRef = ref(db, \"tasks\"); //an object of tasks firebasePush(taskRef, {description:'First things first'} ) //add one task firebasePush(taskRef, {description:'Next things next'} ) //add another task This will produce a database with a structure: { \"tasks\" : { \"-KyxgJhKOVeAj2ibPxrO\" : { \"description\" : \"First things first\" }, \"-KyxgMDJueu17348NxDF\" : { \"description\" : \"Next things next\" } } } Notice how the tasks property is an Object (even though we “pushed” elements into it), and each “task” is assigned an auto-generated key (based on the timestamp it was pushed). You can still interact with tasks as if it were an array-like list, but instead of using a value from 0 to length as the index, you’ll use a generated “key” as the index. Always use the push() function to have Firebase automatically manage data arrays for you. Never try to manually create an “array” by giving values keys “0”, “1”, “2” etc. Firebase snapshots do support a forEach() function that you can use to iterate through their elements, allowing you to loop through the elements in an array. However, if you want to do something more complex (like map(), filter(), or reduce()), you need an actual array. The best way to get this is use call Objects.keys() on the snapshot.val() in order to get an array of the keys, and then you can iterate/map those keys into an array of values (accessing each element in the “array” using bracket notation). //`tasksSnapshot` is a snapshot of the `tasks` \"array\" const allTasksObject = tasksSnapshot.val(); //convert snapshot to value //an array of the keys in the object [\"-KyxgJhKOVeAj2ibPxrO\", \"-KyxgMDJueu17348NxDF\"] const allTasksKeys = Object.keys(allTasksObject); //map array of keys into array of tasks const allTasksArray = allTasksKeys.map((key) => { const singleTaskCopy = {...allTasksObject[key]}; //copy element at that key singleTaskCopy.key = key; //locally save the key string as an \"id\" for later return singleTaskCopy; //the transformed object to store in the array }); allTasksArray.map((taskObject) => { ... }) Note that when looping through an “array”, each element is handled separately from its key (the same way that a forEach() loop lets you work with array elements separately from their index). But since you may need that key as an identifier in order to ref() and modify the JSON element later, you should make sure that you “save” the key in the object as you processing it as an additional local property. This won’t modify the value in the database, just the local variable that your code is working with. Don’t lose your key!. 19.3 User Authentication Firebase provides the ability to authenticate users: to let people sign up for you application and then to check that they are who they say (e.g., have provided the right password). Firebase supports multiple different forms of authentication: users can sign up with an email and password, log in with a social media service such as Google or Facebook, or even authenticate “anonymously” (so you can at least keep track of different people even if you don’t know who they are). In order to support user authentication, you will need to enable this feature in the Firebase Web Console. Click on the “Authentication” link in the side navigation menu’s Build capetgory to go to the authentication management page, then choose “Get started”. Under the “Sign-In Method” tab, you can choose what forms of authentication you wish to enable. For example, click on the “Email/Password” option, and then flip the switch to “Enable” that method. Be sure and Save your changes! Each different sign-in method uses what is called a “Provider”—a service that provides the information about whether the user is who they say. Firebase’s email/password check is a possible Provider; Google is a possible Provider; etc. You can enable multiple different Providers, each of which will be able to authenticate users (i.e., letting them sign in with the relevat credentials). Note that you will be able to use this page to see and manage users who have signed up with your Firebase project. This is where you can see if uses have successfully been created, look up their User UID for debugging, or delete users from the project: Firebase users as presented in the authentication web console Signing In with FirebaseUI It is possible to call functions provided by Firebase in order to create and log in users. However, this would require you to implement the “log in form” on your own—and would only easily support the Email/Password authentication option. Instead, a nicer approach is to use the FireabaseUI library, also managed by Firebase. This library provides a set of predefined UI elements like a “login form”, including ones which will support different authentication methods. Example of FirebaseUI authentication There are different FirebaseUI libraries for different platforms; previously for React you would use firebaseui-web-react. However, as of November 2022 this library has not been updated to work with the latest version of React (React 18), and appears to have been been abandoned rather than applying the needed fix. There are two possible workarounds to this: You can install a version of the library updated by Gabriel Villenave (which hasn’t been accepted as a pull request yet): # install library on the command line npm install https://gitpkg.now.sh/gvillenave/firebaseui-web-react/dist Confirm that your package.json file has the correct dependency listed: &quot;react-firebaseui&quot;: &quot;https://gitpkg.now.sh/gvillenave/firebaseui-web-react/dist&quot; You can install the non-React version of the library (firebaseui), and then define the needed Component (StyledFirebaseUI) manually: npm install firebaseui Create the StyledFirebaseAuth.txs file defined in this comment post. The React FirebaseUI library provides a Component called &lt;StyledFirebaseAuth&gt;, which you can render in your page like any other Component. You can think of this Component as the “login form”. A complete example of how this Component is used can be found below, following by an explanation. //import auth functions and variables from Firebase import { getAuth, EmailAuthProvider, GoogleAuthProvider } from 'firebase/auth' //import the component -- pick one! import StyledFirebaseAuth from 'react-firebaseui/StyledFirebaseAuth'; //install option 1 import StyledFirebaseAuth from './StyledFirebaseAuth'; //install option 2 //an object of configuration values const firebaseUIConfig = { signInOptions: [ //array of sign in options supported //array can include just \"Provider IDs\", or objects with the IDs and options GoogleAuthProvider.PROVIDER_ID, { provider: EmailAuthProvider.PROVIDER_ID, requiredDisplayName: true }, ], signInFlow: 'popup', //don't redirect to authenticate credentialHelper: 'none', //don't show the email account chooser callbacks: { //\"lifecycle\" callbacks signInSuccessWithAuthResult: () => { return false; //don't redirect after authentication } } } //the React compnent to render function MySignInScreen() { const auth = getAuth(); //access the \"authenticator\" return ( &lt;div> &lt;h1>My App&lt;/h1> &lt;p>Please sign-in:&lt;/p> &lt;StyledFirebaseAuth uiConfig={firebaseUIConfig} firebaseAuth={auth} /> &lt;/div> ); } There are a few steps to using this Component: The &lt;StyledFirebaseAuth&gt; requires a uiConfig prop, which is an object containing configuration values for that login form (the object has specific properties which correspond to configuratoin options). The config object is usually defined as a global constant. The most important configuration option is the signInOptions, listing the different authentication providers supported (what options should show up in the login form). The IDs for these providers are imported from the 'firebase/auth' library—though they are numeric values, not functions. Other common/useful options are shown in the example; for a complete list of options see the firebaseui-web documentation. The &lt;StyledFirebaseAuth&gt; also requires a firebaseAuth prop, which is a reference to the “authenticator” service—what will handle the process of the user logging in and out. You can get access to this value via the getAuth() function provided by 'firebase/auth' (similar to how you get access to the Realtime Database via the getDatabase() function). Note that as with getDatabase() the authenticator is a singleton value—you can call getAuth() from multiple modules/files/scopes without concern. You do not need to pass it around as a prop or declare it as a “top-level” constant. With this Component, users will be able to “log in”, though see the Managing the User section below. You will be able to see a list of users who have connected to your app in the Firebase Web Console. Note in particular that you can see their uid (unique identifier), which is what is used to distinguish between users. (You can’t use emails as identifiers, because someone who logs in with Facebook won’t provide their email address!). Pro-tip: You don’t need to come up with real email addresses for testing. Try using a@a.com, b@a.com, c@a.com, etc. Similarly, password works fine for testing passwords (though you should never do that in real life!) The Firebase Web Console will provide a view of the “user list”—but importantly, this is not the same as the Realtime Database. The user list holds very limited information: the authentication provider, a “display name”, and possibly a “photo url” (e.g., where to find an avatar image). But you cannot store any additional information in the “user database”—not profile images, not preferred names or pronouns used, not favorite fish. Any user-specific information will need to be stored in the Realtime Database instead, usually using a “key” that is the user’s uid. For example, your Realtime Database might store information like: { \"userData\" : { \"userId1\" : { \"pronouns\" : \"they/them\", \"favoriteFish\" : \"sea bass\" }, \"userId2\" : { \"pronouns\" : \"he/him\", \"favoriteFish\" : \"cuttle fish\" } } } You can then access the user’s data using the same process as any other data in the realtime database, listening to the reference \"userData/\"+userId. In order to sign out a user, you can use another built-in Firebase function: signOut(): import { getAuth, signOut } from 'firebase/auth'; const auth = getAuth(); signOut(auth) .catch(err => console.log(err)); //log any errors for debugging Note that the signOut() method returns a Promise, so you can .catch() and display any errors. Managing the User Although FirebaseUI will log in a user, you will need to do further work in order for your app to know who that logged in user is. The authenticator (from getAuth()) will keep track of which Firebase User is currently logged in—and this information persists even after the browser is closed. This means that every time you reload the page, the authenticator will automatically perform the authentication and “re-login” the user. The recommended way to determine who is currently logged in is to register an event listener to listen for events that occur when the “state” of the authentication changes (e.g., a user logs in or logs out). This event will occur when the page first loads and Firebase determines that a user has previously signed up (the “initial state” is set), or when a user logs in or out. You can register this listener by using Firebase’s onAuthStateChanged() function: //import functions import { getAuth, onAuthStateChanged } from 'firebase/auth' const auth = getAuth(); onAuthStateChanged(auth, (firebaseUser) => { if(firebaseUser){ //firebaseUser defined: is logged in console.log('logged in', firebaseUser.displayName); //do something with firebaseUser (e.g. assign to a state variable) } else { //firebaseUser is undefined: is not logged in console.log('logged out'); } }); The onAuthStateChanged() function takes in two arguments: the authenticator, and a callback function that will be executed whenever the “authentication state” changes (e.g., whenever the user logs in or out). The callback function will be passed an object representing the “Firebase User”. This object contains properties about the user, including: uid, which is the unique id for the user displayName, which is the user’s provider-independent displayable name The most common practice is to take this passed in object and assign it to a more global variable, such as a state variable in a React component (e.g., setCurrentUser(firebaseUser)). If the user “logged out”, then the passed in firebaseUser value will be null; this information can also be saved to the React state variable. Importantly, because this listener involves network access and can trigger throughout the life of your application, in a React app you will need to register the listener inside an effect hook. The effect hook’s “cleanup function” will also need to remove the listener. The onAuthStateChanged() function returns a new function that can be used to “unregister” the listener: function MyComponent(props) { //effect hook useEffect(() => { const auth = getAuth(); //returns a function that will \"unregister\" (turn off) the listener const unregisterFunction = onAuthStateChanged(auth, (firebaseUser) => { //handle user state change if(firebaseUser){ //... } }) //cleanup function for when component is removed function cleanup() { unregisterFunction(); //call the unregister function } return cleanup; //effect hook callback returns the cleanup function }) } Firebase React Hooks In React systems it is common to render different content depending on whether the user is logged in. This could be done with conditional rendering, or with a “protected route” as described in Client-Side Routing. However, it takes a few seconds for Firebase to authenticate a user when a page first loads. Thus your conditional rendering will often need to handle 3 cases: when a user is logged in, when a user is not logged in, and when the user status is “loading” and the app hasn’t finished checking yet. While there are some cludgy workarounds (e.g., use a special value for your state to indicate that a user is “loading”), this is a common enough situation that you can use solutions implemented by other people. One such option is the firebase-react-hooks library. This library provides a simple hook (like useState or useParams) that lets you access the user status. In particular, the useAuthState hook will implement the authentication state listener for you: import { getAuth } from 'firebase/auth'; import { useAuthState } from 'react-firebase-hooks/auth'; function MyComponent(props) { const auth = getAuth(); const [user, loading, error] = useAuthState(auth); if(loading){ //still waiting return &lt;p>Initializing user&lt;/p> } if(error) { //error logging in return &lt;p>Error: {error}&lt;/p> } if(user) { //user is defined, so logged in return &lt;p>Welcome {user.displayName}&lt;/p> } else { //user is undefined return &lt;p>Please sign in&lt;/p> } //... } This hook returns an array of 3 values (which are destructured in the above example), indicating the current user (or null for no user), whether the auth state is still loading, and whether there was an error. While using such a library is not necessary, it is a good example of how React’s architecture allows for external libraries that can help reduce boilerplate code. 19.4 Firebase Storage Firebase’s Realtime Database persists JSON data: so in the end just strings, numbers, and booleans (even if those values are organized into objects). If you wish to persist data files—such as music, video, pdfs, etc—you need to use a different service called Firebase Storage. Storage is designed for storing larger files rather than primitive data types. In the end it works fairly similarly to the realtime database, though without data binding. Firebase free tier provides up to 5 GB of storage for free (with 1 GB/day of downloading allowed). That’s about 5000 hi-res images, 1000 music files, or maybe 20 hr of compressed video. This means that the free storage service will work great for most development versions of media applications–though you may run out of space quickly if working with video, especially when testing. Always consider the amount of data you will need to store before choosing a cloud storage service. In order to use Firebase Storage, you will need to enable this feature in the Firebase Web Console. Click on the “Storage” link in the side navigation menu’s Build capetgory to go to the authentication management page, then choose “Get started”. Similar to the realtime database, you’ll need to choose security rules (probably being in test mode for development). When prompted for a Cloud Storage bucket location, pick something nearby to speed up access a little, but for most student projects it doesn’t matter much. Once you have set up Storage, you can use the Firebase Web Console to view and manage files that have been uploaded (including deleting them if desired). File Inputs In order for a user to upload a file to Storage, the user will need to first choose which file they want to store. The correct way to do this is to use a \"file\" type &lt;input&gt; element: &lt;input type=\"file\"> This element works the same as other &lt;input&gt; elements you’ve used (usually with the default type of \"text\"). But rather than providing an interface for the user to provide a string as a value, the input will provide an interface for the user to choose a file from their operating system. This is an &lt;input&gt; like any other, which means that in React you should use a state variable to control it! Once the user choses a file, you can access that the files chosen through the .files property of the &lt;input&gt; element—similar to the .value property used with default &lt;input&gt; elements. Note that the operating system’s file picking dialog may allow the user to choose multiple files (or none at all!); you will will want to check this when responding to any changes to the input: //an event handler function that responds to changing in an `&lt;input type=\"file\">` const handleChange = (event) => { //the event.target is the &lt;input> element //check e.g., that the user picked at least 1 file, and that the file they picked actually exists if(event.target.files.length > 0 &amp;&amp; event.target.files[0]) { const chosenFile = event.target.files[0]; //the first file chosen //... do something with that value, such as store it in React's state } } Note that the chosenFile will be a File-type value, which has its own set of methods and properties. Critically, the File value is really just a reference to a location in your computer’s operating system; if the file gets moved or renamed then the File will be pointing at something with no size, so you won’t be able to upload it. Uploading Files Once you have the File the user wants to upload, you can upload that data to Firebase using a method similar to how you set data in the realtime database. First, you need to get a reference to the location in Storage where you want to upload the file. You do this by using the ref() function from the firebase/storage library: import {getStorage, ref as storageRef } from 'firebase/storage'; //get a reference to the storage service const storage = getStorage(); //get a reference to where the file will go in storage const fileRef = storageRef(storage, \"path/to/myfile.png\"); Importantly, this is a different ref() function than the one used with the realtime database! They are not interchangeable. For that reason, you can alias the storage’s ref as e.g., storageRef in order to use both in the same module. The ref() function takes as arguments the reference to the storage service and a string representing the “file path” for the new file—where it will go in the Storage bucket. You write this string like any other relative file path; it includes both any intermediate directories as well as the name of the resulting file. Any directories you include in the path will be created when the file is uploaded (they do not have to exist previously), and if a file already exists at that location, it will be overwritten. Be sure to include the file extension when naming the file (and you’ll want that file extension to match the actual file type!) Once you have a reference to the file’s location in storage, you can use the uploadBytes() function to upload the file: import {getStorage, ref as storageRef, uploadBytes } from 'firebase/storage'; const storage = getStorage(); const fileRef = storageRef(storage, \"path/to/myfile.png\"); uploadBytes(fileRef, myFile) .then(() => console.log(\"file successfully uploaded!\")) .catch(err => console.log(err)); //log any errors for debugging The uploadBytes() function is asynchronous (it can take a while to upload large files!) and returns a Promise that you can use to respond when the file has finished uploading or to catch and process errors. Once a file has been uploaded, Firebase will give it a public URL (with the usual https:// protocol) where websites and users can access it. This public URL is different and constructed from the ref path that was specified, and will vary based on the storage parameters used by Firebase. So in order to figure out the resulting URL for this file (e.g., so you can show the file to the user again, you will need to request that URL from Firebase. You do this by using yet another function called getDownloadURL(). The function takes the file’s ref as an argument, and will query Firebase for the public URL of the file. But querying Firebase is a network operation, which means that it takes time… Thus getDownloadURL() is asynchronous doesn’t return the actual URL, but a Promise for that URL; you will need to wait for that promise to resolve to access the URL string. Since uploading the file and getting the public URL are both asynchronous functions that return Promises, this operation is a good place to use async/await syntax to help keep the code readable rather than having a sequence of Promises. import {getStorage, ref as storageRef, uploadBytes, getDownloadURL } from 'firebase/storage'; //await calls need to go in an async function async function uploadFile() { const storage = getStorage(); const fileRef = storageRef(storage, \"path/to/myfile.png\"); try { //try/catch to handle errors await uploadBytes(fileRef, myFile) //asynchronous upload const url = await getDownloadURL(fileRef); //asynch query for public URL //...do something with the url, such as set it to state for rendering //...or save that url in the realtime database } catch (err) { console.log(err); //log any errors for debugging } } Note that it is normal to take the public URL and to also set it to a location in the realtime database; this allows an uploaded image to be associated with some other data values. The realtime database stores the url to the file (a string, stored in JSON), but the file itself is kept in Firebase Storage. Resources Firebase Web Documentation Firebase Realtime Database Firebase Authentication "],["code-style-guide.html", "A Code Style Guide A.1 HTML Guidelines A.2 CSS Guidelines A.3 JavaScript Guidelines A.4 React Guidelines A.5 Miscellaneous Guidelines", " A Code Style Guide Computer code is read by two different audiences: computers, which execute the code statements (or render the web page), and humans who need to interpret and update the code over time. Using good coding style—the manner and format in which code is written—is vital for supporting the humans who read it. Poorly written code may be interpretable by the computer and thus work correctly, but it also needs to be understandale by people. Code that is well written (has “good style”) fulfills two properties: It is easy for people to read It is easy for people to modify in the future All coding style guidelines should follow from these two goals. If you ever wonder whether one styling approach is better than another, consider it in terms of those goals. Everyone has a differnet opinions on what is considered “good style”; indeed there are numerous existing “style guides” written for web programming languages: for example, Google has their own HTML/CSS and JavaScript style guides, as does Mozilla. There are also tools that enforce styling guidelines. “linters” such as ESLint will both identify syntactic errors, but also may have strong opinions on style, marking “poor style” as an error. I recommend being cautious with automatic code styling (“beautifier”) tools or plugins. While these can be useful, it’s also possible that they will “clean” your code in a way that doesn’t actually improve it. Be very careful with anything that writes or changes code for you to ensure that it’s doing the right thing! This chapter provides a number of specific guidelines following the opinions of the authors (and instructors of the INFO 340: Client Side Development course) in order to help you learn to write code that is generally easier to read and modify—that has good style. It is not intended to be comprehensive; rather it is a collection of guidelines that students often question or have troubles following intuitively. See the above linked style guides for more comprehensive suggestions. This chapter is a work in progress, with more guidelines being added as they come up. A.1 HTML Guidelines Always use lowercase letters for HTML tags. This helps with readability and consistency. &lt;!-- Do this --> &lt;p>lorem ipsum&lt;/p> &lt;!-- Don't do this --> &lt;P>lorem ipsum&lt;/P> &lt;P>lorem ipsum&lt;/p> Spacing In general, put tags for block elements on their own lines, with the content of block elements as a separate (indented) line—unless the content of that block element is very short. Subsequent block eleents are indented an additional step. This makes it easier to read the code by seeing the blocks, as well as to modify the code by adding more content inside of blocks. &lt;!-- Do this --> &lt;div> lorem ipsum &lt;/div> &lt;!-- Do this --> &lt;div> &lt;p> lorem ipsum &lt;/p> &lt;/div> &lt;!-- Do this --> &lt;p>Hello world&lt;/p> &lt;!-- short content so can be on same line as tags --> &lt;!-- Don't do this --> &lt;div>&lt;p>lorem ipsum&lt;/p>&lt;/div> For many inline elements—particularly text formatting ones (e.g., &lt;em&gt;, &lt;strong&gt;, &lt;a&gt;)—it’s best to keep them inline with the rest of the content. Think about like writing a paragraph, but some words in the middle are formatted. Don’t try to separate out the inline elements. This makes it easier to see them as “inline”, and means that you can integrate it into your code without needing to worry about spacing. (This will also often fix trailing space issues). Note that this guideline is one that automated beautifying tools mess up. &lt;!-- Do this --> &lt;p> There was a farmer who had a dog, and &lt;em>Bingo&lt;/em> was his name-o... &lt;/p> &lt;!-- Don't do this --> &lt;p> There was a farmer who had a dog, and &lt;em>Bingo&lt;/em> was his name-o... &lt;/p> For “structural” inline elements (e.g., &lt;img&gt; , &lt;button&gt;), it’s better to put them on their own line similar to block elements. Indeed, these elements may often want to be styled as block elements anyway! &lt;!-- Do this --> &lt;p> This is a picture of a dog: &lt;img src=\"puppy.png\" alt=\"a puppy\"> &lt;/p> &lt;!-- Don't do this --> &lt;p> This is a picture of a dog: &lt;img src=\"puppy.png\" alt=\"a puppy\"> &lt;/p> Element attributes should be written on the same line as the element tag they apply to—even if the attribute value seems “long” (like a URL). &lt;!-- Do this --> &lt;a href=\"https://info340.github.io/really/long/path/to/content\">Link&lt;/a> &lt;!-- Don't do this --> &lt;a href=\"https://info340.github.io/really/long/path/to/content\">Link&lt;/a> Note that it is not valid HTML to put whitespace, including line breaks, around the = when defining an attribute. The one exception to this style guideline is when you have lots of attributes for a single element. In that situation, it’s acceptible to put each attribute on its own line, indented 1 step. While that rarely happens in straight HTML, it can be very common when specifying props for a React component (and makes it easier to modify those props as well). &lt;!-- Do this --> &lt;input type=\"text\" id=\"user-input-field\" name=\"user-input-field\" value=\"\" placeholder=\"Write something here!\" class=\"long-form-input\"> Write all text content of a single element as a single line of code; do not manually put line breaks inside of plain text. This will allow you to modify that text content later without needing to reformat things. Do not worry about the length of the line of code. You can use the “word wrap” functionality of your editor to avoid horizontal scrolling. &lt;!-- Do this --> &lt;!-- This *single line of code* can be made to wrap in your editor --> &lt;p> Lorem, ipsum dolor sit amet consectetur adipisicing elit. Consectetur est necessitatibus, rerum atque officiis doloremque porro similique molestias fugit, a repellendus fuga natus, tempora impedit. Dolore repellendus itaque soluta est ad modi corrupti quibusdam tenetur architecto nesciunt harum ipsa consectetur ullam unde, quos sit asperiores corporis vitae pariatur expedita non? &lt;/p> &lt;!-- Don't do this --> &lt;p> Lorem, ipsum dolor sit amet consectetur adipisicing elit. Consectetur est necessitatibus, rerum atque officiis doloremque porro similique molestias fugit, a repellendus fuga natus, tempora impedit. Dolore repellendus itaque soluta est ad modi corrupti quibusdam tenetur architecto nesciunt harum ipsa consectetur ullam unde, quos sit asperiores corporis vitae pariatur expedita non? &lt;/p> Specific Elements Avoid un-semantic formatting elements (e.g., &lt;i&gt;, &lt;b&gt;), as they are not accessible to screen readers. Avoid using the &lt;br&gt; element for line breaks. If you’re breaking a line of text, it’s most often because you’re defining a new paragraph, and so should use an additional &lt;p&gt; element. If there isn’t a semantic meaning for the line break, don’t include one! If you need to adjust the amount of spacing between paragraphs (e.g., you want it to be a single spacing not double spacing), use CSS to adjust the margin or padding. &lt;!-- Do this --> &lt;p> Lorem, ipsum dolor sit amet consectetur adipisicing elit. &lt;/p> &lt;p> Consectetur est necessitatibus, rerum atque officiis doloremque porro similique molestias fugit, a repellendus fuga natus, tempora impedit. &lt;/p> &lt;!-- Don't do this --> &lt;p> Lorem, ipsum dolor sit amet consectetur adipisicing elit. &lt;br /> Consectetur est necessitatibus, rerum atque officiis doloremque porro similique molestias fugit, a repellendus fuga natus, tempora impedit. &lt;p> The only reason I can think of for semanticaly using a &lt;br&gt; element would be in poetry: &lt;!-- Do this --> &lt;div> Roses are red, &lt;br> Violets are blue. &lt;br> Unexpected '}' &lt;br> on line 32. &lt;/div> Comments in HTML Most HTML content doesn’t need comments; it should be understandable just from the indentation and content. If your code needs more organization, use semantic elements (e.g., &lt;section&gt;) or class names to help structure it (e.g., &lt;div class=\"first-post\"&gt;). A.2 CSS Guidelines One piece of adviace for writing good CSS is to focus on the “minimal” amount of CSS needed to achieve your effect. Work with the browser and its defaults, rather than trying to overpower it. Perhaps surprisingly, removing rules or properties is usually a better fix to a problem then adding additional styling. A.2.1 Spacing When writing CSS rules, put the { of a rule on the same line as the selector, and indent the properties of the rule a consistent amount. Put a space after the : in a rule, but not before. Rules should thus look like: selector { property: value; property: value; } Note that you can use VS Code to automatically “indent” your code using the format document command. A.2.2 Selectors Use selectors that are only as specific as they need to be. /* Do this */ li.selected {} /* selected list items, not selected paragraphs */ /* Don't do this */ div p {} /* paragraphs inside of divs (are there other paragraphs? */ /* Don't do this */ body p {} /* no paragraphs outside of the body, so redundant */ (It’s hard to show examples, because the required specificity depends on the situation!) Most selectors will involve 1-3 “pieces” (connected by descendant or compound selection). If you find yourself using more than that, ask if there’s a simpler way to write the selector—or just give the element a class to select it directly! Use class or element selectors instead of id selectors. /* Do this */ .side-nav {} /* Don't do this */ #side-nav {} If you must use an id selector, don’t add extra specificity before id selectors. An id has to be unique, so you don’t need to distinguish between multiple elements with the same id. /* Don't do this */ nav#side-nav {} Do not use the !important keyword. Write a sufficiently specific rule instead! /* Don't do this */ .error { color: red !important; } /* Do this */ p.alert.error { color: red; } A.2.3 Class Names Use descriptive class names. Classes should describe what or why that styling is being applied. /* Do this */ .side-nav {} /* Do this */ .alert-warning {} /* Don't do this */ .thingy {} /* Don't do this */ .s1 {} /* Don't do this */ .p {} /* use an element selector instead! */ Note that classes could either be defined semantically (e.g., .avatar-icon, .comment-form), or modularly (e.g., .font-large, .bg-secondary). Either approach is acceptable per this guide, but try to be consistent. Using naming schema such as BEM is also acceptable. Use hyphens as delimiters for class names. /* Do this */ .side-nav {} /* Do this */ .alert-warning {} Certain frameworks may make it sensible to use camelCasing for class naming (so class names are also valid JavaScript identifiers). In that case, be consistent with delimiters. This will make it easier to write and modify the code. /* Don't do this */ .sideNav {} .alert-warning {} A.2.4 Specific Properties Avoid using float; use flexboxes or grids for positioning. It is rare to actually have “floating” content (though it can happen with image inserts inside of large text-based articles). Avoid using position: absolute. This will produce layouts that are not responsive or accessible to multiple devices. Work with the browser’s layout instead by using relative layouts. A.2.5 Responsive CSS Use a mobile-first approach to styling. This means that general rules go at the top and apply to mobile devices, and then use media queries to specify style alterations for larger displays. Media queries check against minimize size only: /* Do this */ @media (min-width: 768px) {} /* Do not do this */ @media (min-width: 768px) and (max-width: 1092px) {} /* Do not do this */ @media (max-width: 768px) {} Limiting styling rules to screen is not required (unless you distinctly want those to be different from printed rules) /* Do this */ @media (min-width: 768px) {} /* Do not need to do this */ @media screen and (min-width: 768px) {} Media queries should be used to modify the mobile device styling, not to replace it completely. Don’t “reset” all of the rules from the mobile styling, just override and add-to the few rules needed to make the page effectively responsive. Your page should have a similar style/theme no matter what device is being used to view the content! A.2.6 Comments in CSS You do not need a lot of comments for CSS code; your rules should be self-explanatory because you’ve used descriptive class names. Use comments to help organize or “sign-post” your code, to group rules together in your .css file. /* Do this */ /* navbar */ nav {} nav li {} .tab-selected {} /* main content */ section {} p {} img.small {} A.3 JavaScript Guidelines A.3.1 Variables Declare variables using const or let. In general, use const for all variables, and then let only if you find you need to reassign the variable later (which is a lot less common then you may think)! Do not use var to declare variables (this avoid polluting the global scope). Variable names are written in camelCaseFormat (capitalizing the first letter of each “word” in the name after the first). Do not begin variable names with a capital letter. /* Do this */ const myName = \"Joel Ross\" /* Do not do this */ const my_name = \"Joel Ross\" /* Do not do this */ const MyName = \"Joel Ross\" You can use all capital letters for global constants. Note that just because a variable is declared const doesn’t mean it is a “global constant”. Use all capital letters to name values that are specified external to the functioning of your program; PI, WA_TAX_RATE, SCREEN_WIDTH are all global constants. Use descriptive variable names. Variable names should what the value references. Do not use names like stuff, thing, or x as they won’t help anyone understand your code. Name arrays and collections using plural nouns. Alternatively, you may find it useful to name strings, arrays, objects, and functions after their data type to help you remember (particularly if understanding plurals in English is difficult). /* Do this */ const names = [\"john\", \"paul\", \"george\", \"ringo\"]; /* Do this */ const dogArray = [\"fido\", \"spot\", \"rover\"]; //array of dog names const dogObj = {name: 'Fido', breed: 'mutt'}; //single dog object /* Do not do this */ const dog = [\"fido\", \"spot\", \"rover\"]; //an array named by a singular noun A.3.2 Functions Use function declarations rather than function expressions when defining functions—particularly “top-level” functions. This helps distinguish between functions and variables, making it easier to read and follow the code (even if it takes more typing). /* Do this */ function sum(a, b) { return a + b; } /* Do not do this */ const sum = function(a, b) { return a + b; } /* Do not do this */ const sum = (a, b) => a + b; For inline functions (such as anonymous callback functions), use arrow notation. This can keep things more concise and also avoid some scoping problems. /* Do this */ const transformed = array.map((item) => { //... }) /* Do not do this */ const transformed = array.map(function(item) { //... }) When using arrow functions, always put the () around the argument list. This clarifies that it is a function and will make things easier if/when you want to add additional arguments. /* Do this */ const transformed = array.map((item) => { //... }) /* Do not do this */ const transformed = array.map(item => { //... }) In general, avoid using concise body arrow functions. Including the explicit block (the {}) makes it easier to read as a function, as well as to modify and debug since you can add additional statements easily. It may seem like more code to type, but it’s better style. /* Do this */ const exclaimed = stringArray.map((aString) => { return aString + \"!!\" //add exclamation points }) /* Do not do this */ const exclaimed = stringArray.map((aString) => aString + \"!!\") Functions should be defined to be short and reusable. Using pure functions whenever possible. This means that they avoid side effects—they do not assign to or modify non-local variables. A.3.3 Comments in JavaScript “Comments are always failures.” - Robert Martin In general well-written code documents itself without the need for additional comments. Functions that are well named with small scopes will clearly indicate what they do without the need for further notation. If you find that you need a comment to explain what your code does, then you probably should rewrite that code so that it’s more readable. Comments should be used to provide further information about the intent of code (why it has been included), not the behavior of code (what it does). This means that in general you shouldn’t need to include a lot of comments in your code. Use comments as a last resort to clarify code behavior or otherwise communicate with other people. Do not retain large blocks of commented code in production (final) versions—be clear about the code you’re using without requiring the user to scroll past or ignore a lot of code that you’re not. A.3.4 Miscellaneous JavaScript Guidelines Use strict equality comparisons (=== and !==) instead of regular equality comparisons (== and !=). Minimize the use of console.log() statements in production (final) versions. These will slow your program down, pollute the logging space, and can be a source of information and security leaks. Use lots of console.log() statements when debugging, but remove them when you’ve fixed the bugs. A.4 React Guidelines A.4.1 Components Use Component functions (and hooks). Do not define components as classes. Use function declarations rather than function expressions when defining Component functions. This helps with readability. /* Do this */ function Card(props) { //... } /* Do not do this */ const Card = (props) => { //... } Component functions are named using nouns (what they are), not verbs (what they do). You name then like you would name classes in Java or other OOP languages. /* Do this - what the content is */ function EntryForm(props) //... } /* Do not do this - what it does */ function UpdateData(props) { //... } Give Components descripive names that indicate what “kind” of element they are, so there is no confusion about whether they are nouns or verbs. /* Do this - the component is a form */ function FilterForm(props) //... } /* Do not do this - unclear what the component is */ function Filter(props) { //... } Components are always written as top level functions. Never define one component inside of another! /* Do this */ function Parent(props) //... } function Child(props) //... } /* Do not do this */ function Parent(props) { function Child(props) { //... } //... } The argument to a Component is always called props (with an s at the end!). It is acceptable to use object destructuring in the argument to a Component function. Remember to include the {}—a Component only accepts a single argument! /* Acceptable */ function SongCard(props) //... } /* Also acceptable */ function SongCard({artist, title, album}) { //... } When specifying props to a Component (or attributes for an HTML element), do not put spaces around the = — write it like HTML! /* Do this */ &lt;Card value={dataItem} /&gt; /* Do not do this */ &lt;Card value = {dataItem} /&gt; Organize Components into separate modules (.js files). You can include multiple related components (e.g,. a Card and a CardList) in the same module. It’s a good idea to keep these files together inside of a distinct components folder in your source code. A.4.2 Mapping Data Do not declare functions such as the .map() callback inline inside the return statement of a Component (or any other function). Use multiple statements when writing code! Instead, declare the mapped values as a separate variable that can be included inside of the returned DOM. This will make your code easier to read, modify, and debug since you can add additional processing or inspections after the .map() call. /* Do this */ function App(props) { //map the data into &lt;Card> elements const cardElemArray = data.map((dataItem) => { return &lt;Card value={dataItem} key={dataItem.id} /> }) return ( &lt;div> {cardElemArray} &lt;/div> ) } /* Do not do this */ function App(props) { //This is all one statement (line) of code! Don't do that. return ( &lt;div> { data.map((dataItem) => { return &lt;Card value={dataItem} key={dataItem.id} /> }) } &lt;/div> ) } A.4.3 State Always use const when declaring state variables (since you don’t reassign them anyway)! /* Do this */ const [data, setData] = useState([]); /* Do not do this */ let [data, setData] = useState([]); Always name the “state setter” function after the name of the state variable (set______): /* Do this */ const [data, setData] = useState([]); const [currentsong, setCurrentSong] = useState({}); /* Do not do this */ const [nowPlaying, changeSong] = useState({}); const [lastTrack, setLast] = useState({}); //use the full variable name instead! Do not duplicate data in state. It’s both bad style and will cause bugs. Keep state minimal. Do not define state variables for values that can be computed from other variables. /* Do this */ const [myArray, setMyArray] = useState([]); const arrayLength = myArray.length; //computed from state, but not a state variable /* Do not do this */ const [myArray, setMyArray] = useState([]); const [arrayLength, setArrayLength] = useState(0); //duplicated data Do not have multiple components save the same data in their state. Instead, lift the state up to the appropriate level and pass the data down as a prop. /* Do this */ function App(props) { const [data, setData] = useState([]); return ( {/* pass down the data as a prop */} &lt;CardList data={data} /> ) } /* Do not do this */ function App(props) { const [data, setData] = useState([]); return ( &lt;CardList data={data} /> ) } function CardList(props) { const [data, setData] = useState(props.data); //... } Do not pass state setter functions as callbacks to child components. Instead, create a separate callback function which can call the state setter. This makes it easier to add additional processing and control logic when updating state, as well as following the Principle of Least Knowledge /* Do this */ function App(props) { const [data, setData] = useState([]); //a function to update the data const updateData = (newData) => { //can do additional processing here setData(newData); //update the state } return ( {/* pass down the callback function as a prop */} &lt;UpdateForm data={data} updateCallback={updateData} /> ) } /* Do not do this */ function App(props) { const [data, setData] = useState([]); return ( {/* Do not pass the state setter directly! */} &lt;UpdateForm data={data} updateCallback={setData} /> ) } A.4.4 Events and Forms All forms should be controlled, managing the inputted value through the Component’s state (instead of the HTML element’s state). This helps avoid data duplication, following the Don’t Repeat Yourself (DRY) Principle. /* Do this */ function ExampleForm(props) { const [inputValue, setInputValue] = useState('') const handleChange = (event) => { let newValue = event.target.value setInputValue(newValue); } return ( &lt;input type=\"text\" onChange={handleChange} value={inputValue} /> ) } A.5 Miscellaneous Guidelines Name all files and folder (source code or otherwise) with all lowercase letters. This will keep things consistent and avoid bugs across operating systems. Do not include spaces () in file names, particular for media assets—do not have a file named my puppy.png. Instead replace the space with an alternate character, such as an _, a -, or a +. Whitespace characters need to be specially encoded for URIs, which can cause problems and readability issues. "],["jest.html", "B Testing with Jest B.1 Testing B.2 Testing with Jest B.3 Writing a Test B.4 Testing Web Apps with Jest", " B Testing with Jest People just aren’t as repeatable as computers are. Nor should we expect them to be. A shell script or batch file will execute the same instructions, in the same order, time after time. It can be put under source control, so you can examine changes to the procedure over time as well (“but it used to work…”). - The Pragmatic Programmer This chapter introduces automated testing using the Jest framework. By following this tutorial, you will learn how to write and execute simple unit tests on JavaScript functions and DOM manipulating code. This tutorial references code found at https://github.com/info343/jest-tutorial. B.1 Testing One of the most important goals when developing computer programs is to make sure that the code you write actually works. You can determine if a program works by considering three things: What input was given to the program? From a user perspective, this is what actions that user took (e.g., “I pressed a button”). From a code perspective, this is often what value was passed to a method. Running the program with a particular input will lead to a received result: something will happen because of the input. From a user perspective, this would be this would be like the changes to a web page caused by the button press. From a code perspective, this could be the value returned by that function (or potentially a new value for a state variable). To know if a program worked though, you need to know the expected result of that program: what was supposed to happen because of the input? If you don’t know what the program was supposed to do, then you’ll have no way of knowing if it worked or not! You can test a program by providing the input and then comparing the received result. If the received result matches the expected result, then you know that the program worked! Testing is simply the process of providing the inputs and comparing the received and expected results Providing the input and then comparing the received and expected results can get tedious, particularly if you have lots of possible inputs or they require multiple steps (like clicking on multiple buttons). For that reason, it’s helpful to use automation to let a computer perform the testing for you. You define the expected result of some action, and the computer will check if the received result matches. Because automated testing is so useful and comment, there are a wide variety of testing frameworks: external scripts that provide the code to let you easily compare received and expected results. In JavaScript, the most popular testing frameworks are Jasmine, Mocha (which is just the framework, it uses Chai to actually compare received and expected results—hot beverages are a theme), and Jest. The later was developed by Facebook specifically to support testing React applications, and is the framework introduced and used in this course (though its API is almost identical to Jasmine and Mocha/Chai). B.2 Testing with Jest Jest is a command line program so you will need to have it installed on your machine. It can be installed globally through npm: npm install -g jest Additionally, you will need to install the dependencies listed in this repository’s package.json file, which will allow tests to use ES6 module syntax to access the functions in a separate file to test (as well as auto-complete definitions for Jest!) # install all dependencies npm install With Jest, you define “tests”, which are just JavaScript code that is used to perform the action and compare the received and expected results. These tests can either be placed in a file whose name ends with .test.js (indicating it is a test script), .spec.js (for “specification”), or a plain .js file inside the __tests__ folder in your program. In either case, a test script is just a JavaScript file, so you include any JavaScript code/variables/functions/etc. you want. B.3 Writing a Test We define a “test” (a check if a particular piece of functionality works) by calling the test() function—a predefined function provided by the Jest framework. This functions take two arguments: a string describing what the test is checking, and a callback function that will contain the code to run which does the action and compares the results. test('should do something...', function() { //regular old Javascript code that will perform the test goes here }); Test descriptions (the string parameter) are written in present tense, and state in plain English what behavior SHOULD happen. Starting the description with the word “should” is a good approach! Jest also provides a function it() that is an alias for test(), and lets the code read like badly punctuated English: it('should do something', function() { ... }); Assertions and Matchers We check that the program actually does what we’re testing by writing an assertion. An assertion is a proposition that some fact is true. In this case, we are going to assert that the expected result and the actual result are the same. If that proposition is shown to be valid (our claim that the results matched is true), then we know that our claim that the program works must hold and thus we “pass” the test! You can think of an assertion as a bit like doing the work of an if-else statement: if(received value == expected value){ test passes } else { test fails } In Jest, we put forth an assertion by calling the expect() function with an appropriate matcher. The expect() function takes a single parameter, which is the received result (produced by doing the action; e.g., calling the function with a particular input). A matcher is another function that is called directly on the returned value of expect(), and takes as an argument the expected result that we want to compare. The matcher does the work of actually comparing the values, and then reporting the validity of our claim back to Jest: test('should add numbers correctly', function() { expect(1+1).toEqual(2); }); In this case, .toEqual() is the “matcher” which compare the received and expected values to see if they are equal. Be careful about your parentheses! The expect() function should take a single expression (even if that expression includes a function call), and the matcher is called after the expect() function. Using local variables can help with readability. Jest supports a wide variety of matchers. For example: //can do numerical comparison expect(receivedNumber).toBeGreaterThan(expectedNumber); //compare against undefined expect(receivedValue).toBeDefined(); //check if defined! //find receivedValue in an array expect(receivedArray).toContain(expectedValue); //can negate ANY matcher with a .not property expect(receivedValue).not.toEqual(expectedValue); See the documentation for a complete list. Note that a single test() can include multiple assertions! Organizing Tests You can “group” tests together by using the describe() function. This function takes two parameters: a string that describes what feature is being tested, and a callback function that contains the code for the tests: describe('Basic math', function() { it('should add numbers correctly', function() { expect(1+1).toEqual(2); }); }); You should name your feature and test features so that they read as: {Feature name} should {do something specific} This will allow the test results to be communicated very clearly, even to non-developers (e.g., to your boss or client). describe() blocks can contain multiple tests(), and even other describe() blocks if you want to separate subfeatures. It is also possible to run particular blocks of code before groups of tests are run by using the beforeEach() and beforeAll() functions. See Setup and Teardown for details. Running the Tests You can run the test (have the computer perform the testing work) by using the jest command line program, passing it the name of the text script (without the extension) that you wish to run: # test the app.spec.js file jest app The command line will print out the results of this test script: An example passing script This will tell you what tests were run, which “passed” (were green for good to go!) and which “failed” (were red). Failed tests will also report which assertion failed, and what the expected and received values were that didn’t match. Practice This repo’s app.js file contains a function invertCase(). In the provides app.spec.js file, implement a describe() block to contains tests for the function, and write unit tests to check it for bugs (by giving it specific inputs and checking the received vs. the expected result). If you find any bugs, fix them and then re-run your tests! B.4 Testing Web Apps with Jest It is also possible to use Jest to JavaScript code that is used to manipulate the DOM. You can do this because Jest creates a virtual DOM that you can interact with. That is, jest provides a global document object that you can access and call methods on (e.g., document.querySelector()). This isn’t a full browser: it won’t load external CSS files or allow you to navigate to pages, but it does provide a tree of HTML elements you can modify and inspect. allowing you to test your DOM manipulation. There are a few steps to being able to work effectively with the document provided by Jest: First, you will want to make sure the content of the DOM includes the HTML elements you wish to test with. This is called mounting the content. You can mount some HTML content by assigning it to the innerHTML of the DOM’s root element—not the &lt;html&gt; element, but a virtual element that acts as the ultimate parent of the DOM (similar to the root / folder on an operating system). This node can be accessed via the document.documentElement property: //assign a given HTML content (e.g., as string) to the virtual DOM document.documentElement.innerHTML = \"&lt;html>&lt;head>&lt;/head>&lt;body>...&lt;/body>&lt;/html>\"; Often, this HTML content is read directly from the file, using Node’s fs (file system) library. Because the document object only represents the DOM tree (the rendered HTML), it won’t apply any embedded &lt;script&gt; tags. So in order to run your script on the DOM and modify it, you will need to manually apply those scripts. But since Jest has already defined you a document object to modify, you can simply tell Jest to load and run your script! Your code will do the exact same thing it does in the browser, just querying and modifying Jest’s virtual DOM (document) rather than the browser’s DOM. You load an external script in Jest by using Node’s require() function, passing it the relative path to the script file you wish to load (this script must be saved locally): //load the `index.js` file require('../js/index.js'); Note that this path is relative to the location of the test script, not relative to the location of the .html file (since Jest doesn’t use the HTML). If the script file is in the same directory as the spec file, you will need to put a ./ in front of the filename path to indicate that you’re giving a path rather than naming a module. You will need to also explicitly have Jest load any external libraries (such as jQuery) you wish to use. These libraries will need to be loaded from a local file (Jest can’t access a CDN), but they can usually be installed via npm. For example, you would load jQuery with: $ = require('jquery'); //load the jQuery module (installed from npm) window.$ = $; //assign make the jQuery library into a DOM global Remember to load any external scripts before your own! Finally, you can use DOM methods (or jQuery helpers!) to trigger events (like button clicks). You can then inspect the DOM with document.querySelector() and run assertions about the state of DOM after that user action. //for example let h1 = document.querySelector('h1'); expert(h1.textContent).toEqual('Hello world!'); And with that, you can automatically test if your page’s interactivity works as expected without needing to repeatedly click on a button. In particular, these automatic tests can help you make sure that future changes don’t break your code (e.g., don’t cause the tests to fail), performing what is called regression testing. You should still test your page inside the browser, just to catch any platform differences between Jest’s virtual DOM and actual web browsers. Practice Write a test in the provided index.spec.js file to confirm that when the “Panic” button is pressed, the HTML’s .alert element is displayed. "],["webpack.html", "C Lab: Webpack C.1 What is Webpack? C.2 Getting Started C.3 webpack.config.js C.4 Loaders", " C Lab: Webpack This lab is intended to walk you through the basics of the Webpack module bundling system. Webpack is the tool most commonly used in the React &amp; Javascript community to transpile and bundle components, and is what is used under the hood by create-react-app (we’ll be using this next week!). While that scaffolding tool means you don’t need to know how to set up Webpack, it is good to be at least somewhat familiar with the concept (and this exercise will give you further practice working with npm modules). This tutorial is adapted from one by Tyler McGinnis. C.1 What is Webpack? Webpack is a build tool. That is, it is a (command line) application that is used to automatically take the source code you write and prepare that code to be run/executed, whether for development or deployment. There are numerous such build tools in existence: Gulp is the major competitor to Webpack, and most IDEs (like jGrasp or IntelliJ) provide them. However, Webpack is favored by React developers because of how easily and speedily it transpiles JSX. At its core, Webpack is a module loader: it takes source files like JavaScript modules and bundles them into a few simplified files that can be part of your webpage. It takes your complicated source code structure (lots of files) and transforms it into a brand-new, “simplified” version (few files). C.2 Getting Started There are two things you need to do to get started: First, we need to create the package.json file to store information about the app you’re building, including dependencies that Webpack will use. You can do this with the following command: cd path/to/project npm init You will be prompted for a bunch of information to provide about your app. Give it the following details (just hit &lt;enter&gt; to accept the details on any other prompts) name should be “webpack-tutorial” author should be your name Once you’re finished, you will be asked to confirm your choices (type yes), and you’ll have a brand new package.json file ready to use! :bulb: If you just want a blank package.json file, use npm init -y to skip the prompts! Locally install the webpack program. This will allow you to run the program from the command line and bundle your app. Using the --save-dev flag saves the module to your devDependencies, which will not be bundled in the bundled version of your app. npm install --save-dev webpack C.3 webpack.config.js While Webpack can be used to do simple bundling from the command line (see the official tutorial for an example), it’s most common to write down all of your bundling options inside a configuration file. This file is basically just a JavaScript file that defines a variable that represents all of the different options you’d want to pass to the webpack program. If you name this file webpack.config.js, Webpack will read in that configuration automatically. Thus “using Webpack” really involves creating this file. Create a new file called webpack.config.js and open it up in your favorite editor (e.g., VS Code). Inside this file, add the following line of code: module.exports = {} This is the CommonJS version of the ES6 export default {}—you are defining an object (initially empty) that will be exported and used by the Webpack program. The rest of this tutorial will involve adding properties to this object. Note that is it possible to use ES 6 style import and export commands, but you need to name your file webpack.config.babel.js and will need to have some Babel libraries installed. See here for discussion. For this lab, stick to the CommonJS syntax. Webpack’s basic job is to take your source files, changing them in some way, and producing a new version. Thus there are three things you’ll need to specify: What files to transform (specifically: what JavaScript file makes your program start) What transformations to make Where to save the transformed files entry and output We specify the first piece (what files to transform) by giving the exported object an entry property: module.exports = { //list of entry points entry: [ __dirname + '/src/index.js' ] } This indicates which file (relative to the folder you are currently in) is the “start” or “entry point” into your program—in a way, which file has “main” in it. In our case, src/index.js (the __dirname is a Node constant referring to the current working directory). Note that the entry property is actually an array, since it’s possible to support multiple entry points. We’ll skip step 2 for a moment and also specify where to save the transformed files. This is specified as the output property of the config object: module.exports = { entry: [ __dirname + '/src/index.js' ], output: { filename: \"bundle.js\", path: __dirname + '/dist' }, } The output property is itself an object with more details about the output (rather than an array of possible outputs). The above example says that we should output into the dist folder (in the current directory), combining the code into a file called bundle.js. Since we don’t have webpack installed globally (which you’re welcome to do if you wish npm install -g webpack), we’ll need to add to our package.json file, to tell npm what to do with our local files! Adding to your package.json file, we’ll need to update the scripts key: ... \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\" }, ... Now, if you run npm run build, the project will build! Similar to npm install, when we run this command, we tell npm that, within this project, we want to run the build script, which will call the local version of webpack to run. When webpack runs, it looks for the webpack.config.js file, and then executes using that file to build your project! Here is roughly the output you should see: &gt; webpack-demo@1.0.0 build /Users/joelross/Desktop/webpack-demo &gt; webpack Hash: fc5c075a9cfa7ee938c0 Version: webpack 3.8.1 Time: 56ms Asset Size Chunks Chunk Names bundle.js 3 kB 0 [emitted] main [0] multi ./src/index.js 28 bytes {0} [built] [1] ./src/index.js 390 bytes {0} [built] This will create a new file dist/bundle.js. If you view this file in VS Code, you’ll see it contains some extra code that organizes the different modules into functions (to support variable scoping), one of which is the content of the index.js file! C.4 Loaders Look at all this red! This is the support that ES6 has among today’s modern browsers. What does this mean? While ES6 features are being adopted more and more, there isn’t great uniform support for it. So, we have to do a little trick called transpiling our code so that all browsers know what our Javascript is doing. To do this, we use what are called loaders. A loader is basically a plugin that is used to perform a particular transformation (e.g., transpiling JSX or even ES 6 syntax!). Webpack’s strength is its set of loaders that enable it to handle pretty much any kind of file and transformation. (It’s of course possible to write your own, but that’s well beyond the scope of this tutorial). The module property is used to specify the list of loaders: module.exports = { entry: [ __dirname + '/src/index.js' ], output: { filename: \"bundle.js\", path: __dirname + '/dist' }, module: { loaders: [ { test: /\\.jsx?$/, loaders: [\"babel-loader\"], } ] }, } The module property is an object that itself contains a loaders property, which is an array of loaders to apply. Each loader is described as an object (see? The nesting really does occur!). The test property indicates which file types we want the loader to transform. This may look scary and confusion, but that’s because it’s using a Regular Expression (similar to how you split words in the JavaScript Challenge) to specify the file extension that we want to consider. This particular expression indicates files that end in .js or .jsx (the later is often used for JSX React components). How to make sense of this expression and its crazy punctuation: Regular expressions are like Strings, but surrounded by / / instead of \" \" The . in .js needs to be escaped, so has a \\ in front of it. Like \\n for newlines. The x in .jsx is op tional (without it we have .js, which is fine), so is written with a ? after it to indicate that it can be present or not. The last $ indicates the “end of the line”, so means we’ll only talk about files that end in .js (e.g., libray.js.css wouldn’t get transformed). the loaders property is a list of which loaders we want to apply to files whose names match the “test”. In our case, we use Babel to transform our JSX, so we’ll be using \"babel\" as our loader. Babel Loader Loaders such as Babel need to be installed individually using npm as if they were separate programs (since they are in fact separate libraries!). This we will need to install the babel-loader package to be able to apply Babel transformations: npm install babel-loader --save-dev (The --save-dev argument here is like --save in that it saves the dependency into your package.json file. However, --save-dev lists the dependency as only needed for development, not for deployment. Thus if you wanted to upload your code to a web server (like on AWS), this would let that server know that it doesn’t need to install Babel because you’ve already transpiled the code into a production build). But because nothing is ever simple, the babel-loader actually requires an additional library (babel-core, which is the Babel program itself) to do its work. Thus we also need to install: npm install babel-core --save-dev Babel is able to perform all kinds of transformations, such as compiling JSX and converting ES6 syntax into older, browser-compatible versions. Babel is very modular, so each transformation we want to apply can be downloaded as an individual libraries called presets. npm install babel-preset-es2015 --save-dev This installs babel-preset-es2015 (the transformation for ES 6). Of course, downloading to preset transformations doesn’t automatically tell Babel to use them. To do that, we actually need to create another file that will contain which presets Babel should use. This file is called .babelrc (“rc” stands for “run commands”; note the leading . indicating a hidden file). Create this file in the same directory as webpack.config.js. Your .babelrc file just contains some JSON indicating which presets to use (other options are possible as well): { \"presets\": [\"es2015\"] } Altogether, you’ve specified what Babel transformations to apply (in .babelrc), and told your Webpack config file to use Babel to modify any JavaScript files. So finally, you should be able to use webpack to build a working version of your React program next week! Open the index.html file in a Browser to see your lovely app. Some things to note: All your code is inside the bundle.js file. Whenever you change your code, you will need to “re-build” your application (run webpack again). There are further webpack plugins that can help automate this, such as ones that will automatically refresh the page when the source files change. Clean up :bath: Now that we’ve put in the hard work making webpack bundle our files, let’s actually convert our files to proper ES6 synxtax and use correct import statements, given that only Chrome supports importing natively with special exceptions. Be sure to export the functions from src/sorter.js, src/looper.js and src/printer.js! Now that they’re exported, use ES6 syntax in src/index.js to import the functions &gt; Hint: 3rd syntax in the list here Delete the index.html &lt;script&gt; tags for your files. One last thing: in src/sorter.js, we’re using an npm package called lodash to sort the array. Run npm install --save lodash (--save because we want the module to be used in our final app) and then import lodash in the src/sorter.js file. Hint: use the second import syntax from the MDN docs With any luck, running npm run build one last time should give you a good output, and finally, opening index.html and looking at the console log should have your sorted user array! Further Loader Practice The webpage doesn’t look great yet, because there is no styling (CSS) involved. To practice working with webpack loaders, add an import for main.css stylesheet to your index.js, and modify webpack.config.js so that it will bundle that file: Add the import to your index.js file. The file path should be relative to the index.js file. Install the style-loader and css-loader webpack loaders (remember to --save-dev). Together, these loaders are able to handle CSS files. Add another element to the module.loaders array in the webpack.config.js file to specify the style-loader transformation. The test should be a regular expression for files ending in .css The loader itself should be \"style-loader!css-loader\", which refers to the “css loader” module for the style-loader plugin. Re-build your application using webpack. If you reload the page, you should now see it has a gray background! There are lots of further configurations and options used by Webpack. For example, you can use the webpack-dev-server to have webpack run a local server that will automatically re-bundle modules when the files change. You are encouraged to check out that example if you have time. Lab written in part by Evan Frawley "],["class-components.html", "D React Class Components D.1 Props in Class Components D.2 Handling Events in Class Components D.3 State in Class Components D.4 The Component Lifecycle Resources", " D React Class Components As mentioned in Introduction to React, it’s also possible to define React Components using ES 6 class syntax: //Define a class component representing information about a user class UserInfo extends React.Component { //Components MUST override the `render()` function, which must return a //DOM element render() { //This is an everyday function; you can include any code you want here let name = \"Ethel\"; let descriptor = \"Aardvark\"; //Return a React element (JSX) that is how the component will appear return ( &lt;div> &lt;h1>{name}&lt;/h1> &lt;p>Hello, my name is {name} and I am a {descriptor}&lt;/p> &lt;/div> ) } } This chapter contains further details on working with this style of Class Components, in particular how to manage manage state within such components. This chapter can thus be read as a mirror of [Interactive React], just using class components instead of function components. This chapter is taken from an earlier version of the text that emphasized class components instead of function components. D.1 Props in Class Components When defining a Class component, all of the passed in props are automatically assigned to the props instance variable, accessible as this.props. The this.props variable contains the object that would be passed as an argument to a function version of the component. //Define a component representing information about a user class UserInfo extends Component { render() { //access the individual props from inside the `this.props` object let userName = this.props.userName; let descriptor = this.props.descriptor; return ( &lt;div> &lt;h1>{userName}&lt;/h1> &lt;p>Hello, my name is {name} and I am a {descriptor}&lt;/p> &lt;/div> ) } } let userInfo = &lt;UserInfo userName=\"Ethel\" descriptor=\"Aardvark\" />; Note that the this.props object is read only—meaning that you cannot assign new values to it, nor modify its props directly. You should just think of props as immutable data that is coming in from outside of the component (again, similar to function arguments). A component doesn’t create or change is own props, it just uses those to determine how to render its content. D.2 Handling Events in Class Components When using class components, events are handled in the same way as with function components (e.g., using the onClick prop). The main difference is that event handler callbacks are usually defined as separate methods of the class: //A component representing a button that logs a message when clicked class MyButton extends Component { //method to call when clicked. The name is conventional, but arbitrary //the callback function will be passed the DOM event handleClick(event) { console.log('clicky clicky'); } render() { //make a button with an `onClick` attribute! //this \"registers\" the listener and sets the callback return &lt;button onClick={this.handleClick}>Click me!&lt;/button>; } } Note that when assigning the method to the onClick prop, the method is referenced using the this keyword (and no parentheses!), because the reference is to this Component’s handleClick() method. Accessing this Component from Events It is very common to have a Component’s event callback functions need to reference the instance variables or methods of that component—such as to do something based with a prop (found in this.props) or to call an additional helper method (called as this.otherMethod()). In short—the event callback will need to have access to the this context. But as discussed in Section 15.2, callback functions are not called on any particular object, and thus do not have a value assigned to their this variable. In the example above, although you’re using the word this to refer to the method this.handleClick (to tell JavaScript where to find the function), that function is not actually being called on the class. As described in Section 15.2, just because the method was defined inside a class doesn’t mean it needs to be called on an instance of that class! //BUGGY CODE: A button that causes and error when clicked! class MyButton extends Component { handleClick(event) { //Reference the object's `this.props` instance variable. But since `this` //is undefined when executed as a callback, it will cause a //TypeError: Cannot read property 'props' of undefined console.log(\"You clicked on\", this.props.text) } render() { //Specifies function (which happens to be a class method) as a callback return &lt;button onClick={this.handleClick}>{this.props.text}&lt;/button>; } } //Render the component, passing it a prop ReactDOM.render(&lt;MyButton text=\"Click me!\"/>, document.getElementById('root')); As such, you will need to make sure to “retain” the this context when specifying an event callback function. There are a few ways to do this. First, as described in Chapter 15, an arrow function will utilize the same lexical this as the context it is defined in. Thus you can “wrap” the event callback function in an arrow function in order to keep the this, calling that method on the this instance explicitly: class MyButton extends Component { handleClick(event) { console.log(\"You clicked on\", this.props.text) //functions as expected! } render() { return ( &lt;button onClick={(evt) => this.handleClick(evt) }> {this.props.text} &lt;/button> ) } } In this example, the onClick listener is passed an anonymous callback function (in the form of an arrow function), which does the work of calling the handleClick() method on the instance (this). In effect, you’re defining a “temporary” recipe to register with the event listener, whose one instruction is “follow this other recipe”. Notice that this approach also has the bonus feature of enabling you to pass additional arguments to the event callback! React does note that this approach can have a performance penalty—you are creating a new function (the arrow function) every time the component gets rendered, and components may be rendered a lot as you make React apps interactive! This won’t be noticeable as you are just getting started, but can begin to make a difference for large-scale applications. An alternative approach is to use a public class field to define the method. This is an experimental JavaScript syntax—it is currently being considered for official inclusion in the JavaScript language. However, the Babel transpiler supports this syntax (transforming it into a bound class function), and that support is enabled in Create React App allowing you to use the syntax for React apps. A public class field is a field (instance variable) that is assigned at value the “top level” of a class, rather than explicitly assigning to a property of this in the constructor. //A class with a public class field class Counter { x = 0; //assign the value here, not in the constructor increment() { this.x = this.x + 1; //can access the field as usual } } let counter = new Counter(); counter.increment(); console.log(counter.x); //outputs 1 But since you can assign any type of value to a field—including functions—you can use a public class field and define the event callback, using an arrow function to maintain the bound this context: class MyButton extends Component { //define event callback as a public class field (using an arrow function) handleClick = (event) => { console.log(\"You clicked on\", this.props.text) //functions as expected! } render() { return &lt;button onClick={this.handleClick}>{this.props.text}&lt;/button>; } } Although somewhat more tricky to read and interpret (particularly if the callback takes no parameters), this approach allows you to specify a bound function (which will have the correct value for this), while still being able to reference the function directly when registering the event listener—without having to wrap it in a separate arrow function. At the time of writing, this approach is the “cool” way that callback functions are specified in React. D.3 State in Class Components React Components store their state in the state instance variable (accessed as this.state). Unlike props that are specified as inputs to the Component, the state must be initially assigned a value, which should be done in the Component’s constructor: //A button that tracks how many times it was clicked class CountingButton extends Component { constructor(props) { //the constructor must take a `props` parameter super(props) //the constructor must call superclass constructor //initialize the Component's state this.state = { count: 0 //a value contained in the state } } render() { //can _access_ values from the state in the `render()` function return &lt;button>You clicked me {this.state.count} times&lt;/button>; } } Because Components inherit (extend) the React.Component class, their constructors must do the same work as the parent class (so that they can function in the same way). In particular, the constructor must take in a single parameter (representing the props that are passed into the Component). It must then immediately call the parent’s version of the constructor (and pass in those props) using super(props). This will cause the props to be setup correctly, so that you can use them as normal. Inside the constructor, you initialize the this.state value (and this is usually all you do in the constructor!). The this.state value must be a JavaScript Object which can store specific data—you can’t make the state a String or a Number, but an object that can contain Strings and/or Numbers (with keys to label them). You can access the values currently stored in the state through the this.state instance variable. You will usually do this in the render() (or in a helper method called by the render() function). If a value doesn’t get used for rendering, it probably doesn’t need to be part of the state! React Components must store their state in the state instance variable (accessed as this.state). Unlike props that are specified as inputs to the Component, the state must be initially assigned a value, which should be done in the Component’s constructor: //A button that tracks how many times it was clicked class CountingButton extends Component { constructor(props) { //the constructor must take a `props` parameter super(props) //the constructor must call superclass constructor //initialize the Component's state this.state = { count: 0 //a value contained in the state } } render() { //can _access_ values from the state in the `render()` function return &lt;button>You clicked me {this.state.count} times&lt;/button>; } } Because Components inherit (extend) the React.Component class, their constructors must do the same work as the parent class (so that they can function in the same way). In particular, the constructor must take in a single parameter (representing the props that are passed into the Component). It must then immediately call the parent’s version of the constructor (and pass in those props) using super(props). This will cause the props to be setup correctly, so that you can use them as normal. Inside the constructor, you initialize the this.state value (and this is usually all you do in the constructor!). The this.state value must be a JavaScript Object which can store specific data—you can’t make the state a String or a Number, but an object that can contain Strings and/or Numbers (with keys to label them). You can access the values currently stored in the state through the this.state instance variable. You will usually do this in the render() (or in a helper method called by the render() function). If a value doesn’t get used for rendering, it probably doesn’t need to be part of the state! Changing the State Data is stored in the state so that can be changed over time. You can modify a Component’s state by calling the setState() method on that Component. This method usually takes as a parameter an object that contains the new desired values for the state; this set of new values will be “merged” into the existing state, changing only the indicated values (other values will be left alone): //An element that displays the time when asked class Clock extends Component { constructor(props) { super(props) this.state = { currentTime: new Date(), //current time alarmSound: \"annoying_buzz.mp3\" //changeable alarm sound } } //callback function for the button (public class field) handleClick = (props) => { let stateChanges = { currentTime: new Date() //new value to save in the state }; this.setState(stateChanges); //apply the state changes and re-render! } render() { return ( &lt;div> &lt;button onClick={this.handleClick}>What time is it right now&lt;/button> &lt;p>The time is {this.state.currentTime.toLocaleTimeString()}&lt;/p> &lt;/div> ); } } The setState() method will “merge” the values of its parameter into the Component’s state field; in the above example, the alarmSound value will not be modified when the button is pressed; only the value for currentTime will be changed. If you want to change multiple values at the same time, you can include multiple keys in the parameter to setState(). Also note that this merging is “shallow”—if you wanted to change a state value that was an array (e.g., this.state = { comments:[...] }), you would need to set a brand new version of that array (that could be a modified version of the previous state; see below). Importantly, you must use the setState() method to change the state; you cannot assign a new value to the this.state instance variable directly. This is because the React framework uses that method to not only adjust the instance variable, but also to cause the Component to “re-render”. When the state has finished being updated, React will re-render the Component (causing it’s render() method to be called again), and merging the updated rendering into the page’s DOM. React does this merging in a highly efficient manner, changing the elements that have actually updated—this is what makes React so effective for large scale systems. Remember: calling setState() will cause the render() method to be called again, and it will access the updated this.state values! Never call setState() directly from inside of render()! That will cause an infinite recursive loop. The render() method must remain “pure” with no side effects. Moreover, the setState() method is asynchronous. Calling the method only sends a “request” to update the state; it doesn’t happen immediately. This is because React will “batch” multiple requests to update the state of Components (and so to rerender them) together—that way if your app needs to make lots of small changes at the same time, React only needs to regenerate the DOM once, providing a significant performance boost. //An Component with a callback that doesn't handle asynchronous state changes class CounterWithError extends Component { constructor(props) { super(props) this.state = { count: 3 //initial value } } handleClick = () => { this.setState({count: 4}); //change `count` to 4 console.log(this.state.count); //will output \"3\"; state has not changed yet! } //... } In this example, because setState() is asynchronous, you can’t immediately access the updated state after calling the function. If you want to use that updated value, you need to do so in the render() method, which will be called again once the state has finished being updated. Because setState() calls are asynchronous and may be batched, if you wish to update a state value based on the current state (e.g., to have a counter increase), you need to instead pass the setState() method a callback function as an argument (instead of an Object of new values). The callback function will be passed the “current” state (and props), and must return the Object that you wish to merge into the state: //An example button click callback class Counter extends Component { constructor(props) { super(props) this.state = { count: 0 } //initial value } handleClick = () => { //setState is passed an anonymous callback function this.setState((currentState, currentProps) => { //return the Object to \"merge\" into the state let stateChanges = {count: currentState.count + 1}; //increment count return stateChanges; }) } //... } While trying to use this.state directly in a call to setState() will sometimes work, best practice is to instead use a callback function as above when the new state value depends on the old. D.4 The Component Lifecycle A react component’s state is initialized in the constructor (when the component is first instantiated), and then usually modified in response to user events (by calling the setState() method). But there are a number of other “events” that occur during the life of a Component—such as the “events” of when the Component is added to the DOM (“mounted”) or removed from the DOM (“unmounted”). For example, you should only download data when there is a Component on the screen to display that data (after the Component has been added to the DOM), and to “clean up” any listeners or timers when the Component is removed. It is possible to define functions will execute at such these events, allowing you to perform specific actions as the React framework manipulates the DOM. These functions are called lifecycle methods—they are methods that are executed at different stages of the Component’s “lifecycle”. You override these lifecycle methods in order to specify what code you want to run at those events. Lifecycle methods will be automatically executed by the React framework; you never directly call these methods (the same way you never directly call render()—which is itself a lifecycle method!) React components have a number of different lifecycle methods, the most common of which are illustrated below: //A generic component class MyComponent extends Component { //The constructor is called when the Component is instantiated, but before_body //it is added to the DOM (on the screen) constructor(props){ super(props) //initialize state here! } //This method is called when the Component has been added to the DOM (and //is visible on the screen). This occurs _after_ the first `render()` call. componentDidMount() { //do (asynchronous) setup work, including AJAX requests, here! } //This method is called when a Component is being \"re-rendered\" with a //new set of props. This is a less common method to override componentDidUpdate(prevProps, prevState, snapshot) { //do additional \"re-setup\" work (including updated AJAX requests) here! } //This method is called when the Component is about to be removed from the DOM //(and thus will no longer be visible on the screen) componentWillUnmount() { //do (asynchronous) cleanup work here! } } For more details on the specific usages (and parameters!) of these methods, see the official API documentation. Note that you are not required to include these methods in a Component. However, they are required to correctly perform asynchronous functions such as AJAX requests, as described below. Lifecycle Example: Fetching Data via AJAX One of the most common use of lifecycle callback functions is when accessing data asynchronously, such as when fetching data via an AJAX request (such a described in Chapter 14). This section provides details about how to asynchronously load data within a React class component. Remember that the fetch() function downloads data asynchronously. Thus if you want to download some data to display, it may take a while to arrive. You don’t want React to have to “wait” for the data (since React is designed to be fast). Thus the best practice is to send the fetch() request for data, and then when the data has been downloaded, call the setState() method to update the Component with the downloaded data. (The Component can initialize its state as an “empty array” of data). Because fetch() will eventually call the setState() method, you can’t send the AJAX from the Component’s constructor. That’s because setState() will eventually render the Component, which involves updating something that has been added to the DOM. In the constructor, the Component has been instantiated, but has not yet been added to the DOM—thus you can’t update its state yet! If the data ends up downloading before the Component is mounted, you will get an error that you cannot re-render an unmounted Component! Instead, you should always send your (initial) fetch() requests from the componentDidMount() lifecycle method. This way the data will only be downloaded once the Component has actually been added to the DOM, and so is available for re-rendering. This structure is shown in the example below: class MyComponent extends Componet { constructor(props){ super(props); this.state = { data: [] //initialize data as \"empty\" }; } componentDidMount() { fetch(dataUri) //send AJAX request .then((res) => res.json()) .then((data) => { let processedData = data.filter(...).map(...) //do desired processing this.setState({data: processedData}) //change the state, and re-render }) } render() { //Map the data values into DOM elements //Note that this works even before data is loaded (when the array is empty!) let dataItems = this.state.data.map((item) => { return &lt;li key={item.id}>{item.value}&lt;/li>; //return DOM version of datum }) //render the data items (e.g., as a list) return &lt;ul>{dataItems}&lt;/ul>; } } In the above example, the this.state.data is initialized as an empty array; this will render() just fine (it produces an empty list). Once the Component is mounted, the data will be downloaded and processed, and then saved as an updated state value. Calling setState() will cause the Component to re-render, so that the data will be displayed as desired! While technically it means the Component is rendering twice, React can batch these requests together so that if the data downloads fast enough, the user will not notice. Resources The Component Lifecycle State and Lifecycle "],["css-in-js.html", "E CSS in JS E.1 Why CSS in JS? E.2 React Inline Styles E.3 Aphrodite E.4 CSS Modules Resources", " E CSS in JS This chapter discusses writing CSS in JS, a technique by which CSS styles and classes are defined in JavaScript rather than in separate CSS files. This technique is particularly common and useful in React, and solves a number of problems found in managing the styling of large web projects. E.1 Why CSS in JS? In November 2014, Facebook’s Christopher Chedeau gave a talk outlining many of the issues that occur when trying to develop CSS for a large application: A slide from Chedeau’s talk. Click the image to view the entire deck. In short, the talk points out how defining CSS classes in fact defines global variables: because stylesheets are loaded across the entire page, each class definition is effectively “global” and available to each Component within that page. If you define a class .button somewhere in your CSS, then every Component has access to the .button class. This becomes a problem when you want to support many different components. For example, you couldn’t use .button for multiple buttons that are all styled very differently. Instead, you would need to define different classes for each button… and be careful to make sure that the names don’t “conflict” (e.g., you don’t try defining a .button-submit for two different kinds of submit buttons!). You can use careful naming schemes (such as BEM) to make sure that your names don’t conflict, but this requires a lot of developer discipline and extra thinking—and one mistake can lead to difficult to track bugs! Moreover, CSS rules are global variables that include implicit details in their ordering (e.g., rules later in the stylesheet will override earlier ones). This is a problem when you’re trying to load lots of different style sheets for different Components—which may be loaded in different orders or even asynchronously so you don’t know which stylesheet will be loaded first! The proposed solution to this problem is to define CSS style and class definition in JavaScript as JavaScript variables, and then using a library or build tool to convert those variables into properly name-spaced CSS classes that are included in the rendered DOM. This allow each Component to define its own styling (it’s just a JavaScript variable) without worrying about conflicting global variables. Although the CSS and JavaScript will no longer be quite as separated, in the end the code you write will be simpler and easier to intuit. However, the DOM that these techniques produce will often look a lot messier (e.g., in the developer tools), with more complex class names or vast amounts of inline styling. This is generally an acceptable trade-off: the DOM isn’t directly visible to most users, and is even ignored by screen readers. Chedeau’s talk and its solution were hugely influential, marking a major shift in how web developers thought about CSS. It led to the creation of a large number of projects that provide a different ways of including CSS in JS. These libraries all do mostly the same thing, but use different syntax to solve the problem of making it easier to develop non-global CSS styles. E.2 React Inline Styles The easiest way to include CSS in JS using React is to use its built-in support for inline styling. You can define a CSS rule as a JavaScript object: /* CSS version */ h1 { font-family: 'Helvetica'; color: white; background-color: #333; } /* JavaScript version */ const h1Style = { fontFamily: 'Helvetica', color: 'white', backgroundColor: '#333' } This coincidentally requires only a few changes from how you would normally write CSS properties: you need to camelCase property names like when you refer to DOM styling (since - isn’t a legal character in JavaScript variables); you need to put all property values in quotes, and you use , instead of ; to separate properties in the object literal. You can then apply this object to a particular element by specifying it as the style attribute using JSX: &lt;h1 style={h1Style}/>Hello World!&lt;/h1> This is not actually defining a rule (it won’t apply to all &lt;h1&gt; elements), but rather is using inline styling to apply the style to only a particular element. Normally, in non-React contexts, inline styling (specifying CSS properties in an element’s style attribute) is considered bad practice. It is difficult to modify and maintain, and leads to code duplication and poor cohesion (with style rules spread out across the program). This is part of why CSS-in-JS is considered “special”: it takes what is usually bad practice and shows how, when used in a particular way (in React), it can actually produce better code! You can even use JavaScript objects to namespace particular “style” objects, allowing you to produce something akin to CSS classes (where you can organize and apply lots of properties at once): const styles = { success: { backgroundColor: 'green', color: 'white' }, failure: { backgroundColor: 'red', color: 'white' } } //... &lt;button style={styles.success}>You win!&lt;/button> &lt;button style={styles.failure}>You lose.&lt;/button> Note that these aren’t real CSS classes, but rather are simply names given to styles that are applied inline. Thus you wouldn’t refer to this button as .success (or even .style.success)—it is just a classless button that has some styles applied! E.3 Aphrodite React inline styles allow you to specify styling without creating global variables, but don’t provide actual CSS classes. This means that you lose some semantic meaning (since you can’t determine e.g., if a button is a “success” button just from the rendered DOM). You also lose the ability to handle more complex CSS rules, such as pseudo-classes (particularly ones like :hover or :active) and media queries. For these features, you instead will need to use a third-party library for support CSS-in-JS. There are a wide variety of options for libraries that can be used for author robust CSS-in-JS. One of the cleanest (in the author’s opinion) of these libraries is Aphrodite, which is developed and maintained by developers at Khan Academy. This library allows you to specify CSS classes as JavaScript objects, and then apply those classes to a React element via the className attribute as normal. You specify a collection of style classes by using the StyleSheet.create() method supplied by the library. This method is passed an object whose keys are the “class names”, similar to in the example above. You then reference the “classes” from this object by using the library’s css() function: import { StyleSheet, css } from 'aphrodite'; const styles = StyleSheet.create({ success: { backgroundColor: 'green', color: 'white' }, failure: { backgroundColor: 'red', color: 'white' } }); //... &lt;button className={css(styles.success)}>You win!&lt;/button> &lt;button className={css(styles.failure)}>You lose.&lt;/button> Note that classes are still name-spaced (e.g., styles.success, not just success), you you pass the result of the css() function to the className property. The Aphrodite library will take this StyleSheet you have defined and use it to automatically generate CSS class rules which are injected into the page, just as if you had to written them inside of a .css file! The above JSX code will produce DOM elements: &lt;button class=\"success_c72tod\">You win!&lt;/button> &lt;button class=\"failure_cioc8l\">You lose.&lt;/button> Note that the class names start with the name you gave it, but have a number of additional characters at the end (the _c72tod after success). These characters are a hash of the CSS properties contained within that classname, and are used to distinguish between different classes after they have been injected into the page and thus have become “global” variables. In effect, this library will automatically produce “unique names” for each CSS class you define (differentiated by a deterministic hash at the end), so you don’t need to worry about the success class in one Component interfering with the success class in another. Aphrodite will also let you specify pseudo-selectors and media queries. These are specified as properties of the classes they should apply to; the name of that property is (a string of) the pseudo-selector or media query, and the value of that property is another object containing the CSS properties to apply: const styles = StyleSheet.create({ //... hover: { ':hover': { backgroundColor:'gray' } }, responsive: { '@media (min-width:598px)': { fontSize:'2rem' } } }); This is different from how you normally define media queries: rather than specifying a media query with a block containing the classes it should apply, you specify a class whose block contains the media query. You can pass multiple style classes (or arrays of classes) into the css() method, and they will automatically be combined into a single unique style: //pass multiple styles into `css()` &lt;button className={css(styles.success, styles.hover)}/>You win!&lt;/button> This will render an element with the DOM: &lt;button class=\"success_c72tod-o_O-hover_2nsohz\">You win!&lt;/button> Note here that the success and hover classes have been concatenated into a single class (using -o_O- as a separator); this is to avoid any “ordering” issues—ensuring that the hover options are always applied after the success options. Aphrodite supports a few other features and edge cases, see the documentation for details. Aphrodite is just one of many different CSS-in-JS libraries, all of which have their own syntax. But almost all of them will either generate an inline style to inject into an element, or will produce their own injected stylesheet with auto-generated class names. In either case, you can focus on just styling the components without worrying about the CSS stepping on its own toes! E.4 CSS Modules Another popular approach to solving the “global scoping” problem with CSS is to utilize CSS Modules. Rather than converting JavaScript objects into CSS styles and injecting them into the page, with CSS Modules you write your class definitions in .css files as normal. The CSS Modules then post-processes the .css files at build time (similar to how SASS works), converting the CSS classes into locally scoped versions. These locally scoped classes are then imported as JavaScript objects so that they can be referenced in a manner similar to React Inline Styles: /* app-styles.css */ .success { background-color: green; color: white; } .failure { background-color: red; color: white; } /* App.js */ import styles from './app-styles.css' //... &lt;button className={styles.success}>You win!&lt;/button> &lt;button className={styles.failure}>You lose.&lt;/button> This will render DOM elements with unique, locally-scoped class names (similar to what Aphrodite does): &lt;button class=\"src-___App__success___1t37A\">You win!&lt;/button> &lt;button class=\"src-___App__failure___2BnXi\">You lose.&lt;/button> Overall, CSS Modules has the advantages of letting you write styles in .css files as usual (it’s clear where your CSS is located), can run slightly faster (since in the end, it’s just a CSS file loaded as normal), and include a few extra features that supports easy composition of classes (similar to that provided by SASS). Ejecting from Create React App CSS Modules is a post-processor that “compiles” your CSS at build time, rather than at run time. Thus in order to utilize CSS Modules, you need to configure your application’s “build system” to modularize the CSS. So far, you’ve utilized Create React App to provide a no-configuration build system (using webpack behind the scenes). However, Create React App doesn’t support CSS modules by default—you need to modify the provided Webpack system to include the modularization step. In order to modify the Webpack configuration build into Create React App, you will need to eject it. This process will change your project so that the Webpack configuration files are included as part of the source code, rather than loaded from a a single external library (react-scripts). Ejecting will allow you to modify how your React projects are built. Ejecting is a one-way operation! Once you have “extracted” the build configurations, it’s impossible to put them back (short of creating a new app and copying the files over). Be sure you want to do this! Note that if you really don’t want to eject, there are other, more fragile solutions. In order to eject your configuration information, run the following command: cd path/to/app # from the app folder npm run eject This will create two new folders in your project: scripts (which contains the build and start scripts, e.g., what happens when you run npm start), and config/ (which contains the build configuration files). The Webpack configuration files specifically can be found at config/webpack.config.dev.js (configuration for the development server) and config/webpack.config.prod.js (configuration for production builds). In order to support CSS Modules, you will need to modify both the development and production configuration files. You will need to make a simple change to the Webpack configuration files to support CSS Modules. In the webpack.config.dev.js file, at around line 160 (as of this writing), you will find a “rule” object with the property test: /\\.css$/; this specifies what processing should be applied to .css files. Modify this property: { test: /\\.css$/, use: [ require.resolve('style-loader'), { loader: require.resolve('css-loader'), options: { importLoaders: 1, //ADD THE BELOW TWO PROPERTIES!! modules: true, localIdentName: '[path]___[name]__[local]___[hash:base64:5]', }, }, //... } These changes modify the already included css-loader loader so that it supports CSS Modules (a feature that is built into the loader, but not enabled by Create React App by default). The second line specify the “pattern” that should be used for generating the compiled class names: in this case, each class is named with the file path where it is used (imported), as well as its imported name. For webpack.config.prod.js, add the same modules: true property to the object dealing with 'css-loader' (around line 180 as of this writing). You should not specify a custom localIdentName, since the default is a shorter hash that will run faster in production (though be less readable). This is the only change you need to make to utilize CSS Modules! Now you can import CSS files into your React components as illustrated above, referring to each class as a property of the imported object which can be assigned to an element’s className attribute! Note that if you want to apply multiple classes to an element, it’s often easiest to utilize the classnames package, which gives you a helper method called classNames that will easily concatenate different classnames for you. See the examples for details. react-css-modules If needing to refer to classes as style.classname is tedious, you can use the react-css-modules library to simplify your React code. This library allows you to “decorate” each component with extra functionality—in particular, it allows you to use a styleName attribute to specify classes directly, without needing to namespace them: import CSSModules from 'react-css-modules'; import styles from './app-styles.css'; class App extends Component { render() { return ( &lt;div> {/* Note the lack of `styles` namespaces! */} &lt;button styleName={success}>You win!&lt;/button> &lt;button styleName={failure}>You lose.&lt;/button> &lt;/div> ); } } export default CSSModules(App, styles); //decorate the App so it reads from the styles It is also possible to automate this decorating by using babel-plugin-react-css-modules, which is a webpack plugin that will automatically process the styleName attributes in the JSX at build time (e.g., it changes how the JSX is compiled!). This provides a significant performance benefit (as well as making your code cleaner). In order to support babel-plugin-react-css-modules, install the library with npm and modify the Webpack config file. Modify the “rule” object with the property test: /\\.(js|jsx|mjs)$/ (which applies to .js files): { test: /\\.(js|jsx|mjs)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: { cacheDirectory: true, //ADD THE BELOW PROPERTY!! plugins: [ 'react-css-modules' ] }, } This will apply the plugin whenever the JavaScript files are transpiled, allowing you to utilize the styleName without explicitly using the react-css-modules library. Note that this plugin has a bug whereby changes to how CSS Modules are composed (see below) aren’t applied when the ejected Webpack’s developer server automatically reloads the browser window. See this issue. Composing Classes The other main feature of CSS Modules is the ability to compose classes—that is, you can specify that one CSS class contains all the properties defined by another. This is similar in functionality to the @extends keyword in SASS (though it only affects the classes as they are exported to JavaScript): CSS classes are composed by specifying a composes property with a value that is the name of the class to “include”: .base { font-family: 'Helvetica'; font-size: 2rem; } .success { composes: base; /* include the .base properties */ background-color: green; /* additional properties only for .success */ } .failure { composes: base; background-color: red; /* additional properties only for .failure */ } When applied to the previous example (the two &lt;button&gt; elements), this will render as two separate CSS classes: &lt;button class=\"src-___App__success___1t37A src-___App__base___LeFt5\">You win!&lt;/button> &lt;button class=\"src-___App__failure___2BnXi src-___App__base___LeFt5\">You win!&lt;/button> While you can still specify just a single class in your JavaScript (e.g., className={style.success}), CSS Modules will automatically apply all of the “dependent” styles to your element! Moreover, you can also compose CSS classes across separate files by specifying the value as coming from \"filename\": /* colors.css */ .success { color: green; } /* app-styles.css */ .success { composes: base; composes: success from \"../colors.css\"; /* loads the color from another file */ } This makes it possible to break up your CSS classes into a large number of individual “helper” modules: for example, you could have a colors.css file that defines coloring schemes, a fonts.css file that defines classes that only handle fonts (e.g., .large), a layout.css file that defines classes that only handle layout (e.g., padding-small, margin-top-large), and so forth: /* example from docs */ .element { composes: large from \"./fonts.css\"; composes: dark-text from \"./colors.css\"; composes: padding-all-medium from \"./layout.css\"; composes: subtle-shadow from \"./effect.css\"; } In effect, you can use different files you develop your own set of Bootstrap-style utility classes! This may seem like overkill for a small app, but can be a great help when you’re trying to design a large app (e.g., the size of Facebook) or a want to be able to consistently “theme” related but vastly different apps (think Gmail and Google Drive). For more details and examples, see this tutorial introducing CSS Modules. Resources React: CSS in JS - the talk pitching CSS in JS as an approach FAQ: Styling and CSS (React) Aphrodite documentation Inline CSS at Khan Academy - explanation and justification for the design choices used in Aphrodite. CSS Modules: Welcome to the Future - a step-by-step walk though and introduction "],["redux.html", "F Redux", " F Redux See official documentation at https://redux.js.org/, https://redux.js.org/docs/introduction/, and https://redux.js.org/docs/basics/. "],["react-native.html", "G React Native G.1 Getting Setup G.2 React Native Apps", " G React Native As a special topic, this chapter provides a brief introduction to React Native, a framework for using React to build mobile applications (e.g., apps for Android or iOS). The React Native framework provides a set of build tools that allow you to compile React code (written in JavaScript) into native mobile code (Java for Android; Objective-C for iOS). This allows you to utilize your existing knowledge of client-side web development to also create mobile apps as if you had written them in their normal development language! Moreover, the same React code can be converted into apps for both iOS and Android (as well as for the web), with you only needing to adjust any platform-specific features. Three platforms for the price of one! This chapter’s explanation mirrors the official tutorial for React Native; see that for more details. G.1 Getting Setup The easiest way to start a new React Native application is to use the create-react-native-app program. This works almost identically to the create-react-app program you know and love, except it will scaffold you a React Native application and provide build scripts utilizes for testing and developing native apps. To use this program install it globally, and then execute it to create a new React Native project in the current folder: create-react-native-app MyNativeApp This scaffolding will include a number of configuration files (see the User Guide for details), but you’ll mostly be interested in App.js, whose default export will be the “root” component of your application (mobile apps are usually designed around a View component that is shown, rather than an index.js style script to execute). create-react-native-app doesn’t currently work with npm version 5.0 or greater. Until this is fixed, the best solution is to use yarn to install and manage react native applications. Note that installing yarn may cause issues with npm that you’d need to resolve: proceed with caution if under a deadline! Alternatively, you can downgrade to an older version of npm using npm install -g npm@4 Running React Native Apps There are a few different ways to “run” and test your application as you’re developing it, depending on the platform (Android or iOS) you’re targeting: For either platform, you can test your React Native code on a physical device by using the Expo app. This is a separate mobile application that “connects” to a server run by the create-react-native-app build scripts, displaying updates to your app in real time. In order to use Expo, install the app on your phone, and then use npm start to begin the development server. The server will show a QR code in the command line that you can scan to have your phone connect to the server (assuming they are on the same wireless network); this will run your developed app on the phone, and even automatically refresh it when you save changes to the file! It is also possible to run your React Native app on virtual devices (e.g., emulators) for either platform. These are “virtual” phones that run on your own computer, allowing you to develop and test mobile apps without needing a specific device. Note that you will need to have the appropriate development environment installed and set up for each platform: Android Studio for Android, and Xcode for iOS. Xcode only runs on MacOS. For Android, you will need to create and start up an emulator with Android Studio: go to Tools &gt; Android &gt; AVD Manager to open up the Android Virtual Device Manager. You can then choose “Create Virtual Device…” in order to launch the wizard to specify a new emulator. You can then install and run an app on the emulator (using Expo) via the npm run android command. You can access the development menu on the device from the notification, or by hitting cmd-m. For iOS, you can start up the Simulator program (it is found inside Xcode.app/Contents/Developer/Applications. If you right-click on the Xcode.app program and select “Show Package Contents”, you will be able to navigate to it). You will then be able to install and run an app on Simulator (using Expo) via the npm run ios command. You can access the development menu on the device by hitting cmd-d. Finally, Expo Snack allows you to develop, test, and run simple React Native apps entirely online! This can be a good way to test out the design or to share code snippets with others. G.2 React Native Apps Writing React Native code uses the same process and techniques as writing normal React code: you define Components that render Views, which themselves are made up of more Components! These components can be passed in props and track state just like in React. In fact, if you look at the default App.js file created by create-react-native-app, you’ll see that it’s just basic React code. However, instead of eventually rendering HTML elements (such as &lt;div&gt; or &lt;button&gt;), React Native apps render one of the framework’s built-in components. Each of these components is able to be “compiled” into a an appropriate “native” version. For example, a &lt;View&gt; is compiled into a &lt;div&gt; element on the web, an android.View element on Android, and a UIView element on iOS. Just as React components almost always return a &lt;div&gt; with some content nested inside of it, React Native components almost always return a &lt;View&gt; with some content nested inside of it. &lt;View&gt; elements are particularly important when styling your app; see below. Other basic components include: &lt;Text&gt; components represent displayed text (similar in purpose to a &lt;p&gt;, though they get compiled into inline &lt;span&gt; elements on the web). All displayed text must be inside one of these elements; you can’t have a “text node” directly under a &lt;View&gt; like you can in HTML. &lt;Text&gt; elements also support cascading styling. &lt;Image&gt; components are used to display images (similar to a &lt;img&gt;). You specify which image to display by passing in a source prop. This can be a remote reference (e.g., https://domain.com/picture.png), or a local image. In order to refer to a local image file, you should import it using Node’s require() method, specifying the path to the image file relative to the Component. This will the build tools to load the file as a data URI when rendering the image, and ensuring that the asset is packaged with the native app correctly. &lt;Image source={ require('./path/to/picture.png') }/> Additionally, you should always specify an accessibilityLabel prop specifying how the image should be read to screen readers (yes, they exist for mobile devices! Blind people also use phones). Styling React Native You customize the appearance of React Native components by specifying styling properties in their style prop, similar to React inline styling. Note that Android and iOS don’t support CSS, so you don’t utilize className in React Native. However, because it’s often useful to organize styles into groups and give them labels, React Native provides a Stylesheet.create() similar to that used by Aphrodite. Defining a stylesheet helps with code organization, as well as providing a more efficient native implementation (since you don’t need to duplicate style objects)—and efficient matters a lot more on resource-constrained mobile devices! Although you specify style properties similar to CSS properties (e.g., with the same property names), React Native stylesheets do not use CSS! In particular, styles do not normally cascade: specifying the fontSize for a &lt;View&gt; will not cause that property to be applied to multiple nested &lt;Text&gt; elements. This feature is missing because styling does not normally cascade in Android and iOS, and React Native can run more effectively by not needing to traverse the element tree to check if each and every property is defined by a parent. Moreover, this means that each component can be better isolated (developed as a stand-alone, drop-in piece of an application), because there is no chance of accidentally inheriting some styling. However, nested &lt;Text&gt; components will inherit from their parents as a convenience, allowing you to easily style parts of a text block (e.g., to make some text highlighted). You can specify an element’s size by setting it’s width and height style properties. These properties should be assigned unitless numbers (you don’t include px or rem). The value measures the number of density-independent pixels, which is a pixel-value that scales based on the resolution (dots-per-inch, or dpi) of the device. This allows the sizing to be consistent on “retina” displays. Any elements that are not given a fixed size—as well as any element positioning—is primarily performed with Flexbox properties! The Flexbox framework allows you to provide a layout that will be consistent across different screen sizes. The “root” element (usually a &lt;View&gt;) of a component is rendered as a “flex item”, but each &lt;View&gt; can also be made into its own “flex container” in order to specify the direction (which defaults to a vertical “column”), size, or spacing of its content: //declare a stylesheet const styles = StyleSheet.create({ outer: { flex: 1; //this View should fill vertical space flexDirection: 'row'; //children should be layed out horizontally } inner: { flex: 1; //take up equal extra space } }) //an example app export default class App { render() { return ( &lt;View style={styles.outer}> &lt;Text style={styles.inner}>Item 1&lt;/Text> &lt;Text style={styles.inner}>Item 2&lt;/Text> &lt;Text style={styles.inner}>Item 2&lt;/Text> &lt;/View> ) } } Interaction React Native apps can be made interactive using a similar process to regular React apps: you specify an event handler which can be used to modify the state and re-render the component. However, The events that you listen for are slightly different with React Native. For example, a &lt;Button&gt; element accepts an onPress property (instead of onClick): &lt;Button onPress={() => this.handlePress()}>Press me!&lt;/Button> Note that the callback is not passed any parameters, so you don’t have an event to work with. In order to get text input, you use a &lt;TextInput&gt; component (which is a lot like an &lt;input type=\"text\"&gt; element in HTML). This element can be made to be a controlled input just like with normal React, though you would use the onChangeText prop to listen for text changes (the callback function will be passed in the updated text): &lt;TextInput placeholder=\"Type something!\" value={this.state.inputValue} onChangeText={ (newText) => this.setState({inputValue:newText}) } /> Lists and Data Information applications often need to display lists of data values (e.g., a list of tasks to complete). While it is possible to map() an array variable to an array of &lt;View&gt; elements to render, Android and iOS support more specific techniques that allow for better responsiveness and efficiency when displayed on mobile devices. For example, these components will automatically render only a “portion” of the list that is currently visible on the small screen, loading new Views into memory only when the user scrolls down to see them. This allows the user to smoothly “flick” through a list of items. You can create such an optimized list in React Native by rendering a &lt;FlatList&gt; component. This component takes two main properties: data, which is an array of data values to “map” into Views; and renderItem, which is a function that does the “mapping” (similar to the render function for react-router): &lt;FlatList data={myDataArray} renderItem={ (args) => &lt;Text>{args.item.text}&lt;/Text> } /> Each element in the data array must contain a key property that React uses to keep track of each item in the list (though you can pass a function that extracts a value as the key to the keyExtractor prop). The actual “data item” will be found in the item property of the callback function’s arguments (the index property will contain the index of that item). However, it’s common to use object destructuring to instead only pass the the specific property of the parameter object: function renderListItem({item}) { //param is `item = args.item` return &lt;Text>{item.text}&lt;/Text>; //can access item directly } function renderWithIndex({item, index}) { //gets two params: args.item and args.index return &lt;Text>{index} - {item.text}&lt;/TEXT>; } If you would like to download data from the internet to display using React Native, you use the fetch() API just like you’ve used in the web! export default class App extends Component { constructor(props){ super(props); this.state = {data:[]} } componentDidMount() { fetch(dataURI) .then((res) => res.json()) .then((data) => { this.setState({data: data}); }) .catch((err) => console.error) } render() { return ( &lt;View> &lt;FlatList data={this.state.data} renderItem={({item}) => &lt;Text>{item.text}&lt;/Text>} /> &lt;/View> ) } } Overall, React Native is simply another way of building (but not implementing!) React applications, and makes heavy use of many of the modern frameworks and techniques (e.g., Flexbox, fetch) discussed throughout this course "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
